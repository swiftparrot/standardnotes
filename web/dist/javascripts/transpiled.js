(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _get3 = require("babel-runtime/helpers/get");

var _get4 = _interopRequireDefault(_get3);

var _asyncToGenerator3 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator4 = _interopRequireDefault(_asyncToGenerator3);

var _classCallCheck3 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck4 = _interopRequireDefault(_classCallCheck3);

var _createClass3 = require("babel-runtime/helpers/createClass");

var _createClass4 = _interopRequireDefault(_createClass3);

var _possibleConstructorReturn3 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn4 = _interopRequireDefault(_possibleConstructorReturn3);

var _inherits3 = require("babel-runtime/helpers/inherits");

var _inherits4 = _interopRequireDefault(_inherits3);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SNTheme = exports.SNSmartTag = exports.SNServerExtension = exports.SNMfa = exports.SNEncryptedStorage = exports.SNTag = exports.SNNote = exports.SNExtension = exports.Action = exports.SNEditor = exports.SNComponent = exports.SNComponentManager = undefined;

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _standardFileJs = require("standard-file-js");

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _asyncToGenerator(fn) {
  return function () {
    var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);var value = info.value;
        } catch (error) {
          reject(error);return;
        }if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }return step("next");
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var SNComponentManager = exports.SNComponentManager = function () {

  /*
    @param {string} environment: one of [web, desktop, mobile]
    @param {string} platform: one of [ios, android, linux-${environment}, mac-${environment}, windows-${environment}]
  */
  function SNComponentManager(_ref) {
    var modelManager = _ref.modelManager,
        syncManager = _ref.syncManager,
        desktopManager = _ref.desktopManager,
        nativeExtManager = _ref.nativeExtManager,
        alertManager = _ref.alertManager,
        $uiRunner = _ref.$uiRunner,
        $timeout = _ref.$timeout,
        environment = _ref.environment,
        platform = _ref.platform;

    _classCallCheck(this, SNComponentManager);

    /* This domain will be used to save context item client data */
    SNComponentManager.ClientDataDomain = "org.standardnotes.sn.components";

    // Some actions need to be run on the ui thread (desktop/web only)
    this.$uiRunner = $uiRunner || function (fn) {
      fn();
    };
    this.$timeout = $timeout || setTimeout.bind(window);

    this.modelManager = modelManager;
    this.syncManager = syncManager;
    this.desktopManager = desktopManager;
    this.nativeExtManager = nativeExtManager;
    this.alertManager = alertManager;

    this.streamObservers = [];
    this.contextStreamObservers = [];
    this.activeComponents = [];

    this.environment = environment;
    this.platform = platform;
    this.isDesktop = this.environment == "desktop";
    this.isMobile = this.environment == "mobile";

    if (environment != "mobile") {
      this.configureForNonMobileUsage();
    }

    this.configureForGeneralUsage();

    // this.loggingEnabled = true;

    this.permissionDialogs = [];

    this.handlers = [];
  }

  _createClass(SNComponentManager, [{
    key: "configureForGeneralUsage",
    value: function configureForGeneralUsage() {
      var _this = this;

      this.modelManager.addItemSyncObserver("component-manager", "*", function (allItems, validItems, deletedItems, source, sourceKey) {
        var syncedComponents = allItems.filter(function (item) {
          return item.content_type === "SN|Component" || item.content_type == "SN|Theme";
        });

        /* We only want to sync if the item source is Retrieved, not MappingSourceRemoteSaved to avoid
          recursion caused by the component being modified and saved after it is updated.
        */
        if (syncedComponents.length > 0 && source != SFModelManager.MappingSourceRemoteSaved) {
          // Ensure any component in our data is installed by the system
          if (_this.isDesktop) {
            _this.desktopManager.syncComponentsInstallation(syncedComponents);
          }
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = syncedComponents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var component = _step.value;

            var activeComponent = _.find(_this.activeComponents, { uuid: component.uuid });
            if (component.active && !component.deleted && !activeComponent) {
              _this.activateComponent(component);
            } else if (!component.active && activeComponent) {
              _this.deactivateComponent(component);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _loop = function _loop(observer) {
          if (sourceKey && sourceKey == observer.component.uuid) {
            // Don't notify source of change, as it is the originator, doesn't need duplicate event.
            return "continue";
          }

          var relevantItems = allItems.filter(function (item) {
            return observer.contentTypes.indexOf(item.content_type) !== -1;
          });

          if (relevantItems.length == 0) {
            return "continue";
          }

          var requiredPermissions = [{
            name: "stream-items",
            content_types: observer.contentTypes.sort()
          }];

          _this.runWithPermissions(observer.component, requiredPermissions, function () {
            _this.sendItemsInReply(observer.component, relevantItems, observer.originalMessage);
          });
        };

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _this.streamObservers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var observer = _step2.value;

            var _ret = _loop(observer);

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var requiredContextPermissions = [{
          name: "stream-context-item"
        }];

        var _loop2 = function _loop2(observer) {
          if (sourceKey && sourceKey == observer.component.uuid) {
            // Don't notify source of change, as it is the originator, doesn't need duplicate event.
            return "continue";
          }

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = _this.handlers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var handler = _step4.value;

              if (!handler.areas.includes(observer.component.area) && !handler.areas.includes("*")) {
                continue;
              }
              if (handler.contextRequestHandler) {
                itemInContext = handler.contextRequestHandler(observer.component);

                if (itemInContext) {
                  matchingItem = _.find(allItems, { uuid: itemInContext.uuid });

                  if (matchingItem) {
                    _this.runWithPermissions(observer.component, requiredContextPermissions, function () {
                      _this.sendContextItemInReply(observer.component, matchingItem, observer.originalMessage, source);
                    });
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        };

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _this.contextStreamObservers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var observer = _step3.value;
            var itemInContext;
            var matchingItem;

            var _ret2 = _loop2(observer);

            if (_ret2 === "continue") continue;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      });
    }
  }, {
    key: "configureForNonMobileUsage",
    value: function configureForNonMobileUsage() {
      var _this2 = this;

      var detectFocusChange = function detectFocusChange(event) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = _this2.activeComponents[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var component = _step5.value;

            if (document.activeElement == _this2.iframeForComponent(component)) {
              _this2.$timeout(function () {
                _this2.focusChangedForComponent(component);
              });
              break;
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      };

      window.addEventListener ? window.addEventListener('focus', detectFocusChange, true) : window.attachEvent('onfocusout', detectFocusChange);
      window.addEventListener ? window.addEventListener('blur', detectFocusChange, true) : window.attachEvent('onblur', detectFocusChange);

      this.desktopManager.registerUpdateObserver(function (component) {
        // Reload theme if active
        if (component.active && component.isTheme()) {
          _this2.postActiveThemesToAllComponents();
        }
      });

      // On mobile, events listeners are handled by a respective component
      window.addEventListener("message", function (event) {
        if (_this2.loggingEnabled) {
          console.log("Web app: received message", event);
        }

        // Make sure this message is for us
        if (event.data.sessionKey) {
          _this2.handleMessage(_this2.componentForSessionKey(event.data.sessionKey), event.data);
        }
      }, false);
    }
  }, {
    key: "postActiveThemesToAllComponents",
    value: function postActiveThemesToAllComponents() {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.components[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var component = _step6.value;

          // Skip over components that are themes themselves,
          // or components that are not active, or components that don't have a window
          if (component.isTheme() || !component.active || !component.window) {
            continue;
          }

          this.postActiveThemesToComponent(component);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  }, {
    key: "getActiveThemes",
    value: function getActiveThemes() {
      return this.componentsForArea("themes").filter(function (theme) {
        return theme.active;
      });
    }
  }, {
    key: "urlsForActiveThemes",
    value: function urlsForActiveThemes() {
      var _this3 = this;

      var themes = this.getActiveThemes();
      return themes.map(function (theme) {
        return _this3.urlForComponent(theme);
      });
    }
  }, {
    key: "postActiveThemesToComponent",
    value: function postActiveThemesToComponent(component) {
      var urls = this.urlsForActiveThemes();
      var data = { themes: urls };

      this.sendMessageToComponent(component, { action: "themes", data: data });
    }
  }, {
    key: "contextItemDidChangeInArea",
    value: function contextItemDidChangeInArea(area) {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.handlers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var handler = _step7.value;

          if (handler.areas.includes(area) === false && !handler.areas.includes("*")) {
            continue;
          }
          var observers = this.contextStreamObservers.filter(function (observer) {
            return observer.component.area === area;
          });

          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = observers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var observer = _step8.value;

              if (handler.contextRequestHandler) {
                var itemInContext = handler.contextRequestHandler(observer.component);
                if (itemInContext) {
                  this.sendContextItemInReply(observer.component, itemInContext, observer.originalMessage);
                }
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  }, {
    key: "setComponentHidden",
    value: function setComponentHidden(component, hidden) {
      /*
        A hidden component will not receive messages.
        However, when a component is unhidden, we need to send it any items it may have
        registered streaming for.
      */
      if (hidden) {
        component.hidden = true;
      } else if (component.hidden) {
        // Only enter this condition if component is hidden to make this note have double side effects.
        component.hidden = false;

        // streamContextItem
        var contextObserver = _.find(this.contextStreamObservers, { identifier: component.uuid });
        if (contextObserver) {
          this.handleStreamContextItemMessage(component, contextObserver.originalMessage);
        }

        // streamItems
        var streamObserver = _.find(this.streamObservers, { identifier: component.uuid });
        if (streamObserver) {
          this.handleStreamItemsMessage(component, streamObserver.originalMessage);
        }
      }
    }
  }, {
    key: "jsonForItem",
    value: function jsonForItem(item, component, source) {
      var params = { uuid: item.uuid, content_type: item.content_type, created_at: item.created_at, updated_at: item.updated_at, deleted: item.deleted };
      params.content = item.createContentJSONFromProperties();
      params.clientData = item.getDomainDataItem(component.getClientDataKey(), SNComponentManager.ClientDataDomain) || {};

      // isMetadataUpdate implies that the extension should make reference of updated metadata,
      // but not update content values as they may be stale relative to what the extension currently has
      // Changes are always metadata updates if the mapping source is SFModelManager.MappingSourceRemoteSaved || source == SFModelManager.MappingSourceLocalSaved.
      //
      if (source && (source == SFModelManager.MappingSourceRemoteSaved || source == SFModelManager.MappingSourceLocalSaved)) {
        params.isMetadataUpdate = true;
      }

      this.removePrivatePropertiesFromResponseItems([params], component, { type: "outgoing" });
      return params;
    }
  }, {
    key: "sendItemsInReply",
    value: function sendItemsInReply(component, items, message, source) {
      var _this4 = this;

      if (this.loggingEnabled) {
        console.log("Web|componentManager|sendItemsInReply", component, items, message);
      };
      var response = { items: {} };
      var mapped = items.map(function (item) {
        return _this4.jsonForItem(item, component, source);
      });

      response.items = mapped;
      this.replyToMessage(component, message, response);
    }
  }, {
    key: "sendContextItemInReply",
    value: function sendContextItemInReply(component, item, originalMessage, source) {
      if (this.loggingEnabled) {
        console.log("Web|componentManager|sendContextItemInReply", component, item, originalMessage);
      };
      var response = { item: this.jsonForItem(item, component, source) };
      this.replyToMessage(component, originalMessage, response);
    }
  }, {
    key: "replyToMessage",
    value: function replyToMessage(component, originalMessage, replyData) {
      var reply = {
        action: "reply",
        original: originalMessage,
        data: replyData
      };

      this.sendMessageToComponent(component, reply);
    }
  }, {
    key: "sendMessageToComponent",
    value: function sendMessageToComponent(component, message) {
      var permissibleActionsWhileHidden = ["component-registered", "themes"];
      if (component.hidden && !permissibleActionsWhileHidden.includes(message.action)) {
        if (this.loggingEnabled) {
          console.log("Component disabled for current item, not sending any messages.", component.name);
        }
        return;
      }

      if (this.loggingEnabled) {
        console.log("Web|sendMessageToComponent", component, message);
      }

      var origin = this.urlForComponent(component, "file://");
      if (!origin.startsWith("http") && !origin.startsWith("file")) {
        // Native extension running in web, prefix current host
        origin = window.location.href + origin;
      }

      if (!component.window) {
        this.alertManager.alert({ text: "Standard Notes is trying to communicate with " + component.name + ", but an error is occurring. Please restart this extension and try again." });
      }

      // Mobile messaging requires json
      if (this.isMobile) {
        message = JSON.stringify(message);
      }

      component.window.postMessage(message, origin);
    }
  }, {
    key: "componentsForArea",
    value: function componentsForArea(area) {
      return this.components.filter(function (component) {
        return component.area === area;
      });
    }
  }, {
    key: "urlForComponent",
    value: function urlForComponent(component) {
      var offlinePrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      // offlineOnly is available only on desktop, and not on web or mobile.
      if (component.offlineOnly && !this.isDesktop) {
        return null;
      }

      if (component.offlineOnly || this.isDesktop && component.local_url) {
        return component.local_url && component.local_url.replace("sn://", offlinePrefix + this.desktopManager.getApplicationDataPath() + "/");
      } else {
        var url = component.hosted_url || component.legacy_url;
        if (this.isMobile) {
          var localReplacement = this.platform == "ios" ? "localhost" : "10.0.2.2";
          url = url.replace("localhost", localReplacement).replace("sn.local", localReplacement);
        }
        return url;
      }
    }
  }, {
    key: "componentForUrl",
    value: function componentForUrl(url) {
      return this.components.filter(function (component) {
        return component.hosted_url === url || component.legacy_url === url;
      })[0];
    }
  }, {
    key: "componentForSessionKey",
    value: function componentForSessionKey(key) {
      var component = _.find(this.components, { sessionKey: key });
      if (!component) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = this.handlers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var handler = _step9.value;

            if (handler.componentForSessionKeyHandler) {
              component = handler.componentForSessionKeyHandler(key);
              if (component) {
                break;
              }
            }
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }
      return component;
    }
  }, {
    key: "handleMessage",
    value: function handleMessage(component, message) {
      var _this5 = this;

      if (!component) {
        console.log("Component not defined for message, returning", message);
        this.alertManager.alert({ text: "An extension is trying to communicate with Standard Notes, but there is an error establishing a bridge. Please restart the app and try again." });
        return;
      }

      // Actions that won't succeeed with readonly mode
      var readwriteActions = ["save-items", "associate-item", "deassociate-item", "create-item", "create-items", "delete-items", "set-component-data"];

      if (component.readonly && readwriteActions.includes(message.action)) {
        // A component can be marked readonly if changes should not be saved.
        // Particullary used for revision preview windows where the notes should not be savable.
        this.alertManager.alert({ text: "The extension " + component.name + " is trying to save, but it is in a locked state and cannot accept changes." });
        return;
      }

      /**
      Possible Messages:
        set-size
        stream-items
        stream-context-item
        save-items
        select-item
        associate-item
        deassociate-item
        clear-selection
        create-item
        create-items
        delete-items
        set-component-data
        install-local-component
        toggle-activate-component
        request-permissions
        present-conflict-resolution
      */

      if (message.action === "stream-items") {
        this.handleStreamItemsMessage(component, message);
      } else if (message.action === "stream-context-item") {
        this.handleStreamContextItemMessage(component, message);
      } else if (message.action === "set-component-data") {
        this.handleSetComponentDataMessage(component, message);
      } else if (message.action === "delete-items") {
        this.handleDeleteItemsMessage(component, message);
      } else if (message.action === "create-items" || message.action === "create-item") {
        this.handleCreateItemsMessage(component, message);
      } else if (message.action === "save-items") {
        this.handleSaveItemsMessage(component, message);
      } else if (message.action === "toggle-activate-component") {
        var componentToToggle = this.modelManager.findItem(message.data.uuid);
        this.handleToggleComponentMessage(component, componentToToggle, message);
      } else if (message.action === "request-permissions") {
        this.handleRequestPermissionsMessage(component, message);
      } else if (message.action === "install-local-component") {
        this.handleInstallLocalComponentMessage(component, message);
      } else if (message.action === "duplicate-item") {
        this.handleDuplicateItemMessage(component, message);
      }

      // Notify observers

      var _loop3 = function _loop3(handler) {
        if (handler.actionHandler && (handler.areas.includes(component.area) || handler.areas.includes("*"))) {
          _this5.$timeout(function () {
            handler.actionHandler(component, message.action, message.data);
          });
        }
      };

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = this.handlers[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var handler = _step10.value;

          _loop3(handler);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
  }, {
    key: "removePrivatePropertiesFromResponseItems",
    value: function removePrivatePropertiesFromResponseItems(responseItems, component) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // can be 'incoming' or 'outgoing'. We want to remove updated_at if incoming, but keep it if outgoing
      if (options.type == "incoming") {
        var privateTopLevelProperties = ["updated_at"];
        // Maintaining our own updated_at value is imperative for sync to work properly, we ignore any incoming value.
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = responseItems[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var responseItem = _step11.value;

            if (typeof responseItem.setDirty === 'function') {
              console.error("Attempting to pass object. Use JSON.");
              continue;
            }
            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
              for (var _iterator12 = privateTopLevelProperties[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var privateProperty = _step12.value;

                delete responseItem[privateProperty];
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      }

      if (component) {
        // System extensions can bypass this step
        if (this.nativeExtManager && this.nativeExtManager.isSystemExtension(component)) {
          return;
        }
      }
      // Don't allow component to overwrite these properties.
      var privateContentProperties = ["autoupdateDisabled", "permissions", "active"];
      if (options) {
        if (options.includeUrls) {
          privateContentProperties = privateContentProperties.concat(["url", "hosted_url", "local_url"]);
        }
      }
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = responseItems[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var _responseItem = _step13.value;

          // Do not pass in actual items here, otherwise that would be destructive.
          // Instead, generic JS/JSON objects should be passed.
          if (typeof _responseItem.setDirty === 'function') {
            console.error("Attempting to pass object. Use JSON.");
            continue;
          }

          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = privateContentProperties[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var prop = _step14.value;

              delete _responseItem.content[prop];
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14.return) {
                _iterator14.return();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13.return) {
            _iterator13.return();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    }
  }, {
    key: "handleStreamItemsMessage",
    value: function handleStreamItemsMessage(component, message) {
      var _this6 = this;

      var requiredPermissions = [{
        name: "stream-items",
        content_types: message.data.content_types.sort()
      }];

      this.runWithPermissions(component, requiredPermissions, function () {
        if (!_.find(_this6.streamObservers, { identifier: component.uuid })) {
          // for pushing laster as changes come in
          _this6.streamObservers.push({
            identifier: component.uuid,
            component: component,
            originalMessage: message,
            contentTypes: message.data.content_types
          });
        }

        // push immediately now
        var items = [];
        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          for (var _iterator15 = message.data.content_types[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            var contentType = _step15.value;

            items = items.concat(_this6.modelManager.validItemsForContentType(contentType));
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15.return) {
              _iterator15.return();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }

        _this6.sendItemsInReply(component, items, message);
      });
    }
  }, {
    key: "handleStreamContextItemMessage",
    value: function handleStreamContextItemMessage(component, message) {
      var _this7 = this;

      var requiredPermissions = [{
        name: "stream-context-item"
      }];

      this.runWithPermissions(component, requiredPermissions, function () {
        if (!_.find(_this7.contextStreamObservers, { identifier: component.uuid })) {
          // for pushing laster as changes come in
          _this7.contextStreamObservers.push({
            identifier: component.uuid,
            component: component,
            originalMessage: message
          });
        }

        // push immediately now
        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = _this7.handlersForArea(component.area)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var handler = _step16.value;

            if (handler.contextRequestHandler) {
              var itemInContext = handler.contextRequestHandler(component);
              if (itemInContext) {
                _this7.sendContextItemInReply(component, itemInContext, message);
              }
            }
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16.return) {
              _iterator16.return();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }
      });
    }
  }, {
    key: "isItemIdWithinComponentContextJurisdiction",
    value: function isItemIdWithinComponentContextJurisdiction(uuid, component) {
      var itemIdsInJurisdiction = this.itemIdsInContextJurisdictionForComponent(component);
      return itemIdsInJurisdiction.includes(uuid);
    }

    /* Returns items that given component has context permissions for */

  }, {
    key: "itemIdsInContextJurisdictionForComponent",
    value: function itemIdsInContextJurisdictionForComponent(component) {
      var itemIds = [];
      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = this.handlersForArea(component.area)[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var handler = _step17.value;

          if (handler.contextRequestHandler) {
            var itemInContext = handler.contextRequestHandler(component);
            if (itemInContext) {
              itemIds.push(itemInContext.uuid);
            }
          }
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17.return) {
            _iterator17.return();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }

      return itemIds;
    }
  }, {
    key: "handlersForArea",
    value: function handlersForArea(area) {
      return this.handlers.filter(function (candidate) {
        return candidate.areas.includes(area);
      });
    }
  }, {
    key: "handleSaveItemsMessage",
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2(component, message) {
        var _this8 = this;

        var responseItems, requiredPermissions, itemIdsInContextJurisdiction, pendingResponseItems, _iteratorNormalCompletion18, _didIteratorError18, _iteratorError18, _iterator18, _step18, responseItem, requiredContentTypes;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                responseItems = message.data.items;
                requiredPermissions = [];
                itemIdsInContextJurisdiction = this.itemIdsInContextJurisdictionForComponent(component);

                // Pending as in needed to be accounted for in permissions.

                pendingResponseItems = responseItems.slice();
                _iteratorNormalCompletion18 = true;
                _didIteratorError18 = false;
                _iteratorError18 = undefined;
                _context2.prev = 7;
                _iterator18 = responseItems.slice()[Symbol.iterator]();

              case 9:
                if (_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done) {
                  _context2.next = 18;
                  break;
                }

                responseItem = _step18.value;

                if (!itemIdsInContextJurisdiction.includes(responseItem.uuid)) {
                  _context2.next = 15;
                  break;
                }

                requiredPermissions.push({
                  name: "stream-context-item"
                });
                _.pull(pendingResponseItems, responseItem);
                // We break because there can only be one context item
                return _context2.abrupt("break", 18);

              case 15:
                _iteratorNormalCompletion18 = true;
                _context2.next = 9;
                break;

              case 18:
                _context2.next = 24;
                break;

              case 20:
                _context2.prev = 20;
                _context2.t0 = _context2["catch"](7);
                _didIteratorError18 = true;
                _iteratorError18 = _context2.t0;

              case 24:
                _context2.prev = 24;
                _context2.prev = 25;

                if (!_iteratorNormalCompletion18 && _iterator18.return) {
                  _iterator18.return();
                }

              case 27:
                _context2.prev = 27;

                if (!_didIteratorError18) {
                  _context2.next = 30;
                  break;
                }

                throw _iteratorError18;

              case 30:
                return _context2.finish(27);

              case 31:
                return _context2.finish(24);

              case 32:

                // Check to see if additional privileges are required
                if (pendingResponseItems.length > 0) {
                  requiredContentTypes = _.uniq(pendingResponseItems.map(function (i) {
                    return i.content_type;
                  })).sort();

                  requiredPermissions.push({
                    name: "stream-items",
                    content_types: requiredContentTypes
                  });
                }

                this.runWithPermissions(component, requiredPermissions, _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                  var ids, items, lockedCount, _iteratorNormalCompletion19, _didIteratorError19, _iteratorError19, _iterator19, _step19, item, itemNoun, auxVerb, localItems, _iteratorNormalCompletion20, _didIteratorError20, _iteratorError20, _iterator20, _step20, _responseItem2, _item;

                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:

                          _this8.removePrivatePropertiesFromResponseItems(responseItems, component, { includeUrls: true, type: "incoming" });

                          /*
                          We map the items here because modelManager is what updates the UI. If you were to instead get the items directly,
                          this would update them server side via sync, but would never make its way back to the UI.
                          */

                          // Filter locked items
                          ids = responseItems.map(function (i) {
                            return i.uuid;
                          });
                          items = _this8.modelManager.findItems(ids);
                          lockedCount = 0;
                          _iteratorNormalCompletion19 = true;
                          _didIteratorError19 = false;
                          _iteratorError19 = undefined;
                          _context.prev = 7;

                          for (_iterator19 = items[Symbol.iterator](); !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                            item = _step19.value;

                            if (item.locked) {
                              _.remove(responseItems, { uuid: item.uuid });
                              lockedCount++;
                            }
                          }

                          _context.next = 15;
                          break;

                        case 11:
                          _context.prev = 11;
                          _context.t0 = _context["catch"](7);
                          _didIteratorError19 = true;
                          _iteratorError19 = _context.t0;

                        case 15:
                          _context.prev = 15;
                          _context.prev = 16;

                          if (!_iteratorNormalCompletion19 && _iterator19.return) {
                            _iterator19.return();
                          }

                        case 18:
                          _context.prev = 18;

                          if (!_didIteratorError19) {
                            _context.next = 21;
                            break;
                          }

                          throw _iteratorError19;

                        case 21:
                          return _context.finish(18);

                        case 22:
                          return _context.finish(15);

                        case 23:
                          if (lockedCount > 0) {
                            itemNoun = lockedCount == 1 ? "item" : "items";
                            auxVerb = lockedCount == 1 ? "is" : "are";

                            _this8.alertManager.alert({ title: 'Items Locked', text: lockedCount + " " + itemNoun + " you are attempting to save " + auxVerb + " locked and cannot be edited." });
                          }

                          _context.next = 26;
                          return _this8.modelManager.mapResponseItemsToLocalModels(responseItems, SFModelManager.MappingSourceComponentRetrieved, component.uuid);

                        case 26:
                          localItems = _context.sent;
                          _iteratorNormalCompletion20 = true;
                          _didIteratorError20 = false;
                          _iteratorError20 = undefined;
                          _context.prev = 30;
                          _iterator20 = responseItems[Symbol.iterator]();

                        case 32:
                          if (_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done) {
                            _context.next = 42;
                            break;
                          }

                          _responseItem2 = _step20.value;
                          _item = _.find(localItems, { uuid: _responseItem2.uuid });

                          if (_item) {
                            _context.next = 38;
                            break;
                          }

                          // An item this extension is trying to save was possibly removed locally, notify user
                          _this8.alertManager.alert({ text: "The extension " + component.name + " is trying to save an item with type " + _responseItem2.content_type + ", but that item does not exist. Please restart this extension and try again." });
                          return _context.abrupt("continue", 39);

                        case 38:

                          if (!_item.locked) {
                            if (_responseItem2.clientData) {
                              _item.setDomainDataItem(component.getClientDataKey(), _responseItem2.clientData, SNComponentManager.ClientDataDomain);
                            }
                            _this8.modelManager.setItemDirty(_item, true, true, SFModelManager.MappingSourceComponentRetrieved, component.uuid);
                          }

                        case 39:
                          _iteratorNormalCompletion20 = true;
                          _context.next = 32;
                          break;

                        case 42:
                          _context.next = 48;
                          break;

                        case 44:
                          _context.prev = 44;
                          _context.t1 = _context["catch"](30);
                          _didIteratorError20 = true;
                          _iteratorError20 = _context.t1;

                        case 48:
                          _context.prev = 48;
                          _context.prev = 49;

                          if (!_iteratorNormalCompletion20 && _iterator20.return) {
                            _iterator20.return();
                          }

                        case 51:
                          _context.prev = 51;

                          if (!_didIteratorError20) {
                            _context.next = 54;
                            break;
                          }

                          throw _iteratorError20;

                        case 54:
                          return _context.finish(51);

                        case 55:
                          return _context.finish(48);

                        case 56:

                          _this8.syncManager.sync().then(function (response) {
                            // Allow handlers to be notified when a save begins and ends, to update the UI
                            var saveMessage = Object.assign({}, message);
                            saveMessage.action = response && response.error ? "save-error" : "save-success";
                            _this8.replyToMessage(component, message, { error: response && response.error });
                            _this8.handleMessage(component, saveMessage);
                          });

                        case 57:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, _this8, [[7, 11, 15, 23], [16,, 18, 22], [30, 44, 48, 56], [49,, 51, 55]]);
                })));

              case 34:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[7, 20, 24, 32], [25,, 27, 31]]);
      }));

      function handleSaveItemsMessage(_x3, _x4) {
        return _ref2.apply(this, arguments);
      }

      return handleSaveItemsMessage;
    }()
  }, {
    key: "handleDuplicateItemMessage",
    value: function handleDuplicateItemMessage(component, message) {
      var _this9 = this;

      var itemParams = message.data.item;
      var item = this.modelManager.findItem(itemParams.uuid);
      var requiredPermissions = [{
        name: "stream-items",
        content_types: [item.content_type]
      }];

      this.runWithPermissions(component, requiredPermissions, function () {
        var duplicate = _this9.modelManager.duplicateItemAndAdd(item);
        _this9.syncManager.sync();

        _this9.replyToMessage(component, message, { item: _this9.jsonForItem(duplicate, component) });
      });
    }
  }, {
    key: "handleCreateItemsMessage",
    value: function handleCreateItemsMessage(component, message) {
      var _this10 = this;

      var responseItems = message.data.item ? [message.data.item] : message.data.items;
      var uniqueContentTypes = _.uniq(responseItems.map(function (item) {
        return item.content_type;
      }));
      var requiredPermissions = [{
        name: "stream-items",
        content_types: uniqueContentTypes
      }];

      this.runWithPermissions(component, requiredPermissions, function () {
        _this10.removePrivatePropertiesFromResponseItems(responseItems, component, { type: "incoming" });
        var processedItems = [];
        var _iteratorNormalCompletion21 = true;
        var _didIteratorError21 = false;
        var _iteratorError21 = undefined;

        try {
          for (var _iterator21 = responseItems[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
            var responseItem = _step21.value;

            var item = _this10.modelManager.createItem(responseItem);
            if (responseItem.clientData) {
              item.setDomainDataItem(component.getClientDataKey(), responseItem.clientData, SNComponentManager.ClientDataDomain);
            }
            _this10.modelManager.addItem(item);
            _this10.modelManager.resolveReferencesForItem(item, true);
            _this10.modelManager.setItemDirty(item, true);
            processedItems.push(item);
          }
        } catch (err) {
          _didIteratorError21 = true;
          _iteratorError21 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion21 && _iterator21.return) {
              _iterator21.return();
            }
          } finally {
            if (_didIteratorError21) {
              throw _iteratorError21;
            }
          }
        }

        _this10.syncManager.sync();

        // "create-item" or "create-items" are possible messages handled here
        var reply = message.action == "create-item" ? { item: _this10.jsonForItem(processedItems[0], component) } : { items: processedItems.map(function (item) {
            return _this10.jsonForItem(item, component);
          }) };

        _this10.replyToMessage(component, message, reply);
      });
    }
  }, {
    key: "handleDeleteItemsMessage",
    value: function handleDeleteItemsMessage(component, message) {
      var _this11 = this;

      var requiredContentTypes = _.uniq(message.data.items.map(function (i) {
        return i.content_type;
      })).sort();
      var requiredPermissions = [{
        name: "stream-items",
        content_types: requiredContentTypes
      }];

      this.runWithPermissions(component, requiredPermissions, _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
        var itemsData, noun, reply, didConfirm, _iteratorNormalCompletion22, _didIteratorError22, _iteratorError22, _iterator22, _step22, itemData, model;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                itemsData = message.data.items;
                noun = itemsData.length == 1 ? "item" : "items";
                reply = null;
                didConfirm = true;
                _context3.next = 6;
                return _this11.alertManager.confirm({ text: "Are you sure you want to delete " + itemsData.length + " " + noun + "?" }).catch(function () {
                  didConfirm = false;
                });

              case 6:
                if (!didConfirm) {
                  _context3.next = 42;
                  break;
                }

                // Filter for any components and deactivate before deleting
                _iteratorNormalCompletion22 = true;
                _didIteratorError22 = false;
                _iteratorError22 = undefined;
                _context3.prev = 10;
                _iterator22 = itemsData[Symbol.iterator]();

              case 12:
                if (_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done) {
                  _context3.next = 24;
                  break;
                }

                itemData = _step22.value;
                model = _this11.modelManager.findItem(itemData.uuid);

                if (model) {
                  _context3.next = 18;
                  break;
                }

                _this11.alertManager.alert({ text: "The item you are trying to delete cannot be found." });
                return _context3.abrupt("continue", 21);

              case 18:
                if (["SN|Component", "SN|Theme"].includes(model.content_type)) {
                  _this11.deactivateComponent(model, true);
                }
                _this11.modelManager.setItemToBeDeleted(model);
                // Currently extensions are not notified of association until a full server sync completes.
                // We manually notify observers.
                _this11.modelManager.notifySyncObserversOfModels([model], SFModelManager.MappingSourceRemoteSaved);

              case 21:
                _iteratorNormalCompletion22 = true;
                _context3.next = 12;
                break;

              case 24:
                _context3.next = 30;
                break;

              case 26:
                _context3.prev = 26;
                _context3.t0 = _context3["catch"](10);
                _didIteratorError22 = true;
                _iteratorError22 = _context3.t0;

              case 30:
                _context3.prev = 30;
                _context3.prev = 31;

                if (!_iteratorNormalCompletion22 && _iterator22.return) {
                  _iterator22.return();
                }

              case 33:
                _context3.prev = 33;

                if (!_didIteratorError22) {
                  _context3.next = 36;
                  break;
                }

                throw _iteratorError22;

              case 36:
                return _context3.finish(33);

              case 37:
                return _context3.finish(30);

              case 38:

                _this11.syncManager.sync();
                reply = { deleted: true };
                _context3.next = 43;
                break;

              case 42:
                // Rejected by user
                reply = { deleted: false };

              case 43:

                _this11.replyToMessage(component, message, reply);

              case 44:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, _this11, [[10, 26, 30, 38], [31,, 33, 37]]);
      })));
    }
  }, {
    key: "handleRequestPermissionsMessage",
    value: function handleRequestPermissionsMessage(component, message) {
      var _this12 = this;

      this.runWithPermissions(component, message.data.permissions, function () {
        _this12.replyToMessage(component, message, { approved: true });
      });
    }
  }, {
    key: "handleSetComponentDataMessage",
    value: function handleSetComponentDataMessage(component, message) {
      var _this13 = this;

      // A component setting its own data does not require special permissions
      this.runWithPermissions(component, [], function () {
        component.componentData = message.data.componentData;
        _this13.modelManager.setItemDirty(component, true);
        _this13.syncManager.sync();
      });
    }
  }, {
    key: "handleToggleComponentMessage",
    value: function handleToggleComponentMessage(sourceComponent, targetComponent, message) {
      this.toggleComponent(targetComponent);
    }
  }, {
    key: "toggleComponent",
    value: function toggleComponent(component) {
      var _this14 = this;

      if (component.area == "modal") {
        this.openModalComponent(component);
      } else {
        if (component.active) {
          this.deactivateComponent(component);
        } else {
          if (component.content_type == "SN|Theme") {
            // Deactive currently active theme if new theme is not layerable
            var activeThemes = this.getActiveThemes();

            // Activate current before deactivating others, so as not to flicker
            this.activateComponent(component);

            if (!component.isLayerable()) {
              setTimeout(function () {
                var _iteratorNormalCompletion23 = true;
                var _didIteratorError23 = false;
                var _iteratorError23 = undefined;

                try {
                  for (var _iterator23 = activeThemes[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                    var theme = _step23.value;

                    if (theme && !theme.isLayerable()) {
                      _this14.deactivateComponent(theme);
                    }
                  }
                } catch (err) {
                  _didIteratorError23 = true;
                  _iteratorError23 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion23 && _iterator23.return) {
                      _iterator23.return();
                    }
                  } finally {
                    if (_didIteratorError23) {
                      throw _iteratorError23;
                    }
                  }
                }
              }, 10);
            }
          } else {
            this.activateComponent(component);
          }
        }
      }
    }
  }, {
    key: "handleInstallLocalComponentMessage",
    value: function handleInstallLocalComponentMessage(sourceComponent, message) {
      // Only extensions manager has this permission
      if (this.nativeExtManager && !this.nativeExtManager.isSystemExtension(sourceComponent)) {
        return;
      }

      var targetComponent = this.modelManager.findItem(message.data.uuid);
      this.desktopManager.installComponent(targetComponent);
    }
  }, {
    key: "runWithPermissions",
    value: function runWithPermissions(component, requiredPermissions, runFunction) {
      if (!component.permissions) {
        component.permissions = [];
      }

      // Make copy as not to mutate input values
      requiredPermissions = JSON.parse(JSON.stringify(requiredPermissions));

      var acquiredPermissions = component.permissions;

      var _loop4 = function _loop4(required) {
        // Remove anything we already have
        var respectiveAcquired = acquiredPermissions.find(function (candidate) {
          return candidate.name == required.name;
        });
        if (!respectiveAcquired) {
          return "continue";
        }

        // We now match on name, lets substract from required.content_types anything we have in acquired.
        var requiredContentTypes = required.content_types;

        if (!requiredContentTypes) {
          // If this permission does not require any content types (i.e stream-context-item)
          // then we can remove this from required since we match by name (respectiveAcquired.name == required.name)
          _.pull(requiredPermissions, required);
          return "continue";
        }

        var _iteratorNormalCompletion25 = true;
        var _didIteratorError25 = false;
        var _iteratorError25 = undefined;

        try {
          for (var _iterator25 = respectiveAcquired.content_types[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
            var acquiredContentType = _step25.value;

            // console.log("Removing content_type", acquiredContentType, "from", requiredContentTypes);
            _.pull(requiredContentTypes, acquiredContentType);
          }
        } catch (err) {
          _didIteratorError25 = true;
          _iteratorError25 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion25 && _iterator25.return) {
              _iterator25.return();
            }
          } finally {
            if (_didIteratorError25) {
              throw _iteratorError25;
            }
          }
        }

        if (requiredContentTypes.length == 0) {
          // We've removed all acquired and end up with zero, means we already have all these permissions
          _.pull(requiredPermissions, required);
        }
      };

      var _iteratorNormalCompletion24 = true;
      var _didIteratorError24 = false;
      var _iteratorError24 = undefined;

      try {
        for (var _iterator24 = requiredPermissions.slice()[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
          var required = _step24.value;

          var _ret4 = _loop4(required);

          if (_ret4 === "continue") continue;
        }
      } catch (err) {
        _didIteratorError24 = true;
        _iteratorError24 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion24 && _iterator24.return) {
            _iterator24.return();
          }
        } finally {
          if (_didIteratorError24) {
            throw _iteratorError24;
          }
        }
      }

      if (requiredPermissions.length > 0) {
        this.promptForPermissions(component, requiredPermissions, function (approved) {
          if (approved) {
            runFunction();
          }
        });
      } else {
        runFunction();
      }
    }
  }, {
    key: "promptForPermissions",
    value: function promptForPermissions(component, permissions, callback) {
      var _this15 = this;

      var params = {};
      params.component = component;
      params.permissions = permissions;
      params.permissionsString = this.permissionsStringForPermissions(permissions, component);
      params.actionBlock = callback;

      params.callback = function (approved) {
        if (approved) {
          var _loop5 = function _loop5(permission) {
            var matchingPermission = component.permissions.find(function (candidate) {
              return candidate.name == permission.name;
            });
            if (!matchingPermission) {
              component.permissions.push(permission);
            } else {
              // Permission already exists, but content_types may have been expanded
              var contentTypes = matchingPermission.content_types || [];
              matchingPermission.content_types = _.uniq(contentTypes.concat(permission.content_types));
            }
          };

          var _iteratorNormalCompletion26 = true;
          var _didIteratorError26 = false;
          var _iteratorError26 = undefined;

          try {
            for (var _iterator26 = permissions[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
              var permission = _step26.value;

              _loop5(permission);
            }
          } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion26 && _iterator26.return) {
                _iterator26.return();
              }
            } finally {
              if (_didIteratorError26) {
                throw _iteratorError26;
              }
            }
          }

          _this15.modelManager.setItemDirty(component, true);
          _this15.syncManager.sync();
        }

        _this15.permissionDialogs = _this15.permissionDialogs.filter(function (pendingDialog) {
          // Remove self
          if (pendingDialog == params) {
            pendingDialog.actionBlock && pendingDialog.actionBlock(approved);
            return false;
          }

          var containsObjectSubset = function containsObjectSubset(source, target) {
            return !target.some(function (val) {
              return !source.find(function (candidate) {
                return JSON.stringify(candidate) === JSON.stringify(val);
              });
            });
          };

          if (pendingDialog.component == component) {
            // remove pending dialogs that are encapsulated by already approved permissions, and run its function
            if (pendingDialog.permissions == permissions || containsObjectSubset(permissions, pendingDialog.permissions)) {
              // If approved, run the action block. Otherwise, if canceled, cancel any pending ones as well, since the user was
              // explicit in their intentions
              if (approved) {
                pendingDialog.actionBlock && pendingDialog.actionBlock(approved);
              }
              return false;
            }
          }
          return true;
        });

        if (_this15.permissionDialogs.length > 0) {
          _this15.presentPermissionsDialog(_this15.permissionDialogs[0]);
        }
      };

      // since these calls are asyncronous, multiple dialogs may be requested at the same time. We only want to present one and trigger all callbacks based on one modal result
      var existingDialog = _.find(this.permissionDialogs, { component: component });

      this.permissionDialogs.push(params);

      if (!existingDialog) {
        this.presentPermissionsDialog(params);
      } else {
        console.log("Existing dialog, not presenting.");
      }
    }
  }, {
    key: "presentPermissionsDialog",
    value: function presentPermissionsDialog(dialog) {
      console.error("Must override");
    }
  }, {
    key: "openModalComponent",
    value: function openModalComponent(component) {
      console.error("Must override");
    }
  }, {
    key: "registerHandler",
    value: function registerHandler(handler) {
      this.handlers.push(handler);
    }
  }, {
    key: "deregisterHandler",
    value: function deregisterHandler(identifier) {
      var handler = _.find(this.handlers, { identifier: identifier });
      if (!handler) {
        console.log("Attempting to deregister non-existing handler");
        return;
      }
      this.handlers.splice(this.handlers.indexOf(handler), 1);
    }

    // Called by other views when the iframe is ready

  }, {
    key: "registerComponentWindow",
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee4(component, componentWindow) {
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (component.window === componentWindow) {
                  if (this.loggingEnabled) {
                    console.log("Web|componentManager", "attempting to re-register same component window.");
                  }
                }

                if (this.loggingEnabled) {
                  console.log("Web|componentManager|registerComponentWindow", component);
                }
                component.window = componentWindow;
                _context4.next = 5;
                return SFJS.crypto.generateUUID();

              case 5:
                component.sessionKey = _context4.sent;

                this.sendMessageToComponent(component, {
                  action: "component-registered",
                  sessionKey: component.sessionKey,
                  componentData: component.componentData,
                  data: {
                    uuid: component.uuid,
                    environment: this.environment,
                    platform: this.platform,
                    activeThemeUrls: this.urlsForActiveThemes()
                  }
                });

                this.postActiveThemesToComponent(component);

                if (this.desktopManager) {
                  this.desktopManager.notifyComponentActivation(component);
                }

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function registerComponentWindow(_x5, _x6) {
        return _ref5.apply(this, arguments);
      }

      return registerComponentWindow;
    }()
  }, {
    key: "activateComponent",
    value: function activateComponent(component) {
      var _this16 = this;

      var dontSync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var didChange = component.active != true;

      component.active = true;

      var _loop6 = function _loop6(handler) {
        if (handler.areas.includes(component.area) || handler.areas.includes("*")) {
          // We want to run the handler in a $timeout so the UI updates, but we also don't want it to run asyncronously
          // so that the steps below this one are run before the handler. So we run in a waitTimeout.
          // Update 12/18: We were using this.waitTimeout previously, however, that caused the iframe.onload callback to never be called
          // for some reason for iframes on desktop inside the revision-preview-modal. So we'll use safeApply instead. I'm not quite sure
          // where the original "so the UI updates" comment applies to, but we'll have to keep an eye out to see if this causes problems somewhere else.
          _this16.$uiRunner(function () {
            handler.activationHandler && handler.activationHandler(component);
          });
        }
      };

      var _iteratorNormalCompletion27 = true;
      var _didIteratorError27 = false;
      var _iteratorError27 = undefined;

      try {
        for (var _iterator27 = this.handlers[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
          var handler = _step27.value;

          _loop6(handler);
        }
      } catch (err) {
        _didIteratorError27 = true;
        _iteratorError27 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion27 && _iterator27.return) {
            _iterator27.return();
          }
        } finally {
          if (_didIteratorError27) {
            throw _iteratorError27;
          }
        }
      }

      if (didChange && !dontSync) {
        this.modelManager.setItemDirty(component, true);
        this.syncManager.sync();
      }

      if (!this.activeComponents.includes(component)) {
        this.activeComponents.push(component);
      }

      if (component.area == "themes") {
        this.postActiveThemesToAllComponents();
      }
    }
  }, {
    key: "deactivateComponent",
    value: function deactivateComponent(component) {
      var _this17 = this;

      var dontSync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var didChange = component.active != false;
      component.active = false;
      component.sessionKey = null;

      var _loop7 = function _loop7(handler) {
        if (handler.areas.includes(component.area) || handler.areas.includes("*")) {
          // See comment in activateComponent regarding safeApply and awaitTimeout
          _this17.$uiRunner(function () {
            handler.activationHandler && handler.activationHandler(component);
          });
        }
      };

      var _iteratorNormalCompletion28 = true;
      var _didIteratorError28 = false;
      var _iteratorError28 = undefined;

      try {
        for (var _iterator28 = this.handlers[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
          var handler = _step28.value;

          _loop7(handler);
        }
      } catch (err) {
        _didIteratorError28 = true;
        _iteratorError28 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion28 && _iterator28.return) {
            _iterator28.return();
          }
        } finally {
          if (_didIteratorError28) {
            throw _iteratorError28;
          }
        }
      }

      if (didChange && !dontSync) {
        this.modelManager.setItemDirty(component, true);
        this.syncManager.sync();
      }

      _.pull(this.activeComponents, component);

      this.streamObservers = this.streamObservers.filter(function (o) {
        return o.component !== component;
      });

      this.contextStreamObservers = this.contextStreamObservers.filter(function (o) {
        return o.component !== component;
      });

      if (component.area == "themes") {
        this.postActiveThemesToAllComponents();
      }
    }
  }, {
    key: "reloadComponent",
    value: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee5(component) {
        var _this18 = this;

        var _loop8, _iteratorNormalCompletion29, _didIteratorError29, _iteratorError29, _iterator29, _step29, handler;

        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                //
                // Do soft deactivate
                //
                component.active = false;

                _loop8 = function _loop8(handler) {
                  if (handler.areas.includes(component.area) || handler.areas.includes("*")) {
                    // See comment in activateComponent regarding safeApply and awaitTimeout
                    _this18.$uiRunner(function () {
                      handler.activationHandler && handler.activationHandler(component);
                    });
                  }
                };

                _iteratorNormalCompletion29 = true;
                _didIteratorError29 = false;
                _iteratorError29 = undefined;
                _context5.prev = 5;
                for (_iterator29 = this.handlers[Symbol.iterator](); !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                  handler = _step29.value;

                  _loop8(handler);
                }

                _context5.next = 13;
                break;

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](5);
                _didIteratorError29 = true;
                _iteratorError29 = _context5.t0;

              case 13:
                _context5.prev = 13;
                _context5.prev = 14;

                if (!_iteratorNormalCompletion29 && _iterator29.return) {
                  _iterator29.return();
                }

              case 16:
                _context5.prev = 16;

                if (!_didIteratorError29) {
                  _context5.next = 19;
                  break;
                }

                throw _iteratorError29;

              case 19:
                return _context5.finish(16);

              case 20:
                return _context5.finish(13);

              case 21:
                this.streamObservers = this.streamObservers.filter(function (o) {
                  return o.component !== component;
                });

                this.contextStreamObservers = this.contextStreamObservers.filter(function (o) {
                  return o.component !== component;
                });

                if (component.area == "themes") {
                  this.postActiveThemesToAllComponents();
                }

                //
                // Do soft activate
                //

                return _context5.abrupt("return", new Promise(function (resolve, reject) {
                  _this18.$timeout(function () {
                    component.active = true;
                    var _iteratorNormalCompletion30 = true;
                    var _didIteratorError30 = false;
                    var _iteratorError30 = undefined;

                    try {
                      for (var _iterator30 = _this18.handlers[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                        var handler = _step30.value;

                        if (handler.areas.includes(component.area) || handler.areas.includes("*")) {
                          // See comment in activateComponent regarding safeApply and awaitTimeout
                          _this18.$uiRunner(function () {
                            handler.activationHandler && handler.activationHandler(component);
                            resolve();
                          });
                        }
                      }
                    } catch (err) {
                      _didIteratorError30 = true;
                      _iteratorError30 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion30 && _iterator30.return) {
                          _iterator30.return();
                        }
                      } finally {
                        if (_didIteratorError30) {
                          throw _iteratorError30;
                        }
                      }
                    }

                    if (!_this18.activeComponents.includes(component)) {
                      _this18.activeComponents.push(component);
                    }

                    if (component.area == "themes") {
                      _this18.postActiveThemesToAllComponents();
                    }
                    // Resolve again in case first resolve in for loop isn't reached.
                    // Should be no effect if resolved twice, only first will be used.
                    resolve();
                  });
                }));

              case 25:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[5, 9, 13, 21], [14,, 16, 20]]);
      }));

      function reloadComponent(_x9) {
        return _ref6.apply(this, arguments);
      }

      return reloadComponent;
    }()
  }, {
    key: "deleteComponent",
    value: function deleteComponent(component) {
      this.modelManager.setItemToBeDeleted(component);
      this.syncManager.sync();
    }
  }, {
    key: "isComponentActive",
    value: function isComponentActive(component) {
      return component.active;
    }
  }, {
    key: "iframeForComponent",
    value: function iframeForComponent(component) {
      var _iteratorNormalCompletion31 = true;
      var _didIteratorError31 = false;
      var _iteratorError31 = undefined;

      try {
        for (var _iterator31 = Array.from(document.getElementsByTagName("iframe"))[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
          var frame = _step31.value;

          var componentId = frame.dataset.componentId;
          if (componentId === component.uuid) {
            return frame;
          }
        }
      } catch (err) {
        _didIteratorError31 = true;
        _iteratorError31 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion31 && _iterator31.return) {
            _iterator31.return();
          }
        } finally {
          if (_didIteratorError31) {
            throw _iteratorError31;
          }
        }
      }
    }
  }, {
    key: "focusChangedForComponent",
    value: function focusChangedForComponent(component) {
      var focused = document.activeElement == this.iframeForComponent(component);
      var _iteratorNormalCompletion32 = true;
      var _didIteratorError32 = false;
      var _iteratorError32 = undefined;

      try {
        for (var _iterator32 = this.handlers[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
          var handler = _step32.value;

          // Notify all handlers, and not just ones that match this component type
          handler.focusHandler && handler.focusHandler(component, focused);
        }
      } catch (err) {
        _didIteratorError32 = true;
        _iteratorError32 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion32 && _iterator32.return) {
            _iterator32.return();
          }
        } finally {
          if (_didIteratorError32) {
            throw _iteratorError32;
          }
        }
      }
    }
  }, {
    key: "handleSetSizeEvent",
    value: function handleSetSizeEvent(component, data) {
      var setSize = function setSize(element, size) {
        var widthString = typeof size.width === 'string' ? size.width : data.width + "px";
        var heightString = typeof size.height === 'string' ? size.height : data.height + "px";
        if (element) {
          element.setAttribute("style", "width:" + widthString + "; height:" + heightString + ";");
        }
      };

      if (component.area == "rooms" || component.area == "modal") {
        var selector = component.area == "rooms" ? "inner" : "outer";
        var content = document.getElementById("component-content-" + selector + "-" + component.uuid);
        if (content) {
          setSize(content, data);
        }
      } else {
        var iframe = this.iframeForComponent(component);
        if (!iframe) {
          return;
        }

        setSize(iframe, data);

        // On Firefox, resizing a component iframe does not seem to have an effect with editor-stack extensions.
        // Sizing the parent does the trick, however, we can't do this globally, otherwise, areas like the note-tags will
        // not be able to expand outside of the bounds (to display autocomplete, for example).
        if (component.area == "editor-stack") {
          var parent = iframe.parentElement;
          if (parent) {
            setSize(parent, data);
          }
        }

        // content object in this case is === to the iframe object above. This is probably
        // legacy code from when we would size content and container individually, which we no longer do.
        // var content = document.getElementById(`component-iframe-${component.uuid}`);
        // console.log("content === iframe", content == iframe);
        // if(content) {
        //   setSize(content, data);
        // }
      }
    }
  }, {
    key: "editorForNote",
    value: function editorForNote(note) {
      var editors = this.componentsForArea("editor-editor");
      var _iteratorNormalCompletion33 = true;
      var _didIteratorError33 = false;
      var _iteratorError33 = undefined;

      try {
        for (var _iterator33 = editors[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
          var editor = _step33.value;

          if (editor.isExplicitlyEnabledForItem(note)) {
            return editor;
          }
        }

        // No editor found for note. Use default editor, if note does not prefer system editor
      } catch (err) {
        _didIteratorError33 = true;
        _iteratorError33 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion33 && _iterator33.return) {
            _iterator33.return();
          }
        } finally {
          if (_didIteratorError33) {
            throw _iteratorError33;
          }
        }
      }

      if (this.isMobile) {
        if (!note.content.mobilePrefersPlainEditor) {
          return this.getDefaultEditor();
        }
      } else {
        if (!note.getAppDataItem("prefersPlainEditor")) {
          return editors.filter(function (e) {
            return e.isDefaultEditor();
          })[0];
        }
      }
    }
  }, {
    key: "permissionsStringForPermissions",
    value: function permissionsStringForPermissions(permissions, component) {
      var _this19 = this;

      var finalString = "";
      var permissionsCount = permissions.length;

      var addSeparator = function addSeparator(index, length) {
        if (index > 0) {
          if (index == length - 1) {
            if (length == 2) {
              return " and ";
            } else {
              return ", and ";
            }
          } else {
            return ", ";
          }
        }

        return "";
      };

      permissions.forEach(function (permission, index) {
        if (permission.name === "stream-items") {
          var types = permission.content_types.map(function (type) {
            var desc = _this19.modelManager.humanReadableDisplayForContentType(type);
            if (desc) {
              return desc + "s";
            } else {
              return "items of type " + type;
            }
          });
          var typesString = "";

          for (var i = 0; i < types.length; i++) {
            var type = types[i];
            typesString += addSeparator(i, types.length + permissionsCount - index - 1);
            typesString += type;
          }

          finalString += addSeparator(index, permissionsCount);

          finalString += typesString;

          if (types.length >= 2 && index < permissionsCount - 1) {
            // If you have a list of types, and still an additional root-level permission coming up, add a comma
            finalString += ", ";
          }
        } else if (permission.name === "stream-context-item") {
          var mapping = {
            "editor-stack": "working note",
            "note-tags": "working note",
            "editor-editor": "working note"
          };

          finalString += addSeparator(index, permissionsCount, true);

          finalString += mapping[component.area];
        }
      });

      return finalString + ".";
    }
  }, {
    key: "components",
    get: function get() {
      return this.modelManager.allItemsMatchingTypes(["SN|Component", "SN|Theme"]);
    }
  }]);

  return SNComponentManager;
}();

;
var SNComponent = exports.SNComponent = function (_SFItem) {
  _inherits(SNComponent, _SFItem);

  function SNComponent(json_obj) {
    _classCallCheck(this, SNComponent);

    // If making a copy of an existing component (usually during sign in if you have a component active in the session),
    // which may have window set, you may get a cross-origin exception since you'll be trying to copy the window. So we clear it here.
    json_obj.window = null;

    var _this20 = _possibleConstructorReturn(this, (SNComponent.__proto__ || Object.getPrototypeOf(SNComponent)).call(this, json_obj));

    if (!_this20.componentData) {
      _this20.componentData = {};
    }

    if (!_this20.disassociatedItemIds) {
      _this20.disassociatedItemIds = [];
    }

    if (!_this20.associatedItemIds) {
      _this20.associatedItemIds = [];
    }
    return _this20;
  }

  _createClass(SNComponent, [{
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNComponent.prototype.__proto__ || Object.getPrototypeOf(SNComponent.prototype), "mapContentToLocalProperties", this).call(this, content);
      /* Legacy */
      // We don't want to set the url directly, as we'd like to phase it out.
      // If the content.url exists, we'll transfer it to legacy_url
      // We'll only need to set this if content.hosted_url is blank, otherwise, hosted_url is the url replacement.
      if (!content.hosted_url) {
        this.legacy_url = content.url;
      }

      /* New */
      this.local_url = content.local_url;
      this.hosted_url = content.hosted_url || content.url;
      this.offlineOnly = content.offlineOnly;

      if (content.valid_until) {
        this.valid_until = new Date(content.valid_until);
      }

      this.name = content.name;
      this.autoupdateDisabled = content.autoupdateDisabled;

      this.package_info = content.package_info;

      // the location in the view this component is located in. Valid values are currently tags-list, note-tags, and editor-stack`
      this.area = content.area;

      this.permissions = content.permissions;
      if (!this.permissions) {
        this.permissions = [];
      }

      this.active = content.active;

      // custom data that a component can store in itself
      this.componentData = content.componentData || {};

      // items that have requested a component to be disabled in its context
      this.disassociatedItemIds = content.disassociatedItemIds || [];

      // items that have requested a component to be enabled in its context
      this.associatedItemIds = content.associatedItemIds || [];
    }
  }, {
    key: "handleDeletedContent",
    value: function handleDeletedContent() {
      _get(SNComponent.prototype.__proto__ || Object.getPrototypeOf(SNComponent.prototype), "handleDeletedContent", this).call(this);

      this.active = false;
    }
  }, {
    key: "structureParams",
    value: function structureParams() {
      var params = {
        legacy_url: this.legacy_url,
        hosted_url: this.hosted_url,
        local_url: this.local_url,
        valid_until: this.valid_until,
        offlineOnly: this.offlineOnly,
        name: this.name,
        area: this.area,
        package_info: this.package_info,
        permissions: this.permissions,
        active: this.active,
        autoupdateDisabled: this.autoupdateDisabled,
        componentData: this.componentData,
        disassociatedItemIds: this.disassociatedItemIds,
        associatedItemIds: this.associatedItemIds
      };

      var superParams = _get(SNComponent.prototype.__proto__ || Object.getPrototypeOf(SNComponent.prototype), "structureParams", this).call(this);
      Object.assign(superParams, params);
      return superParams;
    }
  }, {
    key: "isEditor",
    value: function isEditor() {
      return this.area == "editor-editor";
    }
  }, {
    key: "isTheme",
    value: function isTheme() {
      return this.content_type == "SN|Theme" || this.area == "themes";
    }
  }, {
    key: "isDefaultEditor",
    value: function isDefaultEditor() {
      return this.getAppDataItem("defaultEditor") == true;
    }
  }, {
    key: "setLastSize",
    value: function setLastSize(size) {
      this.setAppDataItem("lastSize", size);
    }
  }, {
    key: "getLastSize",
    value: function getLastSize() {
      return this.getAppDataItem("lastSize");
    }
  }, {
    key: "acceptsThemes",
    value: function acceptsThemes() {
      if (this.content.package_info && "acceptsThemes" in this.content.package_info) {
        return this.content.package_info.acceptsThemes;
      }
      return true;
    }

    /*
      The key used to look up data that this component may have saved to an item.
      This key will be look up on the item, and not on itself.
     */

  }, {
    key: "getClientDataKey",
    value: function getClientDataKey() {
      if (this.legacy_url) {
        return this.legacy_url;
      } else {
        return this.uuid;
      }
    }
  }, {
    key: "hasValidHostedUrl",
    value: function hasValidHostedUrl() {
      return this.hosted_url || this.legacy_url;
    }
  }, {
    key: "keysToIgnoreWhenCheckingContentEquality",
    value: function keysToIgnoreWhenCheckingContentEquality() {
      return ["active", "disassociatedItemIds", "associatedItemIds"].concat(_get(SNComponent.prototype.__proto__ || Object.getPrototypeOf(SNComponent.prototype), "keysToIgnoreWhenCheckingContentEquality", this).call(this));
    }

    /*
      An associative component depends on being explicitly activated for a given item, compared to a dissaciative component,
      which is enabled by default in areas unrelated to a certain item.
     */

  }, {
    key: "isAssociative",
    value: function isAssociative() {
      return Component.associativeAreas().includes(this.area);
    }
  }, {
    key: "associateWithItem",
    value: function associateWithItem(item) {
      this.associatedItemIds.push(item.uuid);
    }
  }, {
    key: "isExplicitlyEnabledForItem",
    value: function isExplicitlyEnabledForItem(item) {
      return this.associatedItemIds.indexOf(item.uuid) !== -1;
    }
  }, {
    key: "isExplicitlyDisabledForItem",
    value: function isExplicitlyDisabledForItem(item) {
      return this.disassociatedItemIds.indexOf(item.uuid) !== -1;
    }
  }, {
    key: "content_type",
    get: function get() {
      return "SN|Component";
    }
  }], [{
    key: "associativeAreas",
    value: function associativeAreas() {
      return ["editor-editor"];
    }
  }]);

  return SNComponent;
}(_standardFileJs.SFItem);

;
var SNEditor = exports.SNEditor = function (_SFItem2) {
  _inherits(SNEditor, _SFItem2);

  function SNEditor(json_obj) {
    _classCallCheck(this, SNEditor);

    var _this21 = _possibleConstructorReturn(this, (SNEditor.__proto__ || Object.getPrototypeOf(SNEditor)).call(this, json_obj));

    if (!_this21.notes) {
      _this21.notes = [];
    }
    if (!_this21.data) {
      _this21.data = {};
    }
    return _this21;
  }

  _createClass(SNEditor, [{
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNEditor.prototype.__proto__ || Object.getPrototypeOf(SNEditor.prototype), "mapContentToLocalProperties", this).call(this, content);
      this.url = content.url;
      this.name = content.name;
      this.data = content.data || {};
      this.default = content.default;
      this.systemEditor = content.systemEditor;
    }
  }, {
    key: "structureParams",
    value: function structureParams() {
      var params = {
        url: this.url,
        name: this.name,
        data: this.data,
        default: this.default,
        systemEditor: this.systemEditor
      };

      var superParams = _get(SNEditor.prototype.__proto__ || Object.getPrototypeOf(SNEditor.prototype), "structureParams", this).call(this);
      Object.assign(superParams, params);
      return superParams;
    }
  }, {
    key: "referenceParams",
    value: function referenceParams() {
      var references = _.map(this.notes, function (note) {
        return { uuid: note.uuid, content_type: note.content_type };
      });

      return references;
    }
  }, {
    key: "addItemAsRelationship",
    value: function addItemAsRelationship(item) {
      if (item.content_type == "Note") {
        if (!_.find(this.notes, item)) {
          this.notes.push(item);
        }
      }
      _get(SNEditor.prototype.__proto__ || Object.getPrototypeOf(SNEditor.prototype), "addItemAsRelationship", this).call(this, item);
    }
  }, {
    key: "removeItemAsRelationship",
    value: function removeItemAsRelationship(item) {
      if (item.content_type == "Note") {
        _.pull(this.notes, item);
      }
      _get(SNEditor.prototype.__proto__ || Object.getPrototypeOf(SNEditor.prototype), "removeItemAsRelationship", this).call(this, item);
    }
  }, {
    key: "removeAndDirtyAllRelationships",
    value: function removeAndDirtyAllRelationships() {
      _get(SNEditor.prototype.__proto__ || Object.getPrototypeOf(SNEditor.prototype), "removeAndDirtyAllRelationships", this).call(this);
      this.notes = [];
    }
  }, {
    key: "removeReferencesNotPresentIn",
    value: function removeReferencesNotPresentIn(references) {
      _get(SNEditor.prototype.__proto__ || Object.getPrototypeOf(SNEditor.prototype), "removeReferencesNotPresentIn", this).call(this, references);

      var uuids = references.map(function (ref) {
        return ref.uuid;
      });
      this.notes.forEach(function (note) {
        if (!uuids.includes(note.uuid)) {
          _.remove(this.notes, { uuid: note.uuid });
        }
      }.bind(this));
    }
  }, {
    key: "potentialItemOfInterestHasChangedItsUUID",
    value: function potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID) {
      if (newItem.content_type === "Note" && _.find(this.notes, { uuid: oldUUID })) {
        _.remove(this.notes, { uuid: oldUUID });
        this.notes.push(newItem);
      }
    }
  }, {
    key: "setData",
    value: function setData(key, value) {
      var dataHasChanged = JSON.stringify(this.data[key]) !== JSON.stringify(value);
      if (dataHasChanged) {
        this.data[key] = value;
        return true;
      }
      return false;
    }
  }, {
    key: "dataForKey",
    value: function dataForKey(key) {
      return this.data[key] || {};
    }
  }, {
    key: "content_type",
    get: function get() {
      return "SN|Editor";
    }
  }]);

  return SNEditor;
}(_standardFileJs.SFItem);

;
var Action = exports.Action = function Action(json) {
  _classCallCheck(this, Action);

  _.merge(this, json);
  this.running = false; // in case running=true was synced with server since model is uploaded nondiscriminatory
  this.error = false;
  if (this.lastExecuted) {
    // is string
    this.lastExecuted = new Date(this.lastExecuted);
  }
};

var SNExtension = exports.SNExtension = function (_SFItem3) {
  _inherits(SNExtension, _SFItem3);

  function SNExtension(json) {
    _classCallCheck(this, SNExtension);

    var _this22 = _possibleConstructorReturn(this, (SNExtension.__proto__ || Object.getPrototypeOf(SNExtension)).call(this, json));

    if (json.actions) {
      _this22.actions = json.actions.map(function (action) {
        return new Action(action);
      });
    }

    if (!_this22.actions) {
      _this22.actions = [];
    }
    return _this22;
  }

  _createClass(SNExtension, [{
    key: "actionsWithContextForItem",
    value: function actionsWithContextForItem(item) {
      return this.actions.filter(function (action) {
        return action.context == item.content_type || action.context == "Item";
      });
    }
  }, {
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNExtension.prototype.__proto__ || Object.getPrototypeOf(SNExtension.prototype), "mapContentToLocalProperties", this).call(this, content);
      this.description = content.description;
      this.url = content.url;
      this.name = content.name;
      this.package_info = content.package_info;
      this.supported_types = content.supported_types;
      if (content.actions) {
        this.actions = content.actions.map(function (action) {
          return new Action(action);
        });
      }
    }
  }, {
    key: "structureParams",
    value: function structureParams() {
      var params = {
        name: this.name,
        url: this.url,
        package_info: this.package_info,
        description: this.description,
        actions: this.actions.map(function (a) {
          return _.omit(a, ["subrows", "subactions"]);
        }),
        supported_types: this.supported_types
      };

      var superParams = _get(SNExtension.prototype.__proto__ || Object.getPrototypeOf(SNExtension.prototype), "structureParams", this).call(this);
      Object.assign(superParams, params);
      return superParams;
    }
  }, {
    key: "content_type",
    get: function get() {
      return "Extension";
    }
  }]);

  return SNExtension;
}(_standardFileJs.SFItem);

;
var SNNote = exports.SNNote = function (_SFItem4) {
  _inherits(SNNote, _SFItem4);

  function SNNote(json_obj) {
    _classCallCheck(this, SNNote);

    var _this23 = _possibleConstructorReturn(this, (SNNote.__proto__ || Object.getPrototypeOf(SNNote)).call(this, json_obj));

    if (!_this23.text) {
      // Some external editors can't handle a null value for text.
      // Notes created on mobile with no text have a null value for it,
      // so we'll just set a default here.
      _this23.text = "";
    }

    if (!_this23.tags) {
      _this23.tags = [];
    }
    return _this23;
  }

  _createClass(SNNote, [{
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "mapContentToLocalProperties", this).call(this, content);
      this.title = content.title;
      this.text = content.text;
    }
  }, {
    key: "structureParams",
    value: function structureParams() {
      var params = {
        title: this.title,
        text: this.text
      };

      var superParams = _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "structureParams", this).call(this);
      Object.assign(superParams, params);
      return superParams;
    }
  }, {
    key: "addItemAsRelationship",
    value: function addItemAsRelationship(item) {
      /*
      Legacy.
      Previously, note/tag relationships were bidirectional, however in some cases there
      may be broken links such that a note has references to a tag and not vice versa.
      Now, only tags contain references to notes. For old notes that may have references to tags,
      we want to transfer them over to the tag.
       */
      if (item.content_type == "Tag") {
        item.addItemAsRelationship(this);
      }
      _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "addItemAsRelationship", this).call(this, item);
    }
  }, {
    key: "setIsBeingReferencedBy",
    value: function setIsBeingReferencedBy(item) {
      _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "setIsBeingReferencedBy", this).call(this, item);
      this.clearSavedTagsString();
    }
  }, {
    key: "setIsNoLongerBeingReferencedBy",
    value: function setIsNoLongerBeingReferencedBy(item) {
      _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "setIsNoLongerBeingReferencedBy", this).call(this, item);
      this.clearSavedTagsString();
    }
  }, {
    key: "isBeingRemovedLocally",
    value: function isBeingRemovedLocally() {
      this.tags.forEach(function (tag) {
        _.remove(tag.notes, { uuid: this.uuid });
      }.bind(this));
      _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "isBeingRemovedLocally", this).call(this);
    }
  }, {
    key: "informReferencesOfUUIDChange",
    value: function informReferencesOfUUIDChange(oldUUID, newUUID) {
      _get(SNNote.prototype.__proto__ || Object.getPrototypeOf(SNNote.prototype), "informReferencesOfUUIDChange", this).call(this);
      var _iteratorNormalCompletion34 = true;
      var _didIteratorError34 = false;
      var _iteratorError34 = undefined;

      try {
        for (var _iterator34 = this.tags[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
          var tag = _step34.value;

          _.remove(tag.notes, { uuid: oldUUID });
          tag.notes.push(this);
        }
      } catch (err) {
        _didIteratorError34 = true;
        _iteratorError34 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion34 && _iterator34.return) {
            _iterator34.return();
          }
        } finally {
          if (_didIteratorError34) {
            throw _iteratorError34;
          }
        }
      }
    }
  }, {
    key: "tagDidFinishSyncing",
    value: function tagDidFinishSyncing(tag) {
      this.clearSavedTagsString();
    }
  }, {
    key: "safeText",
    value: function safeText() {
      return this.text || "";
    }
  }, {
    key: "safeTitle",
    value: function safeTitle() {
      return this.title || "";
    }
  }, {
    key: "clearSavedTagsString",
    value: function clearSavedTagsString() {
      this.savedTagsString = null;
    }
  }, {
    key: "tagsString",
    value: function tagsString() {
      this.savedTagsString = SNTag.arrayToDisplayString(this.tags);
      return this.savedTagsString;
    }
  }, {
    key: "content_type",
    get: function get() {
      return "Note";
    }
  }, {
    key: "displayName",
    get: function get() {
      return "Note";
    }
  }], [{
    key: "filterDummyNotes",
    value: function filterDummyNotes(notes) {
      var filtered = notes.filter(function (note) {
        return note.dummy == false || note.dummy == null;
      });
      return filtered;
    }
  }]);

  return SNNote;
}(_standardFileJs.SFItem);

;
var SNTag = exports.SNTag = function (_SFItem5) {
  _inherits(SNTag, _SFItem5);

  function SNTag(json_obj) {
    _classCallCheck(this, SNTag);

    var _this24 = _possibleConstructorReturn(this, (SNTag.__proto__ || Object.getPrototypeOf(SNTag)).call(this, json_obj));

    if (!_this24.content_type) {
      _this24.content_type = "Tag";
    }

    if (!_this24.notes) {
      _this24.notes = [];
    }
    return _this24;
  }

  _createClass(SNTag, [{
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNTag.prototype.__proto__ || Object.getPrototypeOf(SNTag.prototype), "mapContentToLocalProperties", this).call(this, content);
      this.title = content.title;
    }
  }, {
    key: "structureParams",
    value: function structureParams() {
      var params = {
        title: this.title
      };

      var superParams = _get(SNTag.prototype.__proto__ || Object.getPrototypeOf(SNTag.prototype), "structureParams", this).call(this);
      Object.assign(superParams, params);
      return superParams;
    }
  }, {
    key: "addItemAsRelationship",
    value: function addItemAsRelationship(item) {
      if (item.content_type == "Note") {
        if (!_.find(this.notes, { uuid: item.uuid })) {
          this.notes.push(item);
          item.tags.push(this);
        }
      }
      _get(SNTag.prototype.__proto__ || Object.getPrototypeOf(SNTag.prototype), "addItemAsRelationship", this).call(this, item);
    }
  }, {
    key: "removeItemAsRelationship",
    value: function removeItemAsRelationship(item) {
      if (item.content_type == "Note") {
        _.remove(this.notes, { uuid: item.uuid });
        _.remove(item.tags, { uuid: this.uuid });
      }
      _get(SNTag.prototype.__proto__ || Object.getPrototypeOf(SNTag.prototype), "removeItemAsRelationship", this).call(this, item);
    }
  }, {
    key: "updateLocalRelationships",
    value: function updateLocalRelationships() {
      var references = this.content.references;

      var uuids = references.map(function (ref) {
        return ref.uuid;
      });
      this.notes.slice().forEach(function (note) {
        if (!uuids.includes(note.uuid)) {
          _.remove(note.tags, { uuid: this.uuid });
          _.remove(this.notes, { uuid: note.uuid });

          note.setIsNoLongerBeingReferencedBy(this);
        }
      }.bind(this));
    }
  }, {
    key: "isBeingRemovedLocally",
    value: function isBeingRemovedLocally() {
      var _this25 = this;

      this.notes.forEach(function (note) {
        _.remove(note.tags, { uuid: _this25.uuid });
        note.setIsNoLongerBeingReferencedBy(_this25);
      });

      this.notes.length = 0;

      _get(SNTag.prototype.__proto__ || Object.getPrototypeOf(SNTag.prototype), "isBeingRemovedLocally", this).call(this);
    }
  }, {
    key: "informReferencesOfUUIDChange",
    value: function informReferencesOfUUIDChange(oldUUID, newUUID) {
      var _iteratorNormalCompletion35 = true;
      var _didIteratorError35 = false;
      var _iteratorError35 = undefined;

      try {
        for (var _iterator35 = this.notes[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
          var note = _step35.value;

          _.remove(note.tags, { uuid: oldUUID });
          note.tags.push(this);
        }
      } catch (err) {
        _didIteratorError35 = true;
        _iteratorError35 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion35 && _iterator35.return) {
            _iterator35.return();
          }
        } finally {
          if (_didIteratorError35) {
            throw _iteratorError35;
          }
        }
      }
    }
  }, {
    key: "didFinishSyncing",
    value: function didFinishSyncing() {
      var _iteratorNormalCompletion36 = true;
      var _didIteratorError36 = false;
      var _iteratorError36 = undefined;

      try {
        for (var _iterator36 = this.notes[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
          var note = _step36.value;

          note.tagDidFinishSyncing(this);
        }
      } catch (err) {
        _didIteratorError36 = true;
        _iteratorError36 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion36 && _iterator36.return) {
            _iterator36.return();
          }
        } finally {
          if (_didIteratorError36) {
            throw _iteratorError36;
          }
        }
      }
    }
  }, {
    key: "isSmartTag",
    value: function isSmartTag() {
      return this.content_type == "SN|SmartTag";
    }
  }, {
    key: "displayName",
    get: function get() {
      return "Tag";
    }
  }], [{
    key: "arrayToDisplayString",
    value: function arrayToDisplayString(tags) {
      return tags.sort(function (a, b) {
        return a.title > b.title;
      }).map(function (tag, i) {
        return "#" + tag.title;
      }).join(" ");
    }
  }]);

  return SNTag;
}(_standardFileJs.SFItem);

;
var SNEncryptedStorage = exports.SNEncryptedStorage = function (_SFItem6) {
  _inherits(SNEncryptedStorage, _SFItem6);

  function SNEncryptedStorage() {
    _classCallCheck(this, SNEncryptedStorage);

    return _possibleConstructorReturn(this, (SNEncryptedStorage.__proto__ || Object.getPrototypeOf(SNEncryptedStorage)).apply(this, arguments));
  }

  _createClass(SNEncryptedStorage, [{
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNEncryptedStorage.prototype.__proto__ || Object.getPrototypeOf(SNEncryptedStorage.prototype), "mapContentToLocalProperties", this).call(this, content);
      this.storage = content.storage;
    }
  }, {
    key: "content_type",
    get: function get() {
      return "SN|EncryptedStorage";
    }
  }]);

  return SNEncryptedStorage;
}(_standardFileJs.SFItem);

;
var SNMfa = exports.SNMfa = function (_SFItem7) {
  _inherits(SNMfa, _SFItem7);

  function SNMfa(json_obj) {
    _classCallCheck(this, SNMfa);

    return _possibleConstructorReturn(this, (SNMfa.__proto__ || Object.getPrototypeOf(SNMfa)).call(this, json_obj));
  }

  // mapContentToLocalProperties(content) {
  //   super.mapContentToLocalProperties(content)
  //   this.serverContent = content;
  // }
  //
  // structureParams() {
  //   return _.merge(this.serverContent, super.structureParams());
  // }

  _createClass(SNMfa, [{
    key: "doNotEncrypt",
    value: function doNotEncrypt() {
      return true;
    }
  }, {
    key: "content_type",
    get: function get() {
      return "SF|MFA";
    }
  }]);

  return SNMfa;
}(_standardFileJs.SFItem);

;
var SNServerExtension = exports.SNServerExtension = function (_SFItem8) {
  _inherits(SNServerExtension, _SFItem8);

  function SNServerExtension() {
    _classCallCheck(this, SNServerExtension);

    return _possibleConstructorReturn(this, (SNServerExtension.__proto__ || Object.getPrototypeOf(SNServerExtension)).apply(this, arguments));
  }

  _createClass(SNServerExtension, [{
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(content) {
      _get(SNServerExtension.prototype.__proto__ || Object.getPrototypeOf(SNServerExtension.prototype), "mapContentToLocalProperties", this).call(this, content);
      this.url = content.url;
    }
  }, {
    key: "doNotEncrypt",
    value: function doNotEncrypt() {
      return true;
    }
  }, {
    key: "content_type",
    get: function get() {
      return "SF|Extension";
    }
  }]);

  return SNServerExtension;
}(_standardFileJs.SFItem);

;
var SNSmartTag = exports.SNSmartTag = function (_SNTag) {
  _inherits(SNSmartTag, _SNTag);

  function SNSmartTag(json_ob) {
    _classCallCheck(this, SNSmartTag);

    var _this29 = _possibleConstructorReturn(this, (SNSmartTag.__proto__ || Object.getPrototypeOf(SNSmartTag)).call(this, json_ob));

    _this29.content_type = "SN|SmartTag";
    return _this29;
  }

  _createClass(SNSmartTag, null, [{
    key: "systemSmartTags",
    value: function systemSmartTags() {
      return [new SNSmartTag({
        uuid: SNSmartTag.SystemSmartTagIdAllNotes,
        dummy: true,
        content: {
          title: "All notes",
          isSystemTag: true,
          isAllTag: true,
          predicate: new SFPredicate.fromArray(["content_type", "=", "Note"])
        }
      }), new SNSmartTag({
        uuid: SNSmartTag.SystemSmartTagIdArchivedNotes,
        dummy: true,
        content: {
          title: "Archived",
          isSystemTag: true,
          isArchiveTag: true,
          predicate: new SFPredicate.fromArray(["archived", "=", true])
        }
      }), new SNSmartTag({
        uuid: SNSmartTag.SystemSmartTagIdTrashedNotes,
        dummy: true,
        content: {
          title: "Trash",
          isSystemTag: true,
          isTrashTag: true,
          predicate: new SFPredicate.fromArray(["content.trashed", "=", true])
        }
      })];
    }
  }]);

  return SNSmartTag;
}(SNTag);

SNSmartTag.SystemSmartTagIdAllNotes = "all-notes";
SNSmartTag.SystemSmartTagIdArchivedNotes = "archived-notes";
SNSmartTag.SystemSmartTagIdTrashedNotes = "trashed-notes";
;
var SNTheme = exports.SNTheme = function (_SNComponent) {
  _inherits(SNTheme, _SNComponent);

  function SNTheme(json_obj) {
    _classCallCheck(this, SNTheme);

    var _this30 = _possibleConstructorReturn(this, (SNTheme.__proto__ || Object.getPrototypeOf(SNTheme)).call(this, json_obj));

    _this30.area = "themes";
    return _this30;
  }

  _createClass(SNTheme, [{
    key: "isLayerable",
    value: function isLayerable() {
      return this.package_info && this.package_info.layerable;
    }
  }, {
    key: "setMobileRules",
    value: function setMobileRules(rules) {
      this.setAppDataItem("mobileRules", rules);
    }
  }, {
    key: "getMobileRules",
    value: function getMobileRules() {
      return this.getAppDataItem("mobileRules") || { constants: {}, rules: {} };
    }

    // Same as getMobileRules but without default value

  }, {
    key: "hasMobileRules",
    value: function hasMobileRules() {
      return this.getAppDataItem("mobileRules");
    }
  }, {
    key: "setNotAvailOnMobile",
    value: function setNotAvailOnMobile(na) {
      this.setAppDataItem("notAvailableOnMobile", na);
    }
  }, {
    key: "getNotAvailOnMobile",
    value: function getNotAvailOnMobile() {
      return this.getAppDataItem("notAvailableOnMobile");
    }

    /* We must not use .active because if you set that to true, it will also activate that theme on desktop/web */

  }, {
    key: "setMobileActive",
    value: function setMobileActive(active) {
      this.setAppDataItem("mobileActive", active);
    }
  }, {
    key: "isMobileActive",
    value: function isMobileActive() {
      return this.getAppDataItem("mobileActive");
    }
  }, {
    key: "content_type",
    get: function get() {
      return "SN|Theme";
    }
  }, {
    key: "displayName",
    get: function get() {
      return "Theme";
    }
  }]);

  return SNTheme;
}(SNComponent);

;

if (typeof window !== 'undefined' && window !== null) {
  // window is for some reason defined in React Native, but throws an exception when you try to set to it
  try {
    window.SNNote = SNNote;
    window.SNTag = SNTag;
    window.SNSmartTag = SNSmartTag;
    window.SNMfa = SNMfa;
    window.SNServerExtension = SNServerExtension;
    window.SNComponent = SNComponent;
    window.SNEditor = SNEditor;
    window.SNExtension = SNExtension;
    window.SNTheme = SNTheme;
    window.SNEncryptedStorage = SNEncryptedStorage;
    window.SNComponentManager = SNComponentManager;
  } catch (e) {
    console.log("Exception while exporting snjs window variables", e);
  }
}

;'use strict';

var SN = SN || {};

angular.module('app', ['ngSanitize']);

function getParameterByName(name, url) {
  name = name.replace(/[\[\]]/g, "\\$&");
  var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
      results = regex.exec(url);
  if (!results) return null;
  if (!results[2]) return '';
  return decodeURIComponent(results[2].replace(/\+/g, " "));
}

function parametersFromURL(url) {
  url = url.split("?").slice(-1)[0];
  var obj = {};
  url.replace(/([^=&]+)=([^&]*)/g, function (m, key, value) {
    obj[decodeURIComponent(key)] = decodeURIComponent(value);
  });
  return obj;
}

function getPlatformString() {
  try {
    var platform = navigator.platform.toLowerCase();
    var trimmed = "";
    if (platform.indexOf("mac") !== -1) {
      trimmed = "mac";
    } else if (platform.indexOf("win") !== -1) {
      trimmed = "windows";
    }if (platform.indexOf("linux") !== -1) {
      trimmed = "linux";
    }

    return trimmed + (isDesktopApplication() ? "-desktop" : "-web");
  } catch (e) {
    return null;
  }
}

function isDesktopApplication() {
  return window && window.process && window.process.type && window.process.versions["electron"];
}

function isMacApplication() {
  return window && window.process && window.process.type && window.process.platform == "darwin";
}

/* Use with numbers and strings, not objects */
Array.prototype.containsPrimitiveSubset = function (array) {
  var _this26 = this;

  return !array.some(function (val) {
    return _this26.indexOf(val) === -1;
  });
};

// https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function value(searchElement, fromIndex) {

      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If len is 0, return false.
      if (len === 0) {
        return false;
      }

      // 4. Let n be ? ToInteger(fromIndex).
      //    (If fromIndex is undefined, this step produces the value 0.)
      var n = fromIndex | 0;

      // 5. If n ≥ 0, then
      //  a. Let k be n.
      // 6. Else n < 0,
      //  a. Let k be len + n.
      //  b. If k < 0, let k be 0.
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      function sameValueZero(x, y) {
        return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
      }

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let elementK be the result of ? Get(O, ! ToString(k)).
        // b. If SameValueZero(searchElement, elementK) is true, return true.
        if (sameValueZero(o[k], searchElement)) {
          return true;
        }
        // c. Increase k by 1.
        k++;
      }

      // 8. Return false
      return false;
    }
  });
}
;angular.module('app').constant('appVersion', '3.0.15');;angular.module('app').config(function ($locationProvider) {

  if (!isDesktopApplication()) {
    if (window.history && window.history.pushState) {
      $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
      });
    }
  } else {
    $locationProvider.html5Mode(false);
  }
});
;
var NoteHistoryEntry = function (_SFItemHistoryEntry) {
  (0, _inherits4.default)(NoteHistoryEntry, _SFItemHistoryEntry);

  function NoteHistoryEntry() {
    (0, _classCallCheck4.default)(this, NoteHistoryEntry);
    return (0, _possibleConstructorReturn4.default)(this, (NoteHistoryEntry.__proto__ || Object.getPrototypeOf(NoteHistoryEntry)).apply(this, arguments));
  }

  (0, _createClass4.default)(NoteHistoryEntry, [{
    key: "previewTitle",
    value: function previewTitle() {
      return this.item.updated_at.toLocaleString();
    }
  }, {
    key: "previewSubTitle",
    value: function previewSubTitle() {
      if (!this.hasPreviousEntry) {
        return this.textCharDiffLength + " characters loaded";
      } else if (this.textCharDiffLength < 0) {
        return this.textCharDiffLength * -1 + " characters removed";
      } else if (this.textCharDiffLength > 0) {
        return this.textCharDiffLength + " characters added";
      } else {
        return "Title or metadata changed";
      }
    }
  }]);
  return NoteHistoryEntry;
}(SFItemHistoryEntry);

;angular.module('app').directive("editorSection", function ($timeout, $sce) {
  return {
    restrict: 'E',
    scope: {
      remove: "&",
      note: "=",
      updateTags: "&"
    },
    templateUrl: 'editor.html',
    replace: true,
    controller: 'EditorCtrl',
    controllerAs: 'ctrl',
    bindToController: true,

    link: function link(scope, elem, attrs, ctrl) {
      scope.$watch('ctrl.note', function (note, oldNote) {
        if (note) {
          ctrl.noteDidChange(note, oldNote);
        }
      });
    }
  };
}).controller('EditorCtrl', function ($sce, $timeout, authManager, $rootScope, actionsManager, syncManager, modelManager, themeManager, componentManager, storageManager, sessionHistory, privilegesManager, keyboardManager, desktopManager) {
  var _this28 = this;

  this.spellcheck = true;
  this.componentManager = componentManager;
  this.componentStack = [];
  this.isDesktop = isDesktopApplication();

  var MinimumStatusDurationMs = 400;

  syncManager.addEventHandler(function (eventName, data) {
    if (!_this28.note) {
      return;
    }

    if (eventName == "sync:taking-too-long") {
      _this28.syncTakingTooLong = true;
    } else if (eventName == "sync:completed") {
      _this28.syncTakingTooLong = false;
      if (_this28.note.dirty) {
        // if we're still dirty, don't change status, a sync is likely upcoming.
      } else {
        var savedItem = data.savedItems.find(function (item) {
          return item.uuid == _this28.note.uuid;
        });
        var isInErrorState = _this28.saveError;
        if (isInErrorState || savedItem) {
          _this28.showAllChangesSavedStatus();
        }
      }
    } else if (eventName == "sync:error") {
      // only show error status in editor if the note is dirty. Otherwise, it means the originating sync
      // came from somewhere else and we don't want to display an error here.
      if (_this28.note.dirty) {
        _this28.showErrorStatus();
      }
    }
  });

  // Right now this only handles offline saving status changes.
  this.syncStatusObserver = syncManager.registerSyncStatusObserver(function (status) {
    if (status.localError) {
      $timeout(function () {
        _this28.showErrorStatus({
          message: "Offline Saving Issue",
          desc: "Changes not saved"
        });
      }, 500);
    } else {}
  });

  modelManager.addItemSyncObserver("editor-note-observer", "Note", function (allItems, validItems, deletedItems, source) {
    if (!_this28.note) {
      return;
    }

    // Before checking if isMappingSourceRetrieved, we check if this item was deleted via a local source,
    // such as alternating uuids during sign in. Otherwise, we only want to make interface updates if it's a
    // remote retrieved source.
    if (_this28.note.deleted || _this28.note.content.trashed) {
      $rootScope.notifyDelete();
      return;
    }

    if (!SFModelManager.isMappingSourceRetrieved(source)) {
      return;
    }

    var matchingNote = allItems.find(function (item) {
      return item.uuid == _this28.note.uuid;
    });

    if (!matchingNote) {
      return;
    }

    // Update tags
    _this28.loadTagsString();
  });

  modelManager.addItemSyncObserver("editor-tag-observer", "Tag", function (allItems, validItems, deletedItems, source) {
    if (!_this28.note) {
      return;
    }

    var _iteratorNormalCompletion37 = true;
    var _didIteratorError37 = false;
    var _iteratorError37 = undefined;

    try {
      for (var _iterator37 = allItems[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
        var tag = _step37.value;

        // If a tag is deleted then we'll have lost references to notes. Reload anyway.
        if (_this28.note.savedTagsString == null || tag.deleted || tag.hasRelationshipWithItem(_this28.note)) {
          _this28.loadTagsString();
          return;
        }
      }
    } catch (err) {
      _didIteratorError37 = true;
      _iteratorError37 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion37 && _iterator37.return) {
          _iterator37.return();
        }
      } finally {
        if (_didIteratorError37) {
          throw _iteratorError37;
        }
      }
    }
  });

  modelManager.addItemSyncObserver("editor-component-observer", "SN|Component", function (allItems, validItems, deletedItems, source) {
    if (!_this28.note) {
      return;
    }

    // Reload componentStack in case new ones were added or removed
    _this28.reloadComponentStackArray();

    // Observe editor changes to see if the current note should update its editor
    var editors = allItems.filter(function (item) {
      return item.isEditor();
    });

    // If no editors have changed
    if (editors.length == 0) {
      return;
    }

    // Look through editors again and find the most proper one
    var editor = _this28.editorForNote(_this28.note);
    _this28.selectedEditor = editor;
    if (!editor) {
      _this28.reloadFont();
    }
  });

  this.noteDidChange = function (note, oldNote) {
    this.setNote(note, oldNote);
    this.reloadComponentContext();
  };

  this.setNote = function (note, oldNote) {
    var _this31 = this;

    this.showExtensions = false;
    this.showMenu = false;
    this.noteStatus = null;
    // When setting alt key down and deleting note, an alert will come up and block the key up event when alt is released.
    // We reset it on set note so that the alt menu restores to default.
    this.altKeyDown = false;
    this.loadTagsString();

    var onReady = function onReady() {
      _this31.noteReady = true;
      $timeout(function () {
        _this31.loadPreferences();
      });
    };

    var associatedEditor = this.editorForNote(note);
    if (associatedEditor && associatedEditor != this.selectedEditor) {
      // setting note to not ready will remove the editor from view in a flash,
      // so we only want to do this if switching between external editors
      this.noteReady = false;
      // switch after timeout, so that note data isnt posted to current editor
      $timeout(function () {
        _this31.selectedEditor = associatedEditor;
        onReady();
      });
    } else if (associatedEditor) {
      // Same editor as currently active
      onReady();
    } else {
      // No editor
      this.selectedEditor = null;
      onReady();
    }

    if (note.safeText().length == 0 && note.dummy) {
      this.focusTitle(100);
    }

    if (oldNote && oldNote != note) {
      if (oldNote.dirty) {
        this.saveNote(oldNote);
      } else if (oldNote.dummy) {
        this.remove()(oldNote);
      }
    }
  };

  this.editorForNote = function (note) {
    return componentManager.editorForNote(note);
  };

  this.closeAllMenus = function () {
    this.showEditorMenu = false;
    this.showMenu = false;
    this.showExtensions = false;
  };

  this.toggleMenu = function (menu) {
    this[menu] = !this[menu];

    var allMenus = ['showMenu', 'showEditorMenu', 'showExtensions', 'showSessionHistory'];
    var _iteratorNormalCompletion38 = true;
    var _didIteratorError38 = false;
    var _iteratorError38 = undefined;

    try {
      for (var _iterator38 = allMenus[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
        var candidate = _step38.value;

        if (candidate != menu) {
          this[candidate] = false;
        }
      }
    } catch (err) {
      _didIteratorError38 = true;
      _iteratorError38 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion38 && _iterator38.return) {
          _iterator38.return();
        }
      } finally {
        if (_didIteratorError38) {
          throw _iteratorError38;
        }
      }
    }
  };

  this.editorMenuOnSelect = function (component) {
    var _this32 = this;

    if (!component || component.area == "editor-editor") {
      // if plain editor or other editor
      this.showEditorMenu = false;
      var editor = component;
      if (this.selectedEditor && editor !== this.selectedEditor) {
        this.disassociateComponentWithCurrentNote(this.selectedEditor);
      }
      if (editor) {
        if (this.note.getAppDataItem("prefersPlainEditor") == true) {
          this.note.setAppDataItem("prefersPlainEditor", false);
          modelManager.setItemDirty(this.note, true);
        }
        this.associateComponentWithCurrentNote(editor);
      } else {
        // Note prefers plain editor
        if (!this.note.getAppDataItem("prefersPlainEditor")) {
          this.note.setAppDataItem("prefersPlainEditor", true);
          modelManager.setItemDirty(this.note, true);
        }
        $timeout(function () {
          _this32.reloadFont();
        });
      }

      this.selectedEditor = editor;
    } else if (component.area == "editor-stack") {
      // If component stack item
      this.toggleStackComponentForCurrentItem(component);
    }

    // Lots of dirtying can happen above, so we'll sync
    syncManager.sync();
  }.bind(this);

  this.hasAvailableExtensions = function () {
    return actionsManager.extensionsInContextOfItem(this.note).length > 0;
  };

  this.focusEditor = function (delay) {
    setTimeout(function () {
      var element = document.getElementById("note-text-editor");
      if (element) {
        element.focus();
      }
    }, delay);
  };

  this.focusTitle = function (delay) {
    setTimeout(function () {
      document.getElementById("note-title-editor").focus();
    }, delay);
  };

  this.clickedTextArea = function () {
    this.showMenu = false;
  };

  this.EditorNgDebounce = 200;
  var SyncDebouce = 350;
  var SyncNoDebounce = 100;

  this.saveNote = function (_ref3) {
    var _this33 = this;

    var bypassDebouncer = _ref3.bypassDebouncer,
        updateClientModified = _ref3.updateClientModified,
        dontUpdatePreviews = _ref3.dontUpdatePreviews;

    var note = this.note;
    note.dummy = false;

    if (note.deleted) {
      alert("The note you are attempting to edit has been deleted, and is awaiting sync. Changes you make will be disregarded.");
      return;
    }

    if (!modelManager.findItem(note.uuid)) {
      alert("The note you are attempting to save can not be found or has been deleted. Changes you make will not be synced. Please copy this note's text and start a new note.");
      return;
    }

    this.showSavingStatus();

    if (!dontUpdatePreviews) {
      var limit = 80;
      var text = note.text || "";
      var truncate = text.length > limit;
      note.content.preview_plain = text.substring(0, limit) + (truncate ? "..." : "");
      // Clear dynamic previews if using plain editor
      note.content.preview_html = null;
    }

    modelManager.setItemDirty(note, true, updateClientModified);

    if (this.saveTimeout) {
      $timeout.cancel(this.saveTimeout);
    }

    var syncDebouceMs = void 0;
    if (authManager.offline() || bypassDebouncer) {
      syncDebouceMs = SyncNoDebounce;
    } else {
      syncDebouceMs = SyncDebouce;
    }

    this.saveTimeout = $timeout(function () {
      syncManager.sync().then(function (response) {
        if (response && response.error && !_this33.didShowErrorAlert) {
          _this33.didShowErrorAlert = true;
          alert("There was an error saving your note. Please try again.");
        }
      });
    }, syncDebouceMs);
  };

  this.showSavingStatus = function () {
    this.setStatus({ message: "Saving..." }, false);
  };

  this.showAllChangesSavedStatus = function () {
    this.saveError = false;
    this.syncTakingTooLong = false;

    var status = "All changes saved";
    if (authManager.offline()) {
      status += " (offline)";
    }

    this.setStatus({ message: status });
  };

  this.showErrorStatus = function (error) {
    if (!error) {
      error = {
        message: "Sync Unreachable",
        desc: "Changes saved offline"
      };
    }
    this.saveError = true;
    this.syncTakingTooLong = false;
    this.setStatus(error);
  };

  this.setStatus = function (status) {
    var _this34 = this;

    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    // Keep every status up for a minimum duration so it doesnt flash crazily.
    var waitForMs = void 0;
    if (!this.noteStatus || !this.noteStatus.date) {
      waitForMs = 0;
    } else {
      waitForMs = MinimumStatusDurationMs - (new Date() - this.noteStatus.date);
    }
    if (!wait || waitForMs < 0) {
      waitForMs = 0;
    }
    if (this.statusTimeout) $timeout.cancel(this.statusTimeout);
    this.statusTimeout = $timeout(function () {
      status.date = new Date();
      _this34.noteStatus = status;
    }, waitForMs);
  };

  this.contentChanged = function () {
    this.saveNote({ updateClientModified: true });
  };

  this.onTitleEnter = function ($event) {
    $event.target.blur();
    this.onTitleChange();
    this.focusEditor();
  };

  this.onTitleChange = function () {
    this.saveNote({ dontUpdatePreviews: true, updateClientModified: true });
  };

  this.onNameFocus = function () {
    this.editingName = true;
  };

  this.onContentFocus = function () {
    $rootScope.$broadcast("editorFocused");
  };

  this.onNameBlur = function () {
    this.editingName = false;
  };

  this.selectedMenuItem = function (hide) {
    if (hide) {
      this.showMenu = false;
    }
  };

  this.deleteNote = function () {
    var _ref4 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(permanently) {
      var _this35 = this;

      var run;
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              run = function run() {
                $timeout(function () {
                  if (_this35.note.locked) {
                    alert("This note is locked. If you'd like to delete it, unlock it, and try again.");
                    return;
                  }

                  var title = _this35.note.safeTitle().length ? "'" + _this35.note.title + "'" : "this note";
                  var message = permanently ? "Are you sure you want to permanently delete " + title + "?" : "Are you sure you want to move " + title + " to the trash?";
                  if (confirm(message)) {
                    if (permanently) {
                      _this35.remove()(_this35.note);
                    } else {
                      _this35.note.content.trashed = true;
                      _this35.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });
                    }
                    _this35.showMenu = false;
                  }
                });
              };

              _context6.next = 3;
              return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionDeleteNote);

            case 3:
              if (!_context6.sent) {
                _context6.next = 7;
                break;
              }

              privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionDeleteNote, function () {
                run();
              });
              _context6.next = 8;
              break;

            case 7:
              run();

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    return function (_x2) {
      return _ref4.apply(this, arguments);
    };
  }();

  this.restoreTrashedNote = function () {
    this.note.content.trashed = false;
    this.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });
  };

  this.deleteNotePermanantely = function () {
    this.deleteNote(true);
  };

  this.getTrashCount = function () {
    return modelManager.trashedItems().length;
  };

  this.emptyTrash = function () {
    var count = this.getTrashCount();
    if (confirm("Are you sure you want to permanently delete " + count + " note(s)?")) {
      modelManager.emptyTrash();
      syncManager.sync();
    }
  };

  this.togglePin = function () {
    this.note.setAppDataItem("pinned", !this.note.pinned);
    this.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });
  };

  this.toggleLockNote = function () {
    this.note.setAppDataItem("locked", !this.note.locked);
    this.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });
  };

  this.toggleProtectNote = function () {
    this.note.content.protected = !this.note.content.protected;
    this.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });

    // Show privilegesManager if Protection is not yet set up
    privilegesManager.actionHasPrivilegesConfigured(PrivilegesManager.ActionViewProtectedNotes).then(function (configured) {
      if (!configured) {
        privilegesManager.presentPrivilegesManagementModal();
      }
    });
  };

  this.toggleNotePreview = function () {
    this.note.content.hidePreview = !this.note.content.hidePreview;
    this.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });
  };

  this.toggleArchiveNote = function () {
    this.note.setAppDataItem("archived", !this.note.archived);
    this.saveNote({ bypassDebouncer: true, dontUpdatePreviews: true });
    $rootScope.$broadcast("noteArchived");
  };

  this.clickedEditNote = function () {
    this.focusEditor(100);
  };

  /*
  Tags
  */

  this.loadTagsString = function () {
    this.tagsString = this.note.tagsString();
  };

  this.addTag = function (tag) {
    var tags = this.note.tags;
    var strings = tags.map(function (_tag) {
      return _tag.title;
    });
    strings.push(tag.title);
    this.updateTags()(this.note, strings);
    this.loadTagsString();
  };

  this.removeTag = function (tag) {
    var tags = this.note.tags;
    var strings = tags.map(function (_tag) {
      return _tag.title;
    }).filter(function (_tag) {
      return _tag !== tag.title;
    });
    this.updateTags()(this.note, strings);
    this.loadTagsString();
  };

  this.updateTagsFromTagsString = function () {
    if (this.tagsString == this.note.tagsString()) {
      return;
    }

    var strings = this.tagsString.split("#").filter(function (string) {
      return string.length > 0;
    }).map(function (string) {
      return string.trim();
    });

    this.note.dummy = false;
    this.updateTags()(this.note, strings);
  };

  /* Resizability */

  this.leftResizeControl = {};
  this.rightResizeControl = {};

  this.onPanelResizeFinish = function (width, left, isMaxWidth) {
    if (isMaxWidth) {
      authManager.setUserPrefValue("editorWidth", null);
    } else {
      if (width !== undefined && width !== null) {
        authManager.setUserPrefValue("editorWidth", width);
        _this28.leftResizeControl.setWidth(width);
      }
    }

    if (left !== undefined && left !== null) {
      authManager.setUserPrefValue("editorLeft", left);
      _this28.rightResizeControl.setLeft(left);
    }
    authManager.syncUserPreferences();
  };

  $rootScope.$on("user-preferences-changed", function () {
    _this28.loadPreferences();
  });

  this.loadPreferences = function () {
    this.monospaceFont = authManager.getUserPrefValue("monospaceFont", "monospace");

    // On desktop application, disable spellcheck by default, as it is not performant.
    var defaultSpellcheckStatus = isDesktopApplication() ? false : true;
    this.spellcheck = authManager.getUserPrefValue("spellcheck", defaultSpellcheckStatus);

    this.marginResizersEnabled = authManager.getUserPrefValue("marginResizersEnabled", true);

    if (!document.getElementById("editor-content")) {
      // Elements have not yet loaded due to ng-if around wrapper
      return;
    }

    this.reloadFont();

    if (this.marginResizersEnabled) {
      var width = authManager.getUserPrefValue("editorWidth", null);
      if (width !== null) {
        this.leftResizeControl.setWidth(width);
        this.rightResizeControl.setWidth(width);
      }

      var left = authManager.getUserPrefValue("editorLeft", null);
      if (left !== null) {
        this.leftResizeControl.setLeft(left);
        this.rightResizeControl.setLeft(left);
      }
    }
  };

  this.reloadFont = function () {
    var editable = document.getElementById("note-text-editor");

    if (!editable) {
      return;
    }

    if (this.monospaceFont) {
      if (isDesktopApplication()) {
        editable.style.fontFamily = "Menlo, Consolas, 'DejaVu Sans Mono', monospace";
      } else {
        editable.style.fontFamily = "monospace";
      }
    } else {
      editable.style.fontFamily = "inherit";
    }
  };

  this.toggleKey = function (key) {
    var _this36 = this;

    this[key] = !this[key];
    authManager.setUserPrefValue(key, this[key], true);
    this.reloadFont();

    if (key == "spellcheck") {
      // Allows textarea to reload
      this.noteReady = false;
      $timeout(function () {
        _this36.noteReady = true;
        $timeout(function () {
          _this36.reloadFont();
        });
      }, 0);
    } else if (key == "marginResizersEnabled" && this[key] == true) {
      $timeout(function () {
        _this36.leftResizeControl.flash();
        _this36.rightResizeControl.flash();
      });
    }
  };

  /*
  Components
  */

  this.onEditorLoad = function (editor) {
    desktopManager.redoSearch();
  };

  componentManager.registerHandler({ identifier: "editor", areas: ["note-tags", "editor-stack", "editor-editor"], activationHandler: function activationHandler(component) {
      if (component.area === "note-tags") {
        // Autocomplete Tags
        _this28.tagsComponent = component.active ? component : null;
      } else if (component.area == "editor-editor") {
        // An editor is already active, ensure the potential replacement is explicitely enabled for this item
        // We also check if the selectedEditor is active. If it's inactive, we want to treat it as an external reference wishing to deactivate this editor (i.e componentView)
        if (_this28.selectedEditor && _this28.selectedEditor == component && component.active == false) {
          _this28.selectedEditor = null;
        } else if (_this28.selectedEditor) {
          if (_this28.selectedEditor.active) {
            // In the case where an editor is duplicated, then you'll have two editors who are explicitely enabled for the same note.
            // This will cause an infinite loop, where as soon as the first is enabled, the second will come in, pass the `isExplicitlyEnabledForItem` check,
            // and replace the previous one. So we now check to make the current editor isn't also explicitely enabled, and if it is, then we'll just keep that one active.
            if (component.isExplicitlyEnabledForItem(_this28.note) && !_this28.selectedEditor.isExplicitlyEnabledForItem(_this28.note)) {
              _this28.selectedEditor = component;
            }
          }
        } else {
          // If no selected editor, let's see if the incoming one is a candidate
          if (component.active && _this28.note && (component.isExplicitlyEnabledForItem(_this28.note) || component.isDefaultEditor())) {
            _this28.selectedEditor = component;
          } else {
            // Not a candidate, and no selected editor. Disable the current editor by setting selectedEditor to null
            _this28.selectedEditor = null;
          }
        }
      } else if (component.area == "editor-stack") {
        _this28.reloadComponentContext();
      }
    }, contextRequestHandler: function contextRequestHandler(component) {
      if (component == _this28.selectedEditor || component == _this28.tagsComponent || _this28.componentStack.includes(component)) {
        return _this28.note;
      }
    }, focusHandler: function focusHandler(component, focused) {
      if (component.isEditor() && focused) {
        _this28.closeAllMenus();
      }
    }, actionHandler: function actionHandler(component, action, data) {
      if (action === "set-size") {
        var setSize = function setSize(element, size) {
          var widthString = typeof size.width === 'string' ? size.width : data.width + "px";
          var heightString = typeof size.height === 'string' ? size.height : data.height + "px";
          element.setAttribute("style", "width:" + widthString + "; height:" + heightString + "; ");
        };

        if (data.type == "container") {
          if (component.area == "note-tags") {
            var container = document.getElementById("note-tags-component-container");
            setSize(container, data);
          }
        }
      } else if (action === "associate-item") {
        if (data.item.content_type == "Tag") {
          var tag = modelManager.findItem(data.item.uuid);
          _this28.addTag(tag);
        }
      } else if (action === "deassociate-item") {
        var tag = modelManager.findItem(data.item.uuid);
        _this28.removeTag(tag);
      } else if (action === "save-items") {
        if (data.items.map(function (item) {
          return item.uuid;
        }).includes(_this28.note.uuid)) {
          _this28.showSavingStatus();
        }
      }
    } });

  this.reloadComponentStackArray = function () {
    this.componentStack = componentManager.componentsForArea("editor-stack").sort(function (a, b) {
      // Careful here. For some reason (probably because re-assigning array everytime quickly destroys componentView elements, causing deallocs),
      // sorting by updated_at (or any other property that may always be changing)
      // causes weird problems with ext communication when changing notes or activating/deactivating in quick succession
      return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
    });
  };

  this.reloadComponentContext = function () {
    // componentStack is used by the template to ng-repeat
    this.reloadComponentStackArray();
    /*
    In the past, we were doing this looping code even if the note wasn't currently defined.
    The problem is if an editor stack item loaded first, requested to stream items, and the note was undefined,
    we would set component.hidden = true. Which means messages would not be sent to the component.
    Theoretically, upon the note loading, we would run this code again, and unhide the extension.
    However, if you had requested to stream items when it was hidden, and then it unhid, it would never
    resend those items upon unhiding.
     Our solution here is to check that the note is defined before setting hidden. The question remains, when
    would note really ever be undefined? Maybe temprarily when you're deleting a note?
    */
    if (this.note) {
      var _iteratorNormalCompletion39 = true;
      var _didIteratorError39 = false;
      var _iteratorError39 = undefined;

      try {
        for (var _iterator39 = this.componentStack[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
          var component = _step39.value;

          if (component.active) {
            componentManager.setComponentHidden(component, !component.isExplicitlyEnabledForItem(this.note));
          }
        }
      } catch (err) {
        _didIteratorError39 = true;
        _iteratorError39 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion39 && _iterator39.return) {
            _iterator39.return();
          }
        } finally {
          if (_didIteratorError39) {
            throw _iteratorError39;
          }
        }
      }
    }

    componentManager.contextItemDidChangeInArea("note-tags");
    componentManager.contextItemDidChangeInArea("editor-stack");
    componentManager.contextItemDidChangeInArea("editor-editor");
  };

  this.toggleStackComponentForCurrentItem = function (component) {
    // If it's hidden, we want to show it
    // If it's not active, then hidden won't be set, and we mean to activate and show it.
    if (component.hidden || !component.active) {
      // Unhide, associate with current item
      componentManager.setComponentHidden(component, false);
      this.associateComponentWithCurrentNote(component);
      if (!component.active) {
        componentManager.activateComponent(component);
      }
      componentManager.contextItemDidChangeInArea("editor-stack");
    } else {
      // not hidden, hide
      componentManager.setComponentHidden(component, true);
      this.disassociateComponentWithCurrentNote(component);
    }
  };

  this.disassociateComponentWithCurrentNote = function (component) {
    var _this37 = this;

    component.associatedItemIds = component.associatedItemIds.filter(function (id) {
      return id !== _this37.note.uuid;
    });

    if (!component.disassociatedItemIds.includes(this.note.uuid)) {
      component.disassociatedItemIds.push(this.note.uuid);
    }

    modelManager.setItemDirty(component, true);
    syncManager.sync();
  };

  this.associateComponentWithCurrentNote = function (component) {
    var _this38 = this;

    component.disassociatedItemIds = component.disassociatedItemIds.filter(function (id) {
      return id !== _this38.note.uuid;
    });

    if (!component.associatedItemIds.includes(this.note.uuid)) {
      component.associatedItemIds.push(this.note.uuid);
    }

    modelManager.setItemDirty(component, true);
    syncManager.sync();
  };

  this.altKeyObserver = keyboardManager.addKeyObserver({
    modifiers: [KeyboardManager.KeyModifierAlt],
    onKeyDown: function onKeyDown() {
      $timeout(function () {
        _this28.altKeyDown = true;
      });
    },
    onKeyUp: function onKeyUp() {
      $timeout(function () {
        _this28.altKeyDown = false;
      });
    }
  });

  this.trashKeyObserver = keyboardManager.addKeyObserver({
    key: KeyboardManager.KeyBackspace,
    notElementIds: ["note-text-editor", "note-title-editor"],
    modifiers: [KeyboardManager.KeyModifierMeta],
    onKeyDown: function onKeyDown() {
      $timeout(function () {
        _this28.deleteNote();
      });
    }
  });

  this.deleteKeyObserver = keyboardManager.addKeyObserver({
    key: KeyboardManager.KeyBackspace,
    modifiers: [KeyboardManager.KeyModifierMeta, KeyboardManager.KeyModifierShift, KeyboardManager.KeyModifierAlt],
    onKeyDown: function onKeyDown(event) {
      event.preventDefault();
      $timeout(function () {
        _this28.deleteNote(true);
      });
    }
  });

  /*
  Editor Customization
  */

  this.onSystemEditorLoad = function () {
    var _this39 = this;

    if (this.loadedTabListener) {
      return;
    }
    this.loadedTabListener = true;

    /**
     * Insert 4 spaces when a tab key is pressed,
     * only used when inside of the text editor.
     * If the shift key is pressed first, this event is
     * not fired.
    */

    var editor = document.getElementById("note-text-editor");
    this.tabObserver = keyboardManager.addKeyObserver({
      element: editor,
      key: KeyboardManager.KeyTab,
      onKeyDown: function onKeyDown(event) {
        if (event.shiftKey) {
          return;
        }

        if (_this39.note.locked) {
          return;
        }

        event.preventDefault();

        // Using document.execCommand gives us undo support
        var insertSuccessful = document.execCommand("insertText", false, "\t");
        if (!insertSuccessful) {
          // document.execCommand works great on Chrome/Safari but not Firefox
          var start = editor.selectionStart;
          var end = editor.selectionEnd;
          var spaces = "    ";

          // Insert 4 spaces
          editor.value = editor.value.substring(0, start) + spaces + editor.value.substring(end);

          // Place cursor 4 spaces away from where
          // the tab key was pressed
          editor.selectionStart = editor.selectionEnd = start + 4;
        }

        $timeout(function () {
          _this39.note.text = editor.value;
          _this39.saveNote({ bypassDebouncer: true });
        });
      }
    });

    // This handles when the editor itself is destroyed, and not when our controller is destroyed.
    angular.element(editor).on('$destroy', function () {
      if (this.tabObserver) {
        keyboardManager.removeKeyObserver(this.tabObserver);
        this.loadedTabListener = false;
      }
    }.bind(this));
  };
});
;angular.module('app').directive("footer", function (authManager) {
  return {
    restrict: 'E',
    scope: {},
    templateUrl: 'footer.html',
    replace: true,
    controller: 'FooterCtrl',
    controllerAs: 'ctrl',
    bindToController: true,

    link: function link(scope, elem, attrs, ctrl) {
      scope.$on("sync:completed", function () {
        ctrl.syncUpdated();
        ctrl.findErrors();
        ctrl.updateOfflineStatus();
      });
      scope.$on("sync:error", function () {
        ctrl.findErrors();
        ctrl.updateOfflineStatus();
      });
    }
  };
}).controller('FooterCtrl', function ($rootScope, authManager, modelManager, $timeout, dbManager, syncManager, storageManager, passcodeManager, componentManager, singletonManager, nativeExtManager, privilegesManager, statusManager) {
  var _this40 = this;

  authManager.checkForSecurityUpdate().then(function (available) {
    _this40.securityUpdateAvailable = available;
  });

  $rootScope.$on("security-update-status-changed", function () {
    _this40.securityUpdateAvailable = authManager.securityUpdateAvailable;
  });

  statusManager.addStatusObserver(function (string) {
    $timeout(function () {
      _this40.arbitraryStatusMessage = string;
    });
  });

  $rootScope.$on("did-begin-local-backup", function () {
    $timeout(function () {
      _this40.backupStatus = statusManager.addStatusFromString("Saving local backup...");
    });
  });

  $rootScope.$on("did-finish-local-backup", function (event, data) {
    $timeout(function () {
      if (data.success) {
        _this40.backupStatus = statusManager.replaceStatusWithString(_this40.backupStatus, "Successfully saved backup.");
      } else {
        _this40.backupStatus = statusManager.replaceStatusWithString(_this40.backupStatus, "Unable to save local backup.");
      }

      $timeout(function () {
        _this40.backupStatus = statusManager.removeStatus(_this40.backupStatus);
      }, 2000);
    });
  });

  this.openSecurityUpdate = function () {
    authManager.presentPasswordWizard("upgrade-security");
  };

  $rootScope.$on("reload-ext-data", function () {
    _this40.reloadExtendedData();
  });

  this.reloadExtendedData = function () {
    if (_this40.reloadInProgress) {
      return;
    }
    _this40.reloadInProgress = true;

    // A reload occurs when the extensions manager window is opened. We can close it after a delay
    var extWindow = _this40.rooms.find(function (room) {
      return room.package_info.identifier == nativeExtManager.extensionsManagerIdentifier;
    });
    if (!extWindow) {
      _this40.queueExtReload = true; // try again when the ext is available
      _this40.reloadInProgress = false;
      return;
    }

    _this40.selectRoom(extWindow);

    $timeout(function () {
      _this40.selectRoom(extWindow);
      _this40.reloadInProgress = false;
      $rootScope.$broadcast("ext-reload-complete");
    }, 2000);
  };

  this.getUser = function () {
    return authManager.user;
  };

  this.updateOfflineStatus = function () {
    this.offline = authManager.offline();
  };
  this.updateOfflineStatus();

  syncManager.addEventHandler(function (syncEvent, data) {
    $timeout(function () {
      if (syncEvent == "local-data-loaded") {
        // If the user has no notes and is offline, show Account menu
        if (_this40.offline && modelManager.noteCount() == 0) {
          _this40.showAccountMenu = true;
        }
      } else if (syncEvent == "enter-out-of-sync") {
        _this40.outOfSync = true;
      } else if (syncEvent == "exit-out-of-sync") {
        _this40.outOfSync = false;
      }
    });
  });

  this.findErrors = function () {
    this.error = syncManager.syncStatus.error;
  };
  this.findErrors();

  this.onAuthSuccess = function () {
    this.showAccountMenu = false;
  }.bind(this);

  this.accountMenuPressed = function () {
    this.showAccountMenu = !this.showAccountMenu;
    this.closeAllRooms();
  };

  this.toggleSyncResolutionMenu = function () {
    this.showSyncResolution = !this.showSyncResolution;
  }.bind(this);

  this.closeAccountMenu = function () {
    _this40.showAccountMenu = false;
  };

  this.hasPasscode = function () {
    return passcodeManager.hasPasscode();
  };

  this.lockApp = function () {
    $rootScope.lockApplication();
  };

  this.refreshData = function () {
    var _this41 = this;

    this.isRefreshing = true;
    // Enable integrity checking for this force request
    syncManager.sync({ force: true, performIntegrityCheck: true }).then(function (response) {
      $timeout(function () {
        this.isRefreshing = false;
      }.bind(_this41), 200);
      if (response && response.error) {
        alert("There was an error syncing. Please try again. If all else fails, try signing out and signing back in.");
      } else {
        _this41.syncUpdated();
      }
    });
  };

  this.syncUpdated = function () {
    this.lastSyncDate = new Date();
  };

  $rootScope.$on("new-update-available", function (version) {
    $timeout(function () {
      // timeout calls apply() which is needed
      this.onNewUpdateAvailable();
    }.bind(this));
  }.bind(this));

  this.onNewUpdateAvailable = function () {
    this.newUpdateAvailable = true;
  };

  this.clickedNewUpdateAnnouncement = function () {
    this.newUpdateAvailable = false;
    alert("A new update is ready to install. Please use the top-level 'Updates' menu to manage installation.");
  };

  /* Rooms */

  this.componentManager = componentManager;
  this.rooms = [];
  this.themesWithIcons = [];

  modelManager.addItemSyncObserver("room-bar", "SN|Component", function (allItems, validItems, deletedItems, source) {
    _this40.rooms = modelManager.components.filter(function (candidate) {
      return candidate.area == "rooms" && !candidate.deleted;
    });
    if (_this40.queueExtReload) {
      _this40.queueExtReload = false;
      _this40.reloadExtendedData();
    }
  });

  modelManager.addItemSyncObserver("footer-bar-themes", "SN|Theme", function (allItems, validItems, deletedItems, source) {
    var themes = modelManager.validItemsForContentType("SN|Theme").filter(function (candidate) {
      return !candidate.deleted && candidate.content.package_info && candidate.content.package_info.dock_icon;
    }).sort(function (a, b) {
      return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
    });

    var differ = themes.length != _this40.themesWithIcons.length;

    _this40.themesWithIcons = themes;

    if (differ) {
      _this40.reloadDockShortcuts();
    }
  });

  this.reloadDockShortcuts = function () {
    var shortcuts = [];
    var _iteratorNormalCompletion40 = true;
    var _didIteratorError40 = false;
    var _iteratorError40 = undefined;

    try {
      for (var _iterator40 = this.themesWithIcons[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
        var theme = _step40.value;

        var icon = theme.content.package_info.dock_icon;
        if (!icon) {
          continue;
        }
        shortcuts.push({
          component: theme,
          icon: icon
        });
      }
    } catch (err) {
      _didIteratorError40 = true;
      _iteratorError40 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion40 && _iterator40.return) {
          _iterator40.return();
        }
      } finally {
        if (_didIteratorError40) {
          throw _iteratorError40;
        }
      }
    }

    this.dockShortcuts = shortcuts.sort(function (a, b) {
      // circles first, then images

      var aType = a.icon.type;
      var bType = b.icon.type;

      if (aType == bType) {
        return 0;
      } else if (aType == "circle" && bType == "svg") {
        return -1;
      } else if (bType == "circle" && aType == "svg") {
        return 1;
      }
    });
  };

  this.initSvgForShortcut = function (shortcut) {
    var id = "dock-svg-" + shortcut.component.uuid;
    var element = document.getElementById(id);
    var parser = new DOMParser();
    var svg = shortcut.component.content.package_info.dock_icon.source;
    var doc = parser.parseFromString(svg, "image/svg+xml");
    element.appendChild(doc.documentElement);
  };

  this.selectShortcut = function (shortcut) {
    componentManager.toggleComponent(shortcut.component);
  };

  componentManager.registerHandler({ identifier: "roomBar", areas: ["rooms", "modal"], activationHandler: function activationHandler(component) {
      // RIP: There used to be code here that checked if component.active was true, and if so, displayed the component.
      // However, we no longer want to persist active state for footer extensions. If you open Extensions on one computer,
      // it shouldn't open on another computer. Active state should only be persisted for persistent extensions, like Folders.
    }, actionHandler: function actionHandler(component, action, data) {
      if (action == "set-size") {
        component.setLastSize(data);
      }
    }, focusHandler: function focusHandler(component, focused) {
      if (component.isEditor() && focused) {
        _this40.closeAllRooms();
        _this40.closeAccountMenu();
      }
    } });

  $rootScope.$on("editorFocused", function () {
    _this40.closeAllRooms();
    _this40.closeAccountMenu();
  });

  this.onRoomDismiss = function (room) {
    room.showRoom = false;
  };

  this.closeAllRooms = function () {
    var _iteratorNormalCompletion41 = true;
    var _didIteratorError41 = false;
    var _iteratorError41 = undefined;

    try {
      for (var _iterator41 = this.rooms[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
        var room = _step41.value;

        room.showRoom = false;
      }
    } catch (err) {
      _didIteratorError41 = true;
      _iteratorError41 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion41 && _iterator41.return) {
          _iterator41.return();
        }
      } finally {
        if (_didIteratorError41) {
          throw _iteratorError41;
        }
      }
    }
  };

  this.selectRoom = function () {
    var _ref7 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(room) {
      var run;
      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              run = function run() {
                $timeout(function () {
                  room.showRoom = !room.showRoom;
                });
              };

              if (room.showRoom) {
                _context7.next = 11;
                break;
              }

              _context7.next = 4;
              return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManageExtensions);

            case 4:
              if (!_context7.sent) {
                _context7.next = 8;
                break;
              }

              privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManageExtensions, function () {
                run();
              });
              _context7.next = 9;
              break;

            case 8:
              run();

            case 9:
              _context7.next = 12;
              break;

            case 11:
              run();

            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    return function (_x7) {
      return _ref7.apply(this, arguments);
    };
  }();

  this.clickOutsideAccountMenu = function () {
    if (privilegesManager.authenticationInProgress()) {
      return;
    }
    this.showAccountMenu = false;
  };
});
;angular.module('app').controller('HomeCtrl', function ($scope, $location, $rootScope, $timeout, modelManager, dbManager, syncManager, authManager, themeManager, passcodeManager, storageManager, migrationManager, privilegesManager, statusManager) {
  var _this42 = this;

  var autoSignInFromParams = function () {
    var _ref9 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
      var server, email, pw;
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              server = urlParam("server");
              email = urlParam("email");
              pw = urlParam("pw");

              if (authManager.offline()) {
                _context9.next = 18;
                break;
              }

              _context9.next = 6;
              return syncManager.getServerURL();

            case 6:
              _context9.t1 = _context9.sent;
              _context9.t2 = server;
              _context9.t0 = _context9.t1 === _context9.t2;

              if (!_context9.t0) {
                _context9.next = 11;
                break;
              }

              _context9.t0 = authManager.user.email === email;

            case 11:
              if (!_context9.t0) {
                _context9.next = 15;
                break;
              }

              return _context9.abrupt("return");

            case 15:
              // sign out
              authManager.signout(true).then(function () {
                window.location.reload();
              });

            case 16:
              _context9.next = 19;
              break;

            case 18:
              authManager.login(server, email, pw, false, false, {}).then(function (response) {
                window.location.reload();
              });

            case 19:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    return function autoSignInFromParams() {
      return _ref9.apply(this, arguments);
    };
  }();

  storageManager.initialize(passcodeManager.hasPasscode(), authManager.isEphemeralSession());

  $scope.platform = getPlatformString();

  $scope.onUpdateAvailable = function (version) {
    $rootScope.$broadcast('new-update-available', version);
  };

  $rootScope.$on("panel-resized", function (event, info) {
    if (info.panel == "notes") {
      _this42.notesCollapsed = info.collapsed;
    }
    if (info.panel == "tags") {
      _this42.tagsCollapsed = info.collapsed;
    }

    var appClass = "";
    if (_this42.notesCollapsed) {
      appClass += "collapsed-notes";
    }
    if (_this42.tagsCollapsed) {
      appClass += " collapsed-tags";
    }

    $scope.appClass = appClass;
  });

  /* Used to avoid circular dependencies where syncManager cannot be imported but rootScope can */
  $rootScope.sync = function (source) {
    syncManager.sync();
  };

  $rootScope.lockApplication = function () {
    // Reloading wipes current objects from memory
    window.location.reload();
  };

  var initiateSync = function initiateSync() {
    authManager.loadInitialData();

    _this42.syncStatusObserver = syncManager.registerSyncStatusObserver(function (status) {
      if (status.retrievedCount > 20) {
        var text = "Downloading " + status.retrievedCount + " items. Keep app open.";
        _this42.syncStatus = statusManager.replaceStatusWithString(_this42.syncStatus, text);
        _this42.showingDownloadStatus = true;
      } else if (_this42.showingDownloadStatus) {
        _this42.showingDownloadStatus = false;
        var text = "Download Complete.";
        _this42.syncStatus = statusManager.replaceStatusWithString(_this42.syncStatus, text);
        setTimeout(function () {
          _this42.syncStatus = statusManager.removeStatus(_this42.syncStatus);
        }, 2000);
      } else if (status.total > 20) {
        _this42.uploadSyncStatus = statusManager.replaceStatusWithString(_this42.uploadSyncStatus, "Syncing " + status.current + "/" + status.total + " items...");
      } else if (_this42.uploadSyncStatus) {
        _this42.uploadSyncStatus = statusManager.removeStatus(_this42.uploadSyncStatus);
      }
    });

    syncManager.setKeyRequestHandler((0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
      var offline, auth_params, keys;
      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              offline = authManager.offline();

              if (!offline) {
                _context8.next = 5;
                break;
              }

              _context8.t0 = passcodeManager.passcodeAuthParams();
              _context8.next = 8;
              break;

            case 5:
              _context8.next = 7;
              return authManager.getAuthParams();

            case 7:
              _context8.t0 = _context8.sent;

            case 8:
              auth_params = _context8.t0;

              if (!offline) {
                _context8.next = 13;
                break;
              }

              _context8.t1 = passcodeManager.keys();
              _context8.next = 16;
              break;

            case 13:
              _context8.next = 15;
              return authManager.keys();

            case 15:
              _context8.t1 = _context8.sent;

            case 16:
              keys = _context8.t1;
              return _context8.abrupt("return", {
                keys: keys,
                offline: offline,
                auth_params: auth_params
              });

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, _this42);
    })));

    var lastSessionInvalidAlert = void 0;

    syncManager.addEventHandler(function (syncEvent, data) {
      $rootScope.$broadcast(syncEvent, data || {});
      if (syncEvent == "sync-session-invalid") {
        // On Windows, some users experience issues where this message keeps appearing. It might be that on focus, the app syncs, and this message triggers again.
        // We'll only show it once every X seconds
        var showInterval = 30; // At most 30 seconds in between
        if (!lastSessionInvalidAlert || (new Date() - lastSessionInvalidAlert) / 1000 > showInterval) {
          lastSessionInvalidAlert = new Date();
          setTimeout(function () {
            // If this alert is displayed on launch, it may sometimes dismiss automatically really quicky for some reason. So we wrap in timeout
            alert("Your session has expired. New changes will not be pulled in. Please sign out and sign back in to refresh your session.");
          }, 500);
        }
      } else if (syncEvent == "sync-exception") {
        alert("There was an error while trying to save your items. Please contact support and share this message: " + data);
      }
    });

    var encryptionEnabled = authManager.user || passcodeManager.hasPasscode();
    _this42.syncStatus = statusManager.addStatusFromString(encryptionEnabled ? "Decrypting items..." : "Loading items...");

    var incrementalCallback = function incrementalCallback(current, total) {
      var notesString = current + "/" + total + " items...";
      _this42.syncStatus = statusManager.replaceStatusWithString(_this42.syncStatus, encryptionEnabled ? "Decrypting " + notesString : "Loading " + notesString);
    };

    syncManager.loadLocalItems({ incrementalCallback: incrementalCallback }).then(function () {
      $timeout(function () {
        $rootScope.$broadcast("initial-data-loaded"); // This needs to be processed first before sync is called so that singletonManager observers function properly.
        // Perform integrity check on first sync
        _this42.syncStatus = statusManager.replaceStatusWithString(_this42.syncStatus, "Syncing...");
        syncManager.sync({ performIntegrityCheck: true }).then(function () {
          _this42.syncStatus = statusManager.removeStatus(_this42.syncStatus);
        });
        // refresh every 30s
        setInterval(function () {
          syncManager.sync();
        }, 30000);
      });
    });

    authManager.addEventHandler(function (event) {
      if (event == SFAuthManager.DidSignOutEvent) {
        modelManager.handleSignout();
        syncManager.handleSignout();
      }
    });
  };

  function load() {
    // pass keys to storageManager to decrypt storage
    // Update: Wait, why? passcodeManager already handles this.
    // storageManager.setKeys(passcodeManager.keys());

    openDatabase();
    // Retrieve local data and begin sycing timer
    initiateSync();
  }

  if (passcodeManager.isLocked()) {
    $scope.needsUnlock = true;
  } else {
    load();
  }

  $scope.onSuccessfulUnlock = function () {
    $timeout(function () {
      $scope.needsUnlock = false;
      load();
    });
  };

  function openDatabase() {
    dbManager.setLocked(false);
    dbManager.openDatabase(null, function () {
      // new database, delete syncToken so that items can be refetched entirely from server
      syncManager.clearSyncToken();
      syncManager.sync();
    });
  }

  /*
  Editor Callbacks
  */

  $scope.updateTagsForNote = function (note, stringTags) {
    var toRemove = [];
    var _iteratorNormalCompletion42 = true;
    var _didIteratorError42 = false;
    var _iteratorError42 = undefined;

    try {
      for (var _iterator42 = note.tags[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
        var tag = _step42.value;

        if (stringTags.indexOf(tag.title) === -1) {
          // remove this tag
          toRemove.push(tag);
        }
      }
    } catch (err) {
      _didIteratorError42 = true;
      _iteratorError42 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion42 && _iterator42.return) {
          _iterator42.return();
        }
      } finally {
        if (_didIteratorError42) {
          throw _iteratorError42;
        }
      }
    }

    var _iteratorNormalCompletion43 = true;
    var _didIteratorError43 = false;
    var _iteratorError43 = undefined;

    try {
      for (var _iterator43 = toRemove[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
        var tagToRemove = _step43.value;

        tagToRemove.removeItemAsRelationship(note);
      }
    } catch (err) {
      _didIteratorError43 = true;
      _iteratorError43 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion43 && _iterator43.return) {
          _iterator43.return();
        }
      } finally {
        if (_didIteratorError43) {
          throw _iteratorError43;
        }
      }
    }

    modelManager.setItemsDirty(toRemove, true);

    var tags = [];
    var _iteratorNormalCompletion44 = true;
    var _didIteratorError44 = false;
    var _iteratorError44 = undefined;

    try {
      for (var _iterator44 = stringTags[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
        var tagString = _step44.value;

        var existingRelationship = _.find(note.tags, { title: tagString });
        if (!existingRelationship) {
          tags.push(modelManager.findOrCreateTagByTitle(tagString));
        }
      }
    } catch (err) {
      _didIteratorError44 = true;
      _iteratorError44 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion44 && _iterator44.return) {
          _iterator44.return();
        }
      } finally {
        if (_didIteratorError44) {
          throw _iteratorError44;
        }
      }
    }

    var _iteratorNormalCompletion45 = true;
    var _didIteratorError45 = false;
    var _iteratorError45 = undefined;

    try {
      for (var _iterator45 = tags[Symbol.iterator](), _step45; !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
        var tag = _step45.value;

        tag.addItemAsRelationship(note);
      }
    } catch (err) {
      _didIteratorError45 = true;
      _iteratorError45 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion45 && _iterator45.return) {
          _iterator45.return();
        }
      } finally {
        if (_didIteratorError45) {
          throw _iteratorError45;
        }
      }
    }

    modelManager.setItemsDirty(tags, true);

    syncManager.sync();
  };

  /*
  Tags Ctrl Callbacks
  */

  $scope.tagsSelectionMade = function (tag) {
    // If a tag is selected twice, then the needed dummy note is removed.
    // So we perform this check.
    if ($scope.selectedTag && tag && $scope.selectedTag.uuid == tag.uuid) {
      return;
    }

    if ($scope.selectedNote && $scope.selectedNote.dummy) {
      modelManager.removeItemLocally($scope.selectedNote);
      $scope.selectedNote = null;
    }

    $scope.selectedTag = tag;
  };

  $scope.tagsAddNew = function (tag) {
    modelManager.addItem(tag);
  };

  $scope.tagsSave = function (tag, callback) {
    if (!tag.title || tag.title.length == 0) {
      $scope.removeTag(tag);
      return;
    }

    modelManager.setItemDirty(tag, true);
    syncManager.sync().then(callback);
    modelManager.resortTag(tag);
  };

  /*
  Notes Ctrl Callbacks
  */

  $scope.removeTag = function (tag) {
    if (confirm("Are you sure you want to delete this tag? Note: deleting a tag will not delete its notes.")) {
      modelManager.setItemToBeDeleted(tag);
      syncManager.sync().then(function () {
        // force scope tags to update on sub directives
        $rootScope.safeApply();
      });
    }
  };

  $scope.notesSelectionMade = function (note) {
    $scope.selectedNote = note;
  };

  $scope.notesAddNew = function (note) {
    modelManager.addItem(note);
    modelManager.setItemDirty(note);

    if (!$scope.selectedTag.isSmartTag()) {
      $scope.selectedTag.addItemAsRelationship(note);
      modelManager.setItemDirty($scope.selectedTag, true);
    }
  };

  /*
  Shared Callbacks
  */

  $rootScope.safeApply = function (fn) {
    var phase = this.$root.$$phase;
    if (phase == '$apply' || phase == '$digest') this.$eval(fn);else this.$apply(fn);
  };

  $rootScope.notifyDelete = function () {
    $timeout(function () {
      $rootScope.$broadcast("noteDeleted");
    }.bind(this), 0);
  };

  $scope.deleteNote = function (note) {
    modelManager.setItemToBeDeleted(note);

    if (note == $scope.selectedNote) {
      $scope.selectedNote = null;
    }

    if (note.dummy) {
      modelManager.removeItemLocally(note);
      $rootScope.notifyDelete();
      return;
    }

    syncManager.sync().then(function () {
      if (authManager.offline()) {
        // when deleting items while ofline, we need to explictly tell angular to refresh UI
        setTimeout(function () {
          $rootScope.notifyDelete();
          $rootScope.safeApply();
        }, 50);
      } else {
        $timeout(function () {
          $rootScope.notifyDelete();
        });
      }
    });
  };

  /*
    Disable dragging and dropping of files into main SN interface.
    both 'dragover' and 'drop' are required to prevent dropping of files.
    This will not prevent extensions from receiving drop events.
  */
  window.addEventListener('dragover', function (event) {
    event.preventDefault();
  }, false);

  window.addEventListener('drop', function (event) {
    event.preventDefault();
    alert("Please use FileSafe or the Bold Editor to attach images and files. Learn more at standardnotes.org/filesafe.");
  }, false);

  /*
    Handle Auto Sign In From URL
  */

  function urlParam(key) {
    return $location.search()[key];
  }

  if (urlParam("server")) {
    autoSignInFromParams();
  }
});
;
var LockScreen = function () {
  function LockScreen() {
    (0, _classCallCheck4.default)(this, LockScreen);

    this.restrict = "E";
    this.templateUrl = "lock-screen.html";
    this.scope = {
      onSuccess: "&"
    };
  }

  (0, _createClass4.default)(LockScreen, [{
    key: "controller",
    value: function controller($scope, passcodeManager, authManager, syncManager, storageManager) {
      'ngInject';

      var _this43 = this;

      $scope.formData = {};

      this.visibilityObserver = passcodeManager.addVisibilityObserver(function (visible) {
        if (visible) {
          var input = document.getElementById("passcode-input");
          if (input) {
            input.focus();
          }
        }
      });

      $scope.$on("$destroy", function () {
        passcodeManager.removeVisibilityObserver(_this43.visibilityObserver);
      });

      $scope.submitPasscodeForm = function () {
        if (!$scope.formData.passcode || $scope.formData.passcode.length == 0) {
          return;
        }
        passcodeManager.unlock($scope.formData.passcode, function (success) {
          if (!success) {
            alert("Invalid passcode. Please try again.");
            return;
          }

          $scope.onSuccess()();
        });
      };

      $scope.forgotPasscode = function () {
        $scope.formData.showRecovery = true;
      };

      $scope.beginDeleteData = function () {
        if (!confirm("Are you sure you want to clear all local data?")) {
          return;
        }

        authManager.signout(true).then(function () {
          window.location.reload();
        });
      };
    }
  }]);
  return LockScreen;
}();

angular.module('app').directive('lockScreen', function () {
  return new LockScreen();
});
;angular.module('app').directive("notesSection", function () {
  return {
    scope: {
      addNew: "&",
      selectionMade: "&",
      tag: "="
    },

    templateUrl: 'notes.html',
    replace: true,
    controller: 'NotesCtrl',
    controllerAs: 'ctrl',
    bindToController: true,

    link: function link(scope, elem, attrs, ctrl) {
      scope.$watch('ctrl.tag', function (tag, oldTag) {
        if (tag) {
          ctrl.tagDidChange(tag, oldTag);
        }
      });
    }
  };
}).controller('NotesCtrl', function (authManager, $timeout, $rootScope, modelManager, syncManager, storageManager, desktopManager, privilegesManager, keyboardManager) {
  var _this44 = this;

  this.panelController = {};
  this.searchSubmitted = false;

  $rootScope.$on("user-preferences-changed", function () {
    _this44.loadPreferences();
    _this44.reloadNotes();
  });

  authManager.addEventHandler(function (event) {
    if (event == SFAuthManager.DidSignInEvent) {
      // Delete dummy note if applicable
      if (_this44.selectedNote && _this44.selectedNote.dummy) {
        modelManager.removeItemLocally(_this44.selectedNote);
        _.pull(_this44.notes, _this44.selectedNote);
        _this44.selectedNote = null;
        _this44.selectNote(null);

        // We now want to see if the user will download any items from the server.
        // If the next sync completes and our notes are still 0, we need to create a dummy.
        _this44.createDummyOnSynCompletionIfNoNotes = true;
      }
    }
  });

  syncManager.addEventHandler(function (syncEvent, data) {
    if (syncEvent == "local-data-loaded") {
      if (_this44.notes.length == 0) {
        _this44.createNewNote();
      }
    } else if (syncEvent == "sync:completed") {
      // Pad with a timeout just to be extra patient
      $timeout(function () {
        if (_this44.createDummyOnSynCompletionIfNoNotes && _this44.notes.length == 0) {
          _this44.createDummyOnSynCompletionIfNoNotes = false;
          _this44.createNewNote();
        }
      }, 100);
    }
  });

  modelManager.addItemSyncObserver("note-list", "*", function (allItems, validItems, deletedItems, source, sourceKey) {
    // reload our notes
    _this44.reloadNotes();

    // Note has changed values, reset its flags
    var notes = allItems.filter(function (item) {
      return item.content_type == "Note";
    });
    var _iteratorNormalCompletion46 = true;
    var _didIteratorError46 = false;
    var _iteratorError46 = undefined;

    try {
      for (var _iterator46 = notes[Symbol.iterator](), _step46; !(_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done); _iteratorNormalCompletion46 = true) {
        var note = _step46.value;

        _this44.loadFlagsForNote(note);
        note.cachedCreatedAtString = note.createdAtString();
        note.cachedUpdatedAtString = note.updatedAtString();
      }

      // select first note if none is selected
    } catch (err) {
      _didIteratorError46 = true;
      _iteratorError46 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion46 && _iterator46.return) {
          _iterator46.return();
        }
      } finally {
        if (_didIteratorError46) {
          throw _iteratorError46;
        }
      }
    }

    if (!_this44.selectedNote) {
      $timeout(function () {
        // required to be in timeout since selecting notes depends on rendered notes
        _this44.selectFirstNote();
      });
    }
  });

  this.setNotes = function (notes) {
    notes = this.filterNotes(notes);
    notes = this.sortNotes(notes, this.sortBy, this.sortReverse);
    var _iteratorNormalCompletion47 = true;
    var _didIteratorError47 = false;
    var _iteratorError47 = undefined;

    try {
      for (var _iterator47 = notes[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
        var note = _step47.value;

        note.shouldShowTags = this.shouldShowTagsForNote(note);
      }
    } catch (err) {
      _didIteratorError47 = true;
      _iteratorError47 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion47 && _iterator47.return) {
          _iterator47.return();
        }
      } finally {
        if (_didIteratorError47) {
          throw _iteratorError47;
        }
      }
    }

    this.notes = notes;

    this.reloadPanelTitle();
  };

  this.reloadNotes = function () {
    var notes = this.tag.notes;

    // Typically we reload flags via modelManager.addItemSyncObserver,
    // but sync observers are not notified of errored items, so we'll do it here instead
    var _iteratorNormalCompletion48 = true;
    var _didIteratorError48 = false;
    var _iteratorError48 = undefined;

    try {
      for (var _iterator48 = notes[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
        var note = _step48.value;

        if (note.errorDecrypting) {
          this.loadFlagsForNote(note);
        }
      }
    } catch (err) {
      _didIteratorError48 = true;
      _iteratorError48 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion48 && _iterator48.return) {
          _iterator48.return();
        }
      } finally {
        if (_didIteratorError48) {
          throw _iteratorError48;
        }
      }
    }

    this.setNotes(notes);
  };

  this.reorderNotes = function () {
    this.setNotes(this.notes);
  };

  this.loadPreferences = function () {
    var _this45 = this;

    var prevSortValue = this.sortBy;

    this.sortBy = authManager.getUserPrefValue("sortBy", "created_at");
    this.sortReverse = authManager.getUserPrefValue("sortReverse", false);

    if (this.sortBy == "updated_at") {
      // use client_updated_at instead
      this.sortBy = "client_updated_at";
    }

    if (prevSortValue && prevSortValue != this.sortBy) {
      $timeout(function () {
        _this45.selectFirstNote();
      });
    }

    this.showArchived = authManager.getUserPrefValue("showArchived", false);
    this.hidePinned = authManager.getUserPrefValue("hidePinned", false);
    this.hideNotePreview = authManager.getUserPrefValue("hideNotePreview", false);
    this.hideDate = authManager.getUserPrefValue("hideDate", false);
    this.hideTags = authManager.getUserPrefValue("hideTags", false);

    var width = authManager.getUserPrefValue("notesPanelWidth");
    if (width) {
      this.panelController.setWidth(width);
      if (this.panelController.isCollapsed()) {
        $rootScope.$broadcast("panel-resized", { panel: "notes", collapsed: this.panelController.isCollapsed() });
      }
    }
  };

  this.loadPreferences();

  this.onPanelResize = function (newWidth, lastLeft, isAtMaxWidth, isCollapsed) {
    authManager.setUserPrefValue("notesPanelWidth", newWidth);
    authManager.syncUserPreferences();
    $rootScope.$broadcast("panel-resized", { panel: "notes", collapsed: isCollapsed });
  };

  angular.element(document).ready(function () {
    _this44.loadPreferences();
  });

  $rootScope.$on("editorFocused", function () {
    this.showMenu = false;
  }.bind(this));

  $rootScope.$on("noteDeleted", function () {
    $timeout(this.onNoteRemoval.bind(this));
  }.bind(this));

  $rootScope.$on("noteArchived", function () {
    $timeout(this.onNoteRemoval.bind(this));
  }.bind(this));

  // When a note is removed from the list
  this.onNoteRemoval = function () {
    var visibleNotes = this.visibleNotes();
    var index = void 0;
    if (this.selectedIndex < visibleNotes.length) {
      index = Math.max(this.selectedIndex, 0);
    } else {
      index = visibleNotes.length - 1;
    }

    var note = visibleNotes[index];
    if (note) {
      this.selectNote(note);
    } else {
      this.createNewNote();
    }
  };

  window.onresize = function (event) {
    _this44.resetPagination({ keepCurrentIfLarger: true });
  };

  this.paginate = function () {
    this.notesToDisplay += this.DefaultNotesToDisplayValue;

    if (this.searchSubmitted) {
      desktopManager.searchText(this.noteFilter.text);
    }
  };

  this.resetPagination = function () {
    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        keepCurrentIfLarger = _ref10.keepCurrentIfLarger;

    var MinNoteHeight = 51.0; // This is the height of a note cell with nothing but the title, which *is* a display option
    this.DefaultNotesToDisplayValue = document.documentElement.clientHeight / MinNoteHeight || 20;
    if (keepCurrentIfLarger && this.notesToDisplay > this.DefaultNotesToDisplayValue) {
      return;
    }
    this.notesToDisplay = this.DefaultNotesToDisplayValue;
  };

  this.resetPagination();

  this.reloadPanelTitle = function () {
    if (this.isFiltering()) {
      this.panelTitle = this.notes.filter(function (i) {
        return i.visible;
      }).length + " search results";
    } else if (this.tag) {
      this.panelTitle = "" + this.tag.title;
    }
  };

  this.optionsSubtitle = function () {
    var base = "";
    if (this.sortBy == "created_at") {
      base += " Date Added";
    } else if (this.sortBy == "client_updated_at") {
      base += " Date Modified";
    } else if (this.sortBy == "title") {
      base += " Title";
    }

    if (this.showArchived) {
      base += " | + Archived";
    }
    if (this.hidePinned) {
      base += " | – Pinned";
    }
    if (this.sortReverse) {
      base += " | Reversed";
    }

    return base;
  };

  this.loadFlagsForNote = function (note) {
    var flags = [];

    if (note.pinned) {
      flags.push({
        text: "Pinned",
        class: "info"
      });
    }

    if (note.archived) {
      flags.push({
        text: "Archived",
        class: "warning"
      });
    }

    if (note.content.protected) {
      flags.push({
        text: "Protected",
        class: "success"
      });
    }

    if (note.locked) {
      flags.push({
        text: "Locked",
        class: "neutral"
      });
    }

    if (note.content.trashed) {
      flags.push({
        text: "Deleted",
        class: "danger"
      });
    }

    if (note.content.conflict_of) {
      flags.push({
        text: "Conflicted Copy",
        class: "danger"
      });
    }

    if (note.errorDecrypting) {
      flags.push({
        text: "Missing Keys",
        class: "danger"
      });
    }

    if (note.deleted) {
      flags.push({
        text: "Deletion Pending Sync",
        class: "danger"
      });
    }

    note.flags = flags;

    return flags;
  };

  this.tagDidChange = function (tag, oldTag) {
    var _this46 = this;

    var scrollable = document.getElementById("notes-scrollable");
    if (scrollable) {
      scrollable.scrollTop = 0;
      scrollable.scrollLeft = 0;
    }

    this.resetPagination();

    this.showMenu = false;

    if (this.selectedNote) {
      if (this.selectedNote.dummy && oldTag) {
        _.remove(oldTag.notes, this.selectedNote);
      }
    }

    this.noteFilter.text = "";
    desktopManager.searchText();

    this.setNotes(tag.notes);

    // perform in timeout since visibleNotes relies on renderedNotes which relies on render to complete
    $timeout(function () {
      if (_this46.notes.length > 0) {
        _this46.notes.forEach(function (note) {
          note.visible = true;
        });
        _this46.selectFirstNote();
      } else if (syncManager.initialDataLoaded()) {
        if (!tag.isSmartTag()) {
          _this46.createNewNote();
        } else {
          if (_this46.selectedNote && !_this46.notes.includes(_this46.selectedNote)) {
            _this46.selectNote(null);
          }
        }
      }
    });
  };

  this.visibleNotes = function () {
    return this.renderedNotes.filter(function (note) {
      return note.visible;
    });
  };

  this.selectFirstNote = function () {
    var visibleNotes = this.visibleNotes();
    if (visibleNotes.length > 0) {
      this.selectNote(visibleNotes[0]);
    }
  };

  this.selectNextNote = function () {
    var visibleNotes = this.visibleNotes();
    var currentIndex = visibleNotes.indexOf(this.selectedNote);
    if (currentIndex + 1 < visibleNotes.length) {
      this.selectNote(visibleNotes[currentIndex + 1]);
    }
  };

  this.selectPreviousNote = function () {
    var visibleNotes = this.visibleNotes();
    var currentIndex = visibleNotes.indexOf(this.selectedNote);
    if (currentIndex - 1 >= 0) {
      this.selectNote(visibleNotes[currentIndex - 1]);
      return true;
    } else {
      return false;
    }
  };

  this.selectNote = function () {
    var _ref11 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(note) {
      var _this47 = this;

      var viaClick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var run;
      return _regenerator2.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (note) {
                _context10.next = 3;
                break;
              }

              this.selectionMade()(null);
              return _context10.abrupt("return");

            case 3:
              run = function run() {
                $timeout(function () {
                  var dummyNote = void 0;
                  if (_this47.selectedNote && _this47.selectedNote != note && _this47.selectedNote.dummy) {
                    // remove dummy
                    dummyNote = _this47.selectedNote;
                  }

                  _this47.selectedNote = note;
                  if (note.content.conflict_of) {
                    note.content.conflict_of = null; // clear conflict
                    modelManager.setItemDirty(note, true);
                    syncManager.sync();
                  }
                  _this47.selectionMade()(note);
                  _this47.selectedIndex = Math.max(_this47.visibleNotes().indexOf(note), 0);

                  // There needs to be a long timeout after setting selection before removing the dummy
                  // Otherwise, you'll click a note, remove this one, and strangely, the click event registers for a lower cell
                  if (dummyNote) {
                    $timeout(function () {
                      modelManager.removeItemLocally(dummyNote);
                      _.pull(_this47.notes, dummyNote);
                    }, 250);
                  }

                  if (viaClick && _this47.isFiltering()) {
                    desktopManager.searchText(_this47.noteFilter.text);
                  }
                });
              };

              _context10.t0 = note.content.protected;

              if (!_context10.t0) {
                _context10.next = 9;
                break;
              }

              _context10.next = 8;
              return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionViewProtectedNotes);

            case 8:
              _context10.t0 = _context10.sent;

            case 9:
              if (!_context10.t0) {
                _context10.next = 13;
                break;
              }

              privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionViewProtectedNotes, function () {
                run();
              });
              _context10.next = 14;
              break;

            case 13:
              run();

            case 14:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    return function (_x11) {
      return _ref11.apply(this, arguments);
    };
  }();

  this.isFiltering = function () {
    return this.noteFilter.text && this.noteFilter.text.length > 0;
  };

  this.createNewNote = function () {
    // The "Note X" counter is based off this.notes.length, but sometimes, what you see in the list is only a subset.
    // We can use this.visibleNotes().length, but that only accounts for non-paginated results, so first 15 or so.
    var title = "Note" + (this.notes ? " " + (this.notes.length + 1) : "");
    var newNote = modelManager.createItem({ content_type: "Note", content: { text: "", title: title } });
    newNote.dummy = true;
    this.newNote = newNote;
    this.selectNote(this.newNote);
    this.addNew()(this.newNote);
  };

  this.noteFilter = { text: '' };

  this.onFilterEnter = function () {
    // For Desktop, performing a search right away causes input to lose focus.
    // We wait until user explicity hits enter before highlighting desktop search results.
    this.searchSubmitted = true;
    desktopManager.searchText(this.noteFilter.text);
  };

  this.clearFilterText = function () {
    this.noteFilter.text = '';
    this.onFilterEnter();
    this.filterTextChanged();

    // Reset loaded notes
    this.resetPagination();
  };

  this.filterTextChanged = function () {
    var _this48 = this;

    if (this.searchSubmitted) {
      this.searchSubmitted = false;
    }

    this.reloadNotes();

    $timeout(function () {
      if (!_this48.selectedNote.visible) {
        _this48.selectFirstNote();
      }
    }, 100);
  };

  this.selectedMenuItem = function () {
    this.showMenu = false;
  };

  this.togglePrefKey = function (key) {
    this[key] = !this[key];
    authManager.setUserPrefValue(key, this[key]);
    authManager.syncUserPreferences();
    this.reloadNotes();
  };

  this.selectedSortByCreated = function () {
    this.setSortBy("created_at");
  };

  this.selectedSortByUpdated = function () {
    this.setSortBy("client_updated_at");
  };

  this.selectedSortByTitle = function () {
    this.setSortBy("title");
  };

  this.toggleReverseSort = function () {
    this.selectedMenuItem();
    this.sortReverse = !this.sortReverse;
    this.reorderNotes();
    authManager.setUserPrefValue("sortReverse", this.sortReverse);
    authManager.syncUserPreferences();
  };

  this.setSortBy = function (type) {
    this.sortBy = type;
    this.reorderNotes();
    authManager.setUserPrefValue("sortBy", this.sortBy);
    authManager.syncUserPreferences();
  };

  this.shouldShowTagsForNote = function (note) {
    if (this.hideTags || note.content.protected) {
      return false;
    }

    if (this.tag.content.isAllTag) {
      return note.tags && note.tags.length > 0;
    }

    if (this.tag.isSmartTag()) {
      return true;
    }

    // Inside a tag, only show tags string if note contains tags other than this.tag
    return note.tags && note.tags.length > 1;
  };

  this.filterNotes = function (notes) {
    var _this49 = this;

    return notes.filter(function (note) {
      var canShowArchived = _this49.showArchived,
          canShowPinned = !_this49.hidePinned;
      var isTrash = _this49.tag.content.isTrashTag;

      if (!isTrash && note.content.trashed) {
        note.visible = false;
        return note.visible;
      }

      var isSmartTag = _this49.tag.isSmartTag();
      if (isSmartTag) {
        canShowArchived = canShowArchived || _this49.tag.content.isArchiveTag || isTrash;
      }

      if (note.archived && !canShowArchived || note.pinned && !canShowPinned) {
        note.visible = false;
        return note.visible;
      }

      var filterText = _this49.noteFilter.text.toLowerCase();
      if (filterText.length == 0) {
        note.visible = true;
      } else {
        var words = filterText.split(" ");
        var matchesTitle = words.every(function (word) {
          return note.safeTitle().toLowerCase().indexOf(word) >= 0;
        });
        var matchesBody = words.every(function (word) {
          return note.safeText().toLowerCase().indexOf(word) >= 0;
        });
        note.visible = matchesTitle || matchesBody;
      }

      return note.visible;
    });
  };

  this.sortNotes = function (items, sortBy, reverse) {
    var sortValueFn = function sortValueFn(a, b) {
      var pinCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (a.dummy) {
        return -1;
      }
      if (b.dummy) {
        return 1;
      }
      if (!pinCheck) {
        if (a.pinned && b.pinned) {
          return sortValueFn(a, b, true);
        }
        if (a.pinned) {
          return -1;
        }
        if (b.pinned) {
          return 1;
        }
      }

      var aValue = a[sortBy] || "";
      var bValue = b[sortBy] || "";

      var vector = 1;

      if (reverse) {
        vector *= -1;
      }

      if (sortBy == "title") {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();

        if (aValue.length == 0 && bValue.length == 0) {
          return 0;
        } else if (aValue.length == 0 && bValue.length != 0) {
          return 1 * vector;
        } else if (aValue.length != 0 && bValue.length == 0) {
          return -1 * vector;
        } else {
          vector *= -1;
        }
      }

      if (aValue > bValue) {
        return -1 * vector;
      } else if (aValue < bValue) {
        return 1 * vector;
      }
      return 0;
    };

    items = items || [];
    var result = items.sort(function (a, b) {
      return sortValueFn(a, b);
    });
    return result;
  };

  /*
    Keyboard Shortcuts
  */

  // In the browser we're not allowed to override cmd/ctrl + n, so we have to use Control modifier as well.
  // These rules don't apply to desktop, but probably better to be consistent.
  this.newNoteKeyObserver = keyboardManager.addKeyObserver({
    key: "n",
    modifiers: [KeyboardManager.KeyModifierMeta, KeyboardManager.KeyModifierCtrl],
    onKeyDown: function onKeyDown(event) {
      event.preventDefault();
      $timeout(function () {
        _this44.createNewNote();
      });
    }
  });

  this.getSearchBar = function () {
    return document.getElementById("search-bar");
  };

  this.nextNoteKeyObserver = keyboardManager.addKeyObserver({
    key: KeyboardManager.KeyDown,
    elements: [document.body, this.getSearchBar()],
    onKeyDown: function onKeyDown(event) {
      var searchBar = _this44.getSearchBar();
      if (searchBar == document.activeElement) {
        searchBar.blur();
      }
      $timeout(function () {
        _this44.selectNextNote();
      });
    }
  });

  this.nextNoteKeyObserver = keyboardManager.addKeyObserver({
    key: KeyboardManager.KeyUp,
    element: document.body,
    onKeyDown: function onKeyDown(event) {
      $timeout(function () {
        _this44.selectPreviousNote();
      });
    }
  });

  this.searchKeyObserver = keyboardManager.addKeyObserver({
    key: "f",
    modifiers: [KeyboardManager.KeyModifierMeta, KeyboardManager.KeyModifierShift],
    onKeyDown: function onKeyDown(event) {
      var searchBar = _this44.getSearchBar();
      if (searchBar) {
        searchBar.focus();
      };
    }
  });
});
;angular.module('app').directive("tagsSection", function () {
  return {
    restrict: 'E',
    scope: {
      addNew: "&",
      selectionMade: "&",
      save: "&",
      removeTag: "&"
    },
    templateUrl: 'tags.html',
    replace: true,
    controller: 'TagsCtrl',
    controllerAs: 'ctrl',
    bindToController: true
  };
}).controller('TagsCtrl', function ($rootScope, modelManager, syncManager, $timeout, componentManager, authManager) {
  var _this50 = this;

  // Wrap in timeout so that selectTag is defined
  $timeout(function () {
    _this50.smartTags = modelManager.getSmartTags();
    _this50.selectTag(_this50.smartTags[0]);
  });

  syncManager.addEventHandler(function (syncEvent, data) {
    if (syncEvent == "local-data-loaded" || syncEvent == "sync:completed" || syncEvent == "local-data-incremental-load") {
      _this50.tags = modelManager.tags;
      _this50.smartTags = modelManager.getSmartTags();
    }
  });

  modelManager.addItemSyncObserver("tags-list", "*", function (allItems, validItems, deletedItems, source, sourceKey) {
    _this50.reloadNoteCounts();
  });

  this.reloadNoteCounts = function () {
    var allTags = [];
    if (this.tags) {
      allTags = allTags.concat(this.tags);
    }
    if (this.smartTags) {
      allTags = allTags.concat(this.smartTags);
    }

    var _iteratorNormalCompletion49 = true;
    var _didIteratorError49 = false;
    var _iteratorError49 = undefined;

    try {
      for (var _iterator49 = allTags[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
        var tag = _step49.value;

        var validNotes = SNNote.filterDummyNotes(tag.notes).filter(function (note) {
          return !note.archived && !note.content.trashed;
        });

        tag.cachedNoteCount = validNotes.length;
      }
    } catch (err) {
      _didIteratorError49 = true;
      _iteratorError49 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion49 && _iterator49.return) {
          _iterator49.return();
        }
      } finally {
        if (_didIteratorError49) {
          throw _iteratorError49;
        }
      }
    }
  };

  this.panelController = {};

  $rootScope.$on("user-preferences-changed", function () {
    _this50.loadPreferences();
  });

  this.loadPreferences = function () {
    var width = authManager.getUserPrefValue("tagsPanelWidth");
    if (width) {
      this.panelController.setWidth(width);
      if (this.panelController.isCollapsed()) {
        $rootScope.$broadcast("panel-resized", { panel: "tags", collapsed: this.panelController.isCollapsed() });
      }
    }
  };

  this.loadPreferences();

  this.onPanelResize = function (newWidth, lastLeft, isAtMaxWidth, isCollapsed) {
    authManager.setUserPrefValue("tagsPanelWidth", newWidth, true);
    $rootScope.$broadcast("panel-resized", { panel: "tags", collapsed: isCollapsed });
  };

  this.componentManager = componentManager;

  componentManager.registerHandler({ identifier: "tags", areas: ["tags-list"], activationHandler: function (component) {
      this.component = component;
    }.bind(this), contextRequestHandler: function (component) {
      return null;
    }.bind(this), actionHandler: function (component, action, data) {
      if (action === "select-item") {
        if (data.item.content_type == "Tag") {
          var tag = modelManager.findItem(data.item.uuid);
          if (tag) {
            this.selectTag(tag);
          }
        } else if (data.item.content_type == "SN|SmartTag") {
          var smartTag = new SNSmartTag(data.item);
          this.selectTag(smartTag);
        }
      } else if (action === "clear-selection") {
        this.selectTag(this.smartTags[0]);
      }
    }.bind(this) });

  this.selectTag = function (tag) {
    if (tag.isSmartTag()) {
      Object.defineProperty(tag, "notes", {
        get: function get() {
          return modelManager.notesMatchingSmartTag(tag);
        }
      });
    }
    this.selectedTag = tag;
    if (tag.content.conflict_of) {
      tag.content.conflict_of = null;
      modelManager.setItemDirty(tag, true);
      syncManager.sync();
    }
    this.selectionMade()(tag);
  };

  this.clickedAddNewTag = function () {
    if (this.editingTag) {
      return;
    }

    this.newTag = modelManager.createItem({ content_type: "Tag" });
    this.selectedTag = this.newTag;
    this.editingTag = this.newTag;
    this.addNew()(this.newTag);
  };

  this.tagTitleDidChange = function (tag) {
    this.editingTag = tag;
  };

  this.saveTag = function ($event, tag) {
    var _this51 = this;

    this.editingTag = null;
    $event.target.blur();

    if (!tag.title || tag.title.length == 0) {
      if (originalTagName) {
        tag.title = originalTagName;
        originalTagName = null;
      } else {
        // newly created tag without content
        modelManager.removeItemLocally(tag);
      }
      return;
    }

    this.save()(tag, function (savedTag) {
      $timeout(function () {
        _this51.selectTag(tag);
        _this51.newTag = null;
      });
    });
  };

  function inputElementForTag(tag) {
    return document.getElementById("tag-" + tag.uuid);
  }

  var originalTagName = "";
  this.selectedRenameTag = function ($event, tag) {
    originalTagName = tag.title;
    this.editingTag = tag;
    $timeout(function () {
      inputElementForTag(tag).focus();
    });
  };

  this.selectedDeleteTag = function (tag) {
    this.removeTag()(tag);
    this.selectTag(this.smartTags[0]);
  };
});
;
var ActionsManager = function () {
  function ActionsManager(httpManager, modelManager, authManager, syncManager, $rootScope, $compile, $timeout) {
    (0, _classCallCheck4.default)(this, ActionsManager);

    this.httpManager = httpManager;
    this.modelManager = modelManager;
    this.authManager = authManager;
    this.syncManager = syncManager;
    this.$rootScope = $rootScope;
    this.$compile = $compile;
    this.$timeout = $timeout;

    // Used when decrypting old items with new keys. This array is only kept in memory.
    this.previousPasswords = [];
  }

  (0, _createClass4.default)(ActionsManager, [{
    key: "extensionsInContextOfItem",
    value: function extensionsInContextOfItem(item) {
      return this.extensions.filter(function (ext) {
        return _.includes(ext.supported_types, item.content_type) || ext.actionsWithContextForItem(item).length > 0;
      });
    }

    /*
    Loads an extension in the context of a certain item. The server then has the chance to respond with actions that are
    relevant just to this item. The response extension is not saved, just displayed as a one-time thing.
    */

  }, {
    key: "loadExtensionInContextOfItem",
    value: function loadExtensionInContextOfItem(extension, item, callback) {
      this.httpManager.getAbsolute(extension.url, { content_type: item.content_type, item_uuid: item.uuid }, function (response) {
        this.updateExtensionFromRemoteResponse(extension, response);
        callback && callback(extension);
      }.bind(this), function (response) {
        console.log("Error loading extension", response);
        if (callback) {
          callback(null);
        }
      }.bind(this));
    }
  }, {
    key: "updateExtensionFromRemoteResponse",
    value: function updateExtensionFromRemoteResponse(extension, response) {
      if (response.description) {
        extension.description = response.description;
      }
      if (response.supported_types) {
        extension.supported_types = response.supported_types;
      }

      if (response.actions) {
        extension.actions = response.actions.map(function (action) {
          return new Action(action);
        });
      } else {
        extension.actions = [];
      }
    }
  }, {
    key: "executeAction",
    value: function () {
      var _ref12 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14(action, extension, item, callback) {
        var _this52 = this;

        var customCallback, decrypted, triedPasswords, handleResponseDecryption, win;
        return _regenerator2.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                customCallback = function customCallback(response, error) {
                  action.running = false;
                  _this52.$timeout(function () {
                    callback(response, error);
                  });
                };

                action.running = true;

                decrypted = action.access_type == "decrypted";
                triedPasswords = [];

                handleResponseDecryption = function () {
                  var _ref13 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(response, keys, merge) {
                    var item, items, _iteratorNormalCompletion50, _didIteratorError50, _iteratorError50, _iterator50, _step50, mappedItem, _iteratorNormalCompletion51, _didIteratorError51, _iteratorError51, _iterator51, _step51, passwordCandidate, keyResults, success;

                    return _regenerator2.default.wrap(function _callee11$(_context11) {
                      while (1) {
                        switch (_context11.prev = _context11.next) {
                          case 0:
                            item = response.item;
                            _context11.next = 3;
                            return SFJS.itemTransformer.decryptItem(item, keys);

                          case 3:
                            if (item.errorDecrypting) {
                              _context11.next = 36;
                              break;
                            }

                            if (!merge) {
                              _context11.next = 31;
                              break;
                            }

                            _context11.next = 7;
                            return _this52.modelManager.mapResponseItemsToLocalModels([item], SFModelManager.MappingSourceRemoteActionRetrieved);

                          case 7:
                            items = _context11.sent;
                            _iteratorNormalCompletion50 = true;
                            _didIteratorError50 = false;
                            _iteratorError50 = undefined;
                            _context11.prev = 11;

                            for (_iterator50 = items[Symbol.iterator](); !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
                              mappedItem = _step50.value;

                              _this52.modelManager.setItemDirty(mappedItem, true);
                            }
                            _context11.next = 19;
                            break;

                          case 15:
                            _context11.prev = 15;
                            _context11.t0 = _context11["catch"](11);
                            _didIteratorError50 = true;
                            _iteratorError50 = _context11.t0;

                          case 19:
                            _context11.prev = 19;
                            _context11.prev = 20;

                            if (!_iteratorNormalCompletion50 && _iterator50.return) {
                              _iterator50.return();
                            }

                          case 22:
                            _context11.prev = 22;

                            if (!_didIteratorError50) {
                              _context11.next = 25;
                              break;
                            }

                            throw _iteratorError50;

                          case 25:
                            return _context11.finish(22);

                          case 26:
                            return _context11.finish(19);

                          case 27:
                            _this52.syncManager.sync();
                            customCallback({ item: item });
                            _context11.next = 33;
                            break;

                          case 31:
                            item = _this52.modelManager.createItem(item);
                            customCallback({ item: item });

                          case 33:
                            return _context11.abrupt("return", true);

                          case 36:
                            if (response.auth_params) {
                              _context11.next = 39;
                              break;
                            }

                            // In some cases revisions were missing auth params. Instruct the user to email us to get this remedied.
                            alert("We were unable to decrypt this revision using your current keys, and this revision is missing metadata that would allow us to try different keys to decrypt it. This can likely be fixed with some manual intervention. Please email hello@standardnotes.org for assistance.");
                            return _context11.abrupt("return");

                          case 39:

                            // Try previous passwords
                            _iteratorNormalCompletion51 = true;
                            _didIteratorError51 = false;
                            _iteratorError51 = undefined;
                            _context11.prev = 42;
                            _iterator51 = _this52.previousPasswords[Symbol.iterator]();

                          case 44:
                            if (_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done) {
                              _context11.next = 62;
                              break;
                            }

                            passwordCandidate = _step51.value;

                            if (!triedPasswords.includes(passwordCandidate)) {
                              _context11.next = 48;
                              break;
                            }

                            return _context11.abrupt("continue", 59);

                          case 48:
                            triedPasswords.push(passwordCandidate);

                            _context11.next = 51;
                            return SFJS.crypto.computeEncryptionKeysForUser(passwordCandidate, response.auth_params);

                          case 51:
                            keyResults = _context11.sent;

                            if (keyResults) {
                              _context11.next = 54;
                              break;
                            }

                            return _context11.abrupt("continue", 59);

                          case 54:
                            _context11.next = 56;
                            return handleResponseDecryption(response, keyResults, merge);

                          case 56:
                            success = _context11.sent;

                            if (!success) {
                              _context11.next = 59;
                              break;
                            }

                            return _context11.abrupt("return", true);

                          case 59:
                            _iteratorNormalCompletion51 = true;
                            _context11.next = 44;
                            break;

                          case 62:
                            _context11.next = 68;
                            break;

                          case 64:
                            _context11.prev = 64;
                            _context11.t1 = _context11["catch"](42);
                            _didIteratorError51 = true;
                            _iteratorError51 = _context11.t1;

                          case 68:
                            _context11.prev = 68;
                            _context11.prev = 69;

                            if (!_iteratorNormalCompletion51 && _iterator51.return) {
                              _iterator51.return();
                            }

                          case 71:
                            _context11.prev = 71;

                            if (!_didIteratorError51) {
                              _context11.next = 74;
                              break;
                            }

                            throw _iteratorError51;

                          case 74:
                            return _context11.finish(71);

                          case 75:
                            return _context11.finish(68);

                          case 76:

                            _this52.presentPasswordModal(function (password) {
                              _this52.previousPasswords.push(password);
                              handleResponseDecryption(response, keys, merge);
                            });

                            return _context11.abrupt("return", false);

                          case 78:
                          case "end":
                            return _context11.stop();
                        }
                      }
                    }, _callee11, _this52, [[11, 15, 19, 27], [20,, 22, 26], [42, 64, 68, 76], [69,, 71, 75]]);
                  }));

                  return function handleResponseDecryption(_x17, _x18, _x19) {
                    return _ref13.apply(this, arguments);
                  };
                }();

                _context14.t0 = action.verb;
                _context14.next = _context14.t0 === "get" ? 8 : _context14.t0 === "render" ? 10 : _context14.t0 === "show" ? 12 : _context14.t0 === "post" ? 16 : 18;
                break;

              case 8:
                if (confirm("Are you sure you want to replace the current note contents with this action's results?")) {
                  this.httpManager.getAbsolute(action.url, {}, function () {
                    var _ref14 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(response) {
                      return _regenerator2.default.wrap(function _callee12$(_context12) {
                        while (1) {
                          switch (_context12.prev = _context12.next) {
                            case 0:
                              action.error = false;
                              _context12.t0 = handleResponseDecryption;
                              _context12.t1 = response;
                              _context12.next = 5;
                              return _this52.authManager.keys();

                            case 5:
                              _context12.t2 = _context12.sent;
                              (0, _context12.t0)(_context12.t1, _context12.t2, true);

                            case 7:
                            case "end":
                              return _context12.stop();
                          }
                        }
                      }, _callee12, _this52);
                    }));

                    return function (_x20) {
                      return _ref14.apply(this, arguments);
                    };
                  }(), function (response) {
                    var error = response && response.error || { message: "An issue occurred while processing this action. Please try again." };
                    alert(error.message);
                    action.error = true;
                    customCallback(null, error);
                  });
                }
                return _context14.abrupt("break", 18);

              case 10:
                this.httpManager.getAbsolute(action.url, {}, function () {
                  var _ref15 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(response) {
                    return _regenerator2.default.wrap(function _callee13$(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            action.error = false;
                            _context13.t0 = handleResponseDecryption;
                            _context13.t1 = response;
                            _context13.next = 5;
                            return _this52.authManager.keys();

                          case 5:
                            _context13.t2 = _context13.sent;
                            (0, _context13.t0)(_context13.t1, _context13.t2, false);

                          case 7:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee13, _this52);
                  }));

                  return function (_x21) {
                    return _ref15.apply(this, arguments);
                  };
                }(), function (response) {
                  var error = response && response.error || { message: "An issue occurred while processing this action. Please try again." };
                  alert(error.message);
                  action.error = true;
                  customCallback(null, error);
                });

                return _context14.abrupt("break", 18);

              case 12:
                win = window.open(action.url, '_blank');

                if (win) {
                  win.focus();
                }
                customCallback();
                return _context14.abrupt("break", 18);

              case 16:
                this.outgoingParamsForItem(item, extension, decrypted).then(function (itemParams) {
                  var params = {
                    items: [itemParams] // Wrap it in an array
                  };

                  _this52.performPost(action, extension, params, function (response) {
                    if (response && response.error) {
                      alert("An issue occurred while processing this action. Please try again.");
                    }
                    customCallback(response);
                  });
                });

                return _context14.abrupt("break", 18);

              case 18:

                action.lastExecuted = new Date();

              case 19:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function executeAction(_x13, _x14, _x15, _x16) {
        return _ref12.apply(this, arguments);
      }

      return executeAction;
    }()
  }, {
    key: "outgoingParamsForItem",
    value: function () {
      var _ref16 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(item, extension) {
        var decrypted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var keys, itemParams;
        return _regenerator2.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.authManager.keys();

              case 2:
                keys = _context15.sent;

                if (decrypted) {
                  keys = null;
                }
                _context15.t0 = SFItemParams;
                _context15.t1 = item;
                _context15.t2 = keys;
                _context15.next = 9;
                return this.authManager.getAuthParams();

              case 9:
                _context15.t3 = _context15.sent;
                itemParams = new _context15.t0(_context15.t1, _context15.t2, _context15.t3);
                return _context15.abrupt("return", itemParams.paramsForExtension());

              case 12:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function outgoingParamsForItem(_x23, _x24) {
        return _ref16.apply(this, arguments);
      }

      return outgoingParamsForItem;
    }()
  }, {
    key: "performPost",
    value: function performPost(action, extension, params, callback) {
      this.httpManager.postAbsolute(action.url, params, function (response) {
        action.error = false;
        if (callback) {
          callback(response);
        }
      }.bind(this), function (response) {
        action.error = true;
        console.log("Action error response:", response);
        if (callback) {
          callback({ error: "Request error" });
        }
      });
    }
  }, {
    key: "presentRevisionPreviewModal",
    value: function presentRevisionPreviewModal(uuid, content) {
      var scope = this.$rootScope.$new(true);
      scope.uuid = uuid;
      scope.content = content;
      var el = this.$compile("<revision-preview-modal uuid='uuid' content='content' class='sk-modal'></revision-preview-modal>")(scope);
      angular.element(document.body).append(el);
    }
  }, {
    key: "presentPasswordModal",
    value: function presentPasswordModal(callback) {
      var scope = this.$rootScope.$new(true);
      scope.type = "password";
      scope.title = "Decryption Assistance";
      scope.message = "Unable to decrypt this item with your current keys. Please enter your account password at the time of this revision.";
      scope.callback = callback;
      var el = this.$compile("<input-modal type='type' message='message' title='title' callback='callback'></input-modal>")(scope);
      angular.element(document.body).append(el);
    }
  }, {
    key: "extensions",
    get: function get() {
      return this.modelManager.validItemsForContentType("Extension");
    }
  }]);
  return ActionsManager;
}();

angular.module('app').service('actionsManager', ActionsManager);
;
var ArchiveManager = function () {
  function ArchiveManager(passcodeManager, authManager, modelManager, privilegesManager) {
    (0, _classCallCheck4.default)(this, ArchiveManager);

    this.passcodeManager = passcodeManager;
    this.authManager = authManager;
    this.modelManager = modelManager;
    this.privilegesManager = privilegesManager;
  }

  /*
  Public
  */

  (0, _createClass4.default)(ArchiveManager, [{
    key: "downloadBackup",
    value: function () {
      var _ref17 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16(encrypted) {
        return _regenerator2.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", this.downloadBackupOfItems(this.modelManager.allItems, encrypted));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function downloadBackup(_x25) {
        return _ref17.apply(this, arguments);
      }

      return downloadBackup;
    }()
  }, {
    key: "downloadBackupOfItems",
    value: function () {
      var _ref18 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18(items, encrypted) {
        var _this53 = this;

        var run;
        return _regenerator2.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                run = function () {
                  var _ref19 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17() {
                    var keys, authParams;
                    return _regenerator2.default.wrap(function _callee17$(_context17) {
                      while (1) {
                        switch (_context17.prev = _context17.next) {
                          case 0:
                            if (!encrypted) {
                              _context17.next = 12;
                              break;
                            }

                            if (!(_this53.authManager.offline() && _this53.passcodeManager.hasPasscode())) {
                              _context17.next = 6;
                              break;
                            }

                            keys = _this53.passcodeManager.keys();
                            authParams = _this53.passcodeManager.passcodeAuthParams();
                            _context17.next = 12;
                            break;

                          case 6:
                            _context17.next = 8;
                            return _this53.authManager.keys();

                          case 8:
                            keys = _context17.sent;
                            _context17.next = 11;
                            return _this53.authManager.getAuthParams();

                          case 11:
                            authParams = _context17.sent;

                          case 12:
                            _this53.__itemsData(items, keys, authParams).then(function (data) {
                              var modifier = encrypted ? "Encrypted" : "Decrypted";
                              _this53.__downloadData(data, "Standard Notes " + modifier + " Backup - " + _this53.__formattedDate() + ".txt");

                              // download as zipped plain text files
                              if (!keys) {
                                _this53.__downloadZippedItems(items);
                              }
                            });

                          case 13:
                          case "end":
                            return _context17.stop();
                        }
                      }
                    }, _callee17, _this53);
                  }));

                  return function run() {
                    return _ref19.apply(this, arguments);
                  };
                }();

                _context18.next = 3;
                return this.privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManageBackups);

              case 3:
                if (!_context18.sent) {
                  _context18.next = 7;
                  break;
                }

                this.privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManageBackups, function () {
                  run();
                });
                _context18.next = 8;
                break;

              case 7:
                run();

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function downloadBackupOfItems(_x26, _x27) {
        return _ref18.apply(this, arguments);
      }

      return downloadBackupOfItems;
    }()

    /*
    Private
    */

  }, {
    key: "__formattedDate",
    value: function __formattedDate() {
      var string = "" + new Date();
      // Match up to the first parenthesis, i.e do not include '(Central Standard Time)'
      var matches = string.match(/^(.*?) \(/);
      if (matches.length >= 2) {
        return matches[1];
      }
      return string;
    }
  }, {
    key: "__itemsData",
    value: function () {
      var _ref20 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee19(items, keys, authParams) {
        var data, blobData;
        return _regenerator2.default.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.modelManager.getJSONDataForItems(items, keys, authParams);

              case 2:
                data = _context19.sent;
                blobData = new Blob([data], { type: 'text/json' });
                return _context19.abrupt("return", blobData);

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function __itemsData(_x28, _x29, _x30) {
        return _ref20.apply(this, arguments);
      }

      return __itemsData;
    }()
  }, {
    key: "__loadZip",
    value: function __loadZip(callback) {
      if (window.zip) {
        callback();
        return;
      }

      var scriptTag = document.createElement('script');
      scriptTag.src = "/assets/zip/zip.js";
      scriptTag.async = false;
      var headTag = document.getElementsByTagName('head')[0];
      headTag.appendChild(scriptTag);
      scriptTag.onload = function () {
        zip.workerScriptsPath = "assets/zip/";
        callback();
      };
    }
  }, {
    key: "__downloadZippedItems",
    value: function __downloadZippedItems(items) {
      var _this54 = this;

      this.__loadZip(function () {
        zip.createWriter(new zip.BlobWriter("application/zip"), function (zipWriter) {
          var index = 0;

          var nextFile = function nextFile() {
            var item = items[index];
            var name, contents;

            if (item.content_type == "Note") {
              name = item.content.title;
              contents = item.content.text;
            } else {
              name = item.content_type;
              contents = JSON.stringify(item.content, null, 2);
            }

            if (!name) {
              name = "";
            }

            var blob = new Blob([contents], { type: 'text/plain' });

            var filePrefix = name.replace(/\//g, "").replace(/\\+/g, "");
            var fileSuffix = "-" + item.uuid.split("-")[0] + ".txt";

            // Standard max filename length is 255. Slice the note name down to allow filenameEnd
            filePrefix = filePrefix.slice(0, 255 - fileSuffix.length);

            var fileName = item.content_type + "/" + filePrefix + fileSuffix;

            zipWriter.add(fileName, new zip.BlobReader(blob), function () {
              index++;
              if (index < items.length) {
                nextFile();
              } else {
                zipWriter.close(function (blob) {
                  _this54.__downloadData(blob, "Standard Notes Backup - " + _this54.__formattedDate() + ".zip");
                  zipWriter = null;
                });
              }
            });
          };

          nextFile();
        }, onerror);
      });
    }
  }, {
    key: "__hrefForData",
    value: function __hrefForData(data) {
      // If we are replacing a previously generated file we need to
      // manually revoke the object URL to avoid memory leaks.
      if (this.textFile !== null) {
        window.URL.revokeObjectURL(this.textFile);
      }

      this.textFile = window.URL.createObjectURL(data);

      // returns a URL you can use as a href
      return this.textFile;
    }
  }, {
    key: "__downloadData",
    value: function __downloadData(data, fileName) {
      var link = document.createElement('a');
      link.setAttribute('download', fileName);
      link.href = this.__hrefForData(data);
      document.body.appendChild(link);
      link.click();
      link.remove();
    }
  }]);
  return ArchiveManager;
}();

angular.module('app').service('archiveManager', ArchiveManager);
;
var AuthManager = function (_SFAuthManager) {
  (0, _inherits4.default)(AuthManager, _SFAuthManager);

  function AuthManager(modelManager, singletonManager, storageManager, dbManager, httpManager, $rootScope, $timeout, $compile) {
    (0, _classCallCheck4.default)(this, AuthManager);

    var _this55 = (0, _possibleConstructorReturn4.default)(this, (AuthManager.__proto__ || Object.getPrototypeOf(AuthManager)).call(this, storageManager, httpManager, null, $timeout));

    _this55.$rootScope = $rootScope;
    _this55.$compile = $compile;
    _this55.modelManager = modelManager;
    _this55.singletonManager = singletonManager;
    _this55.storageManager = storageManager;
    _this55.dbManager = dbManager;
    return _this55;
  }

  (0, _createClass4.default)(AuthManager, [{
    key: "loadInitialData",
    value: function loadInitialData() {
      var _this56 = this;

      var userData = this.storageManager.getItemSync("user");
      if (userData) {
        this.user = JSON.parse(userData);
      } else {
        // legacy, check for uuid
        var idData = this.storageManager.getItemSync("uuid");
        if (idData) {
          this.user = { uuid: idData };
        }
      }

      this.configureUserPrefs();
      this.checkForSecurityUpdate();

      this.modelManager.addItemSyncObserver("user-prefs", "SN|UserPreferences", function (allItems, validItems, deletedItems, source, sourceKey) {
        _this56.userPreferencesDidChange();
      });
    }
  }, {
    key: "offline",
    value: function offline() {
      return !this.user;
    }
  }, {
    key: "isEphemeralSession",
    value: function isEphemeralSession() {
      if (this.ephemeral == null || this.ephemeral == undefined) {
        this.ephemeral = JSON.parse(this.storageManager.getItemSync("ephemeral", StorageManager.Fixed));
      }
      return this.ephemeral;
    }
  }, {
    key: "setEphemeral",
    value: function setEphemeral(ephemeral) {
      this.ephemeral = ephemeral;
      if (ephemeral) {
        this.storageManager.setModelStorageMode(StorageManager.Ephemeral);
        this.storageManager.setItemsMode(StorageManager.Ephemeral);
      } else {
        this.storageManager.setModelStorageMode(StorageManager.Fixed);
        this.storageManager.setItemsMode(this.storageManager.bestStorageMode());
        this.storageManager.setItem("ephemeral", JSON.stringify(false), StorageManager.Fixed);
      }
    }
  }, {
    key: "getAuthParamsForEmail",
    value: function () {
      var _ref21 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee20(url, email, extraParams) {
        return _regenerator2.default.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", (0, _get4.default)(AuthManager.prototype.__proto__ || Object.getPrototypeOf(AuthManager.prototype), "getAuthParamsForEmail", this).call(this, url, email, extraParams));

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getAuthParamsForEmail(_x31, _x32, _x33) {
        return _ref21.apply(this, arguments);
      }

      return getAuthParamsForEmail;
    }()
  }, {
    key: "login",
    value: function () {
      var _ref22 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee21(url, email, password, ephemeral, strictSignin, extraParams) {
        var _this57 = this;

        return _regenerator2.default.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                return _context21.abrupt("return", (0, _get4.default)(AuthManager.prototype.__proto__ || Object.getPrototypeOf(AuthManager.prototype), "login", this).call(this, url, email, password, strictSignin, extraParams).then(function (response) {
                  if (!response.error) {
                    _this57.setEphemeral(ephemeral);
                    _this57.checkForSecurityUpdate();
                  }

                  return response;
                }));

              case 1:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function login(_x34, _x35, _x36, _x37, _x38, _x39) {
        return _ref22.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "register",
    value: function () {
      var _ref23 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee22(url, email, password, ephemeral) {
        var _this58 = this;

        return _regenerator2.default.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                return _context22.abrupt("return", (0, _get4.default)(AuthManager.prototype.__proto__ || Object.getPrototypeOf(AuthManager.prototype), "register", this).call(this, url, email, password).then(function (response) {
                  if (!response.error) {
                    _this58.setEphemeral(ephemeral);
                  }
                  return response;
                }));

              case 1:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function register(_x40, _x41, _x42, _x43) {
        return _ref23.apply(this, arguments);
      }

      return register;
    }()
  }, {
    key: "changePassword",
    value: function () {
      var _ref24 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee23(url, email, current_server_pw, newKeys, newAuthParams) {
        var _this59 = this;

        return _regenerator2.default.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                return _context23.abrupt("return", (0, _get4.default)(AuthManager.prototype.__proto__ || Object.getPrototypeOf(AuthManager.prototype), "changePassword", this).call(this, url, email, current_server_pw, newKeys, newAuthParams).then(function (response) {
                  if (!response.error) {
                    _this59.checkForSecurityUpdate();
                  }
                  return response;
                }));

              case 1:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function changePassword(_x44, _x45, _x46, _x47, _x48) {
        return _ref24.apply(this, arguments);
      }

      return changePassword;
    }()
  }, {
    key: "handleAuthResponse",
    value: function () {
      var _ref25 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee24(response, email, url, authParams, keys) {
        return _regenerator2.default.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.prev = 0;
                _context24.next = 3;
                return (0, _get4.default)(AuthManager.prototype.__proto__ || Object.getPrototypeOf(AuthManager.prototype), "handleAuthResponse", this).call(this, response, email, url, authParams, keys);

              case 3:
                this.user = response.user;
                this.storageManager.setItem("user", JSON.stringify(response.user));
                _context24.next = 10;
                break;

              case 7:
                _context24.prev = 7;
                _context24.t0 = _context24["catch"](0);

                this.dbManager.displayOfflineAlert();

              case 10:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this, [[0, 7]]);
      }));

      function handleAuthResponse(_x49, _x50, _x51, _x52, _x53) {
        return _ref25.apply(this, arguments);
      }

      return handleAuthResponse;
    }()
  }, {
    key: "verifyAccountPassword",
    value: function () {
      var _ref26 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee25(password) {
        var authParams, keys, success;
        return _regenerator2.default.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.getAuthParams();

              case 2:
                authParams = _context25.sent;
                _context25.next = 5;
                return SFJS.crypto.computeEncryptionKeysForUser(password, authParams);

              case 5:
                keys = _context25.sent;
                _context25.t0 = keys.mk;
                _context25.next = 9;
                return this.keys();

              case 9:
                _context25.t1 = _context25.sent.mk;
                success = _context25.t0 === _context25.t1;
                return _context25.abrupt("return", success);

              case 12:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function verifyAccountPassword(_x54) {
        return _ref26.apply(this, arguments);
      }

      return verifyAccountPassword;
    }()
  }, {
    key: "checkForSecurityUpdate",
    value: function () {
      var _ref27 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee26() {
        var latest, updateAvailable;
        return _regenerator2.default.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                if (!this.offline()) {
                  _context26.next = 2;
                  break;
                }

                return _context26.abrupt("return", false);

              case 2:
                latest = SFJS.version();
                _context26.next = 5;
                return this.protocolVersion();

              case 5:
                _context26.t0 = _context26.sent;
                _context26.t1 = latest;
                updateAvailable = _context26.t0 !== _context26.t1;

                if (updateAvailable !== this.securityUpdateAvailable) {
                  this.securityUpdateAvailable = updateAvailable;
                  this.$rootScope.$broadcast("security-update-status-changed");
                }

                return _context26.abrupt("return", this.securityUpdateAvailable);

              case 10:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function checkForSecurityUpdate() {
        return _ref27.apply(this, arguments);
      }

      return checkForSecurityUpdate;
    }()
  }, {
    key: "presentPasswordWizard",
    value: function presentPasswordWizard(type) {
      var scope = this.$rootScope.$new(true);
      scope.type = type;
      var el = this.$compile("<password-wizard type='type'></password-wizard>")(scope);
      angular.element(document.body).append(el);
    }
  }, {
    key: "signOut",
    value: function signOut() {
      (0, _get4.default)(AuthManager.prototype.__proto__ || Object.getPrototypeOf(AuthManager.prototype), "signout", this).call(this);
      this.user = null;
      this._authParams = null;
    }

    /* User Preferences */

  }, {
    key: "configureUserPrefs",
    value: function configureUserPrefs() {
      var _this60 = this;

      var prefsContentType = "SN|UserPreferences";

      var contentTypePredicate = new SFPredicate("content_type", "=", prefsContentType);
      this.singletonManager.registerSingleton([contentTypePredicate], function (resolvedSingleton) {
        _this60.userPreferences = resolvedSingleton;
      }, function (valueCallback) {
        // Safe to create. Create and return object.
        var prefs = new SFItem({ content_type: prefsContentType });
        _this60.modelManager.addItem(prefs);
        _this60.modelManager.setItemDirty(prefs, true);
        _this60.$rootScope.sync();
        valueCallback(prefs);
      });
    }
  }, {
    key: "userPreferencesDidChange",
    value: function userPreferencesDidChange() {
      this.$rootScope.$broadcast("user-preferences-changed");
    }
  }, {
    key: "syncUserPreferences",
    value: function syncUserPreferences() {
      if (this.userPreferences) {
        this.modelManager.setItemDirty(this.userPreferences, true);
        this.$rootScope.sync();
      }
    }
  }, {
    key: "getUserPrefValue",
    value: function getUserPrefValue(key, defaultValue) {
      if (!this.userPreferences) {
        return defaultValue;
      }
      var value = this.userPreferences.getAppDataItem(key);
      return value !== undefined && value != null ? value : defaultValue;
    }
  }, {
    key: "setUserPrefValue",
    value: function setUserPrefValue(key, value, sync) {
      if (!this.userPreferences) {
        console.log("Prefs are null, not setting value", key);return;
      }
      this.userPreferences.setAppDataItem(key, value);
      if (sync) {
        this.syncUserPreferences();
      }
    }
  }]);
  return AuthManager;
}(SFAuthManager);

angular.module('app').service('authManager', AuthManager);
;
var ComponentManager = function (_SNComponentManager) {
  (0, _inherits4.default)(ComponentManager, _SNComponentManager);

  function ComponentManager(modelManager, syncManager, desktopManager, nativeExtManager, $rootScope, $timeout, $compile) {
    (0, _classCallCheck4.default)(this, ComponentManager);

    // this.loggingEnabled = true;

    var _this61 = (0, _possibleConstructorReturn4.default)(this, (ComponentManager.__proto__ || Object.getPrototypeOf(ComponentManager)).call(this, {
      modelManager: modelManager,
      syncManager: syncManager,
      desktopManager: desktopManager,
      nativeExtManager: nativeExtManager,
      alertManager: new SFAlertManager(),
      $uiRunner: $rootScope.safeApply,
      $timeout: $timeout,
      environment: isDesktopApplication() ? "desktop" : "web",
      platform: getPlatformString()
    }));

    _this61.$compile = $compile;
    _this61.$rootScope = $rootScope;
    return _this61;
  }

  (0, _createClass4.default)(ComponentManager, [{
    key: "openModalComponent",
    value: function openModalComponent(component) {
      var scope = this.$rootScope.$new(true);
      scope.component = component;
      var el = this.$compile("<component-modal component='component' class='sk-modal'></component-modal>")(scope);
      angular.element(document.body).append(el);
    }
  }, {
    key: "presentPermissionsDialog",
    value: function presentPermissionsDialog(dialog) {
      var scope = this.$rootScope.$new(true);
      scope.permissionsString = dialog.permissionsString;
      scope.component = dialog.component;
      scope.callback = dialog.callback;

      var el = this.$compile("<permissions-modal component='component' permissions-string='permissionsString' callback='callback' class='sk-modal'></permissions-modal>")(scope);
      angular.element(document.body).append(el);
    }
  }]);
  return ComponentManager;
}(SNComponentManager);

angular.module('app').service('componentManager', ComponentManager);
;
var DBManager = function () {
  function DBManager() {
    (0, _classCallCheck4.default)(this, DBManager);

    this.locked = true;
  }

  (0, _createClass4.default)(DBManager, [{
    key: "displayOfflineAlert",
    value: function displayOfflineAlert() {
      var message = "There was an issue loading your offline database. This could happen for two reasons:";
      message += "\n\n1. You're in a private window in your browser. We can't save your data without access to the local database. Please use a non-private window.";
      message += "\n\n2. You have two windows of the app open at the same time. Please close any other app instances and reload the page.";
      alert(message);
    }
  }, {
    key: "setLocked",
    value: function setLocked(locked) {
      this.locked = locked;
    }
  }, {
    key: "openDatabase",
    value: function openDatabase(callback, onUgradeNeeded) {
      if (this.locked) {
        return;
      }

      var request = window.indexedDB.open("standardnotes", 1);

      request.onerror = function (event) {
        if (event.target.errorCode) {
          alert("Offline database issue: " + event.target.errorCode);
        } else {
          this.displayOfflineAlert();
        }
        console.error("Offline database issue:", event);
        if (callback) {
          callback(null);
        }
      }.bind(this);

      request.onsuccess = function (event) {
        var db = event.target.result;
        db.onversionchange = function (event) {
          db.close();
        };
        db.onerror = function (errorEvent) {
          console.log("Database error: " + errorEvent.target.errorCode);
        };
        if (callback) {
          callback(db);
        }
      };

      request.onblocked = function (event) {
        console.error("Request blocked error:", event.target.errorCode);
      };

      request.onupgradeneeded = function (event) {
        var db = event.target.result;

        db.onversionchange = function (event) {
          db.close();
        };

        // Create an objectStore for this database
        var objectStore = db.createObjectStore("items", { keyPath: "uuid" });
        objectStore.createIndex("title", "title", { unique: false });
        objectStore.createIndex("uuid", "uuid", { unique: true });
        objectStore.transaction.oncomplete = function (event) {
          // Ready to store values in the newly created objectStore.
          if (db.version === 1) {
            if (onUgradeNeeded) {
              onUgradeNeeded();
            }
          }
        };
      };
    }
  }, {
    key: "getAllModels",
    value: function getAllModels(callback) {
      this.openDatabase(function (db) {
        var objectStore = db.transaction("items").objectStore("items");
        var items = [];
        objectStore.openCursor().onsuccess = function (event) {
          var cursor = event.target.result;
          if (cursor) {
            items.push(cursor.value);
            cursor.continue();
          } else {
            callback(items);
          }
        };
      }, null);
    }
  }, {
    key: "saveModel",
    value: function saveModel(item) {
      this.saveModels([item]);
    }
  }, {
    key: "saveModels",
    value: function saveModels(items, onsuccess, onerror) {

      if (items.length == 0) {
        if (onsuccess) {
          onsuccess();
        }
        return;
      }

      this.openDatabase(function (db) {
        var transaction = db.transaction("items", "readwrite");
        transaction.oncomplete = function (event) {};

        transaction.onerror = function (event) {
          console.error("Transaction error:", event.target.errorCode);
        };

        transaction.onblocked = function (event) {
          console.error("Transaction blocked error:", event.target.errorCode);
        };

        transaction.onabort = function (event) {
          console.log("Offline saving aborted:", event);
          var error = event.target.error;
          if (error.name == "QuotaExceededError") {
            alert("Unable to save changes locally because your device is out of space. Please free up some disk space and try again, otherwise, your data may end up in an inconsistent state.");
          } else {
            alert("Unable to save changes locally due to an unknown system issue. Issue Code: " + error.code + " Issue Name: " + error.name + ".");
          }
          onerror && onerror(error);
        };

        var itemObjectStore = transaction.objectStore("items");
        var i = 0;
        putNext();

        function putNext() {
          if (i < items.length) {
            var item = items[i];
            var request = itemObjectStore.put(item);
            request.onerror = function (event) {
              console.error("DB put error:", event.target.error);
            };
            request.onsuccess = putNext;
            ++i;
          } else {
            onsuccess && onsuccess();
          }
        }
      }, null);
    }
  }, {
    key: "deleteModel",
    value: function deleteModel(item, callback) {
      this.openDatabase(function (db) {
        var request = db.transaction("items", "readwrite").objectStore("items").delete(item.uuid);
        request.onsuccess = function (event) {
          if (callback) {
            callback(true);
          }
        };
      }, null);
    }
  }, {
    key: "clearAllModels",
    value: function clearAllModels(callback) {
      var deleteRequest = window.indexedDB.deleteDatabase("standardnotes");

      deleteRequest.onerror = function (event) {
        console.log("Error deleting database.");
        callback && callback();
      };

      deleteRequest.onsuccess = function (event) {
        console.log("Database deleted successfully");
        callback && callback();
      };

      deleteRequest.onblocked = function (event) {
        console.error("Delete request blocked");
        alert("Your browser is blocking Standard Notes from deleting the local database. Make sure there are no other open windows of this app and try again. If the issue persists, please manually delete app data to sign out.");
      };
    }
  }]);
  return DBManager;
}();

angular.module('app').service('dbManager', DBManager);
; // An interface used by the Desktop app to interact with SN

var DesktopManager = function () {
  function DesktopManager($rootScope, $timeout, modelManager, syncManager, authManager, passcodeManager) {
    var _this62 = this;

    (0, _classCallCheck4.default)(this, DesktopManager);

    this.passcodeManager = passcodeManager;
    this.modelManager = modelManager;
    this.authManager = authManager;
    this.syncManager = syncManager;
    this.$rootScope = $rootScope;
    this.timeout = $timeout;
    this.updateObservers = [];
    this.componentActivationObservers = [];

    this.isDesktop = isDesktopApplication();

    $rootScope.$on("initial-data-loaded", function () {
      _this62.dataLoaded = true;
      if (_this62.dataLoadHandler) {
        _this62.dataLoadHandler();
      }
    });

    $rootScope.$on("major-data-change", function () {
      if (_this62.majorDataChangeHandler) {
        _this62.majorDataChangeHandler();
      }
    });
  }

  (0, _createClass4.default)(DesktopManager, [{
    key: "saveBackup",
    value: function saveBackup() {
      this.majorDataChangeHandler && this.majorDataChangeHandler();
    }
  }, {
    key: "getApplicationDataPath",
    value: function getApplicationDataPath() {
      console.assert(this.applicationDataPath, "applicationDataPath is null");
      return this.applicationDataPath;
    }

    /*
      Sending a component in its raw state is really slow for the desktop app
      Keys are not passed into ItemParams, so the result is not encrypted
     */

  }, {
    key: "convertComponentForTransmission",
    value: function () {
      var _ref28 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee27(component) {
        return _regenerator2.default.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                return _context27.abrupt("return", new SFItemParams(component).paramsForExportFile(true));

              case 1:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function convertComponentForTransmission(_x55) {
        return _ref28.apply(this, arguments);
      }

      return convertComponentForTransmission;
    }()

    // All `components` should be installed

  }, {
    key: "syncComponentsInstallation",
    value: function syncComponentsInstallation(components) {
      var _this63 = this;

      if (!this.isDesktop) return;

      Promise.all(components.map(function (component) {
        return _this63.convertComponentForTransmission(component);
      })).then(function (data) {
        _this63.installationSyncHandler(data);
      });
    }
  }, {
    key: "installComponent",
    value: function () {
      var _ref29 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee28(component) {
        return _regenerator2.default.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.t0 = this;
                _context28.next = 3;
                return this.convertComponentForTransmission(component);

              case 3:
                _context28.t1 = _context28.sent;

                _context28.t0.installComponentHandler.call(_context28.t0, _context28.t1);

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function installComponent(_x56) {
        return _ref29.apply(this, arguments);
      }

      return installComponent;
    }()
  }, {
    key: "registerUpdateObserver",
    value: function registerUpdateObserver(callback) {
      var observer = { id: Math.random, callback: callback };
      this.updateObservers.push(observer);
      return observer;
    }
  }, {
    key: "searchText",
    value: function searchText(text) {
      if (!this.isDesktop) {
        return;
      }
      this.lastSearchedText = text;
      this.searchHandler(text);
    }
  }, {
    key: "redoSearch",
    value: function redoSearch() {
      if (this.lastSearchedText) {
        this.searchText(this.lastSearchedText);
      }
    }
  }, {
    key: "deregisterUpdateObserver",
    value: function deregisterUpdateObserver(observer) {
      _.pull(this.updateObservers, observer);
    }

    // Pass null to cancel search

  }, {
    key: "desktop_setSearchHandler",
    value: function desktop_setSearchHandler(handler) {
      this.searchHandler = handler;
    }
  }, {
    key: "desktop_windowGainedFocus",
    value: function desktop_windowGainedFocus() {
      this.$rootScope.$broadcast("window-gained-focus");
    }
  }, {
    key: "desktop_windowLostFocus",
    value: function desktop_windowLostFocus() {
      this.$rootScope.$broadcast("window-lost-focus");
    }
  }, {
    key: "desktop_onComponentInstallationComplete",
    value: function desktop_onComponentInstallationComplete(componentData, error) {
      var _this64 = this;

      // console.log("Web|Component Installation/Update Complete", componentData, error);

      // Desktop is only allowed to change these keys:
      var permissableKeys = ["package_info", "local_url"];
      var component = this.modelManager.findItem(componentData.uuid);

      if (!component) {
        console.error("desktop_onComponentInstallationComplete component is null for uuid", componentData.uuid);
        return;
      }

      if (error) {
        component.setAppDataItem("installError", error);
      } else {
        var _iteratorNormalCompletion52 = true;
        var _didIteratorError52 = false;
        var _iteratorError52 = undefined;

        try {
          for (var _iterator52 = permissableKeys[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
            var key = _step52.value;

            component[key] = componentData.content[key];
          }
        } catch (err) {
          _didIteratorError52 = true;
          _iteratorError52 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion52 && _iterator52.return) {
              _iterator52.return();
            }
          } finally {
            if (_didIteratorError52) {
              throw _iteratorError52;
            }
          }
        }

        this.modelManager.notifySyncObserversOfModels([component], SFModelManager.MappingSourceDesktopInstalled);
        component.setAppDataItem("installError", null);
      }

      this.modelManager.setItemDirty(component, true);
      this.syncManager.sync();

      this.timeout(function () {
        var _iteratorNormalCompletion53 = true;
        var _didIteratorError53 = false;
        var _iteratorError53 = undefined;

        try {
          for (var _iterator53 = _this64.updateObservers[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
            var observer = _step53.value;

            observer.callback(component);
          }
        } catch (err) {
          _didIteratorError53 = true;
          _iteratorError53 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion53 && _iterator53.return) {
              _iterator53.return();
            }
          } finally {
            if (_didIteratorError53) {
              throw _iteratorError53;
            }
          }
        }
      });
    }
  }, {
    key: "desktop_registerComponentActivationObserver",
    value: function desktop_registerComponentActivationObserver(callback) {
      var observer = { id: Math.random, callback: callback };
      this.componentActivationObservers.push(observer);
      return observer;
    }
  }, {
    key: "desktop_deregisterComponentActivationObserver",
    value: function desktop_deregisterComponentActivationObserver(observer) {
      _.pull(this.componentActivationObservers, observer);
    }

    /* Notify observers that a component has been registered/activated */

  }, {
    key: "notifyComponentActivation",
    value: function () {
      var _ref30 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee29(component) {
        var _this65 = this;

        var serializedComponent;
        return _regenerator2.default.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.convertComponentForTransmission(component);

              case 2:
                serializedComponent = _context29.sent;


                this.timeout(function () {
                  var _iteratorNormalCompletion54 = true;
                  var _didIteratorError54 = false;
                  var _iteratorError54 = undefined;

                  try {
                    for (var _iterator54 = _this65.componentActivationObservers[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {
                      var observer = _step54.value;

                      observer.callback(serializedComponent);
                    }
                  } catch (err) {
                    _didIteratorError54 = true;
                    _iteratorError54 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion54 && _iterator54.return) {
                        _iterator54.return();
                      }
                    } finally {
                      if (_didIteratorError54) {
                        throw _iteratorError54;
                      }
                    }
                  }
                });

              case 4:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function notifyComponentActivation(_x57) {
        return _ref30.apply(this, arguments);
      }

      return notifyComponentActivation;
    }()

    /* Used to resolve "sn://" */

  }, {
    key: "desktop_setApplicationDataPath",
    value: function desktop_setApplicationDataPath(path) {
      this.applicationDataPath = path;
    }
  }, {
    key: "desktop_setComponentInstallationSyncHandler",
    value: function desktop_setComponentInstallationSyncHandler(handler) {
      this.installationSyncHandler = handler;
    }
  }, {
    key: "desktop_setInstallComponentHandler",
    value: function desktop_setInstallComponentHandler(handler) {
      this.installComponentHandler = handler;
    }
  }, {
    key: "desktop_setInitialDataLoadHandler",
    value: function desktop_setInitialDataLoadHandler(handler) {
      this.dataLoadHandler = handler;
      if (this.dataLoaded) {
        this.dataLoadHandler();
      }
    }
  }, {
    key: "desktop_requestBackupFile",
    value: function () {
      var _ref31 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee30(callback) {
        var keys, authParams;
        return _regenerator2.default.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                if (!(this.authManager.offline() && this.passcodeManager.hasPasscode())) {
                  _context30.next = 5;
                  break;
                }

                keys = this.passcodeManager.keys();
                authParams = this.passcodeManager.passcodeAuthParams();
                _context30.next = 11;
                break;

              case 5:
                _context30.next = 7;
                return this.authManager.keys();

              case 7:
                keys = _context30.sent;
                _context30.next = 10;
                return this.authManager.getAuthParams();

              case 10:
                authParams = _context30.sent;

              case 11:

                this.modelManager.getAllItemsJSONData(keys, authParams, true /* return null on empty */
                ).then(function (data) {
                  callback(data);
                });

              case 12:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function desktop_requestBackupFile(_x58) {
        return _ref31.apply(this, arguments);
      }

      return desktop_requestBackupFile;
    }()
  }, {
    key: "desktop_setMajorDataChangeHandler",
    value: function desktop_setMajorDataChangeHandler(handler) {
      this.majorDataChangeHandler = handler;
    }
  }, {
    key: "desktop_didBeginBackup",
    value: function desktop_didBeginBackup() {
      this.$rootScope.$broadcast("did-begin-local-backup");
    }
  }, {
    key: "desktop_didFinishBackup",
    value: function desktop_didFinishBackup(success) {
      this.$rootScope.$broadcast("did-finish-local-backup", { success: success });
    }
  }]);
  return DesktopManager;
}();

angular.module('app').service('desktopManager', DesktopManager);
;
var HttpManager = function (_SFHttpManager) {
  (0, _inherits4.default)(HttpManager, _SFHttpManager);

  function HttpManager(storageManager, $timeout) {
    var _this67 = this;

    (0, _classCallCheck4.default)(this, HttpManager);

    var _this66 = (0, _possibleConstructorReturn4.default)(this, (HttpManager.__proto__ || Object.getPrototypeOf(HttpManager)).call(this, $timeout));
    // calling callbacks in a $timeout allows UI to update


    _this66.setJWTRequestHandler((0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee31() {
      return _regenerator2.default.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              return _context31.abrupt("return", storageManager.getItem("jwt"));

            case 1:
            case "end":
              return _context31.stop();
          }
        }
      }, _callee31, _this67);
    })));
    return _this66;
  }

  return HttpManager;
}(SFHttpManager);

angular.module('app').service('httpManager', HttpManager);
;
var KeyboardManager = function () {
  function KeyboardManager() {
    (0, _classCallCheck4.default)(this, KeyboardManager);

    this.observers = [];

    KeyboardManager.KeyTab = "Tab";
    KeyboardManager.KeyBackspace = "Backspace";
    KeyboardManager.KeyUp = "ArrowUp";
    KeyboardManager.KeyDown = "ArrowDown";

    KeyboardManager.KeyModifierShift = "Shift";
    KeyboardManager.KeyModifierCtrl = "Control";
    // ⌘ key on Mac, ⊞ key on Windows
    KeyboardManager.KeyModifierMeta = "Meta";
    KeyboardManager.KeyModifierAlt = "Alt";

    KeyboardManager.KeyEventDown = "KeyEventDown";
    KeyboardManager.KeyEventUp = "KeyEventUp";

    KeyboardManager.AllModifiers = [KeyboardManager.KeyModifierShift, KeyboardManager.KeyModifierCtrl, KeyboardManager.KeyModifierMeta, KeyboardManager.KeyModifierAlt];

    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    window.addEventListener('keyup', this.handleKeyUp.bind(this));
  }

  (0, _createClass4.default)(KeyboardManager, [{
    key: "modifiersForEvent",
    value: function modifiersForEvent(event) {
      var eventModifiers = KeyboardManager.AllModifiers.filter(function (modifier) {
        // For a modifier like ctrlKey, must check both event.ctrlKey and event.key.
        // That's because on keyup, event.ctrlKey would be false, but event.key == Control would be true.
        var matches = (event.ctrlKey || event.key == KeyboardManager.KeyModifierCtrl) && modifier === KeyboardManager.KeyModifierCtrl || (event.metaKey || event.key == KeyboardManager.KeyModifierMeta) && modifier === KeyboardManager.KeyModifierMeta || (event.altKey || event.key == KeyboardManager.KeyModifierAlt) && modifier === KeyboardManager.KeyModifierAlt || (event.shiftKey || event.key == KeyboardManager.KeyModifierShift) && modifier === KeyboardManager.KeyModifierShift;

        return matches;
      });

      return eventModifiers;
    }
  }, {
    key: "eventMatchesKeyAndModifiers",
    value: function eventMatchesKeyAndModifiers(event, key) {
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      var eventModifiers = this.modifiersForEvent(event);

      if (eventModifiers.length != modifiers.length) {
        return false;
      }

      var _iteratorNormalCompletion55 = true;
      var _didIteratorError55 = false;
      var _iteratorError55 = undefined;

      try {
        for (var _iterator55 = modifiers[Symbol.iterator](), _step55; !(_iteratorNormalCompletion55 = (_step55 = _iterator55.next()).done); _iteratorNormalCompletion55 = true) {
          var modifier = _step55.value;

          if (!eventModifiers.includes(modifier)) {
            return false;
          }
        }

        // Modifers match, check key
      } catch (err) {
        _didIteratorError55 = true;
        _iteratorError55 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion55 && _iterator55.return) {
            _iterator55.return();
          }
        } finally {
          if (_didIteratorError55) {
            throw _iteratorError55;
          }
        }
      }

      if (!key) {
        return true;
      }

      // In the browser, shift + f results in key 'f', but in Electron, shift + f results in 'F'
      // In our case we don't differentiate between the two.
      return key.toLowerCase() == event.key.toLowerCase();
    }
  }, {
    key: "notifyObserver",
    value: function notifyObserver(event, keyEventType) {
      var _iteratorNormalCompletion56 = true;
      var _didIteratorError56 = false;
      var _iteratorError56 = undefined;

      try {
        for (var _iterator56 = this.observers[Symbol.iterator](), _step56; !(_iteratorNormalCompletion56 = (_step56 = _iterator56.next()).done); _iteratorNormalCompletion56 = true) {
          var observer = _step56.value;

          if (observer.element && event.target != observer.element) {
            continue;
          }

          if (observer.elements && !observer.elements.includes(event.target)) {
            continue;
          }

          if (observer.notElement && observer.notElement == event.target) {
            continue;
          }

          if (observer.notElementIds && observer.notElementIds.includes(event.target.id)) {
            continue;
          }

          if (this.eventMatchesKeyAndModifiers(event, observer.key, observer.modifiers)) {
            var callback = keyEventType == KeyboardManager.KeyEventDown ? observer.onKeyDown : observer.onKeyUp;
            if (callback) {
              callback(event);
            }
          }
        }
      } catch (err) {
        _didIteratorError56 = true;
        _iteratorError56 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion56 && _iterator56.return) {
            _iterator56.return();
          }
        } finally {
          if (_didIteratorError56) {
            throw _iteratorError56;
          }
        }
      }
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(event) {
      this.notifyObserver(event, KeyboardManager.KeyEventDown);
    }
  }, {
    key: "handleKeyUp",
    value: function handleKeyUp(event) {
      this.notifyObserver(event, KeyboardManager.KeyEventUp);
    }
  }, {
    key: "addKeyObserver",
    value: function addKeyObserver(_ref33) {
      var key = _ref33.key,
          modifiers = _ref33.modifiers,
          onKeyDown = _ref33.onKeyDown,
          onKeyUp = _ref33.onKeyUp,
          element = _ref33.element,
          elements = _ref33.elements,
          notElement = _ref33.notElement,
          notElementIds = _ref33.notElementIds;

      var observer = { key: key, modifiers: modifiers, onKeyDown: onKeyDown, onKeyUp: onKeyUp, element: element, elements: elements, notElement: notElement, notElementIds: notElementIds };
      this.observers.push(observer);
      return observer;
    }
  }, {
    key: "removeKeyObserver",
    value: function removeKeyObserver(observer) {
      this.observers.splice(this.observers.indexOf(observer), 1);
    }
  }]);
  return KeyboardManager;
}();

angular.module('app').service('keyboardManager', KeyboardManager);
;
var MigrationManager = function (_SFMigrationManager) {
  (0, _inherits4.default)(MigrationManager, _SFMigrationManager);

  function MigrationManager($rootScope, modelManager, syncManager, componentManager, storageManager, statusManager, authManager, desktopManager) {
    (0, _classCallCheck4.default)(this, MigrationManager);

    var _this68 = (0, _possibleConstructorReturn4.default)(this, (MigrationManager.__proto__ || Object.getPrototypeOf(MigrationManager)).call(this, modelManager, syncManager, storageManager, authManager));

    _this68.componentManager = componentManager;
    _this68.statusManager = statusManager;
    _this68.desktopManager = desktopManager;
    return _this68;
  }

  (0, _createClass4.default)(MigrationManager, [{
    key: "registeredMigrations",
    value: function registeredMigrations() {
      return [this.editorToComponentMigration(), this.componentUrlToHostedUrl(), this.removeTagReferencesFromNotes()];
    }

    /*
    Migrate SN|Editor to SN|Component. Editors are deprecated as of November 2017. Editors using old APIs must
    convert to using the new component API.
    */

  }, {
    key: "editorToComponentMigration",
    value: function editorToComponentMigration() {
      var _this69 = this;

      return {
        name: "editor-to-component",
        content_type: "SN|Editor",
        handler: function () {
          var _ref34 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee32(editors) {
            var _iteratorNormalCompletion57, _didIteratorError57, _iteratorError57, _iterator57, _step57, editor, component, _iteratorNormalCompletion58, _didIteratorError58, _iteratorError58, _iterator58, _step58, _editor;

            return _regenerator2.default.wrap(function _callee32$(_context32) {
              while (1) {
                switch (_context32.prev = _context32.next) {
                  case 0:
                    // Convert editors to components
                    _iteratorNormalCompletion57 = true;
                    _didIteratorError57 = false;
                    _iteratorError57 = undefined;
                    _context32.prev = 3;
                    for (_iterator57 = editors[Symbol.iterator](); !(_iteratorNormalCompletion57 = (_step57 = _iterator57.next()).done); _iteratorNormalCompletion57 = true) {
                      editor = _step57.value;

                      // If there's already a component for this url, then skip this editor
                      if (editor.url && !_this69.componentManager.componentForUrl(editor.url)) {
                        component = _this69.modelManager.createItem({
                          content_type: "SN|Component",
                          content: {
                            url: editor.url,
                            name: editor.name,
                            area: "editor-editor"
                          }
                        });

                        component.setAppDataItem("data", editor.data);
                        _this69.modelManager.addItem(component);
                        _this69.modelManager.setItemDirty(component, true);
                      }
                    }

                    _context32.next = 11;
                    break;

                  case 7:
                    _context32.prev = 7;
                    _context32.t0 = _context32["catch"](3);
                    _didIteratorError57 = true;
                    _iteratorError57 = _context32.t0;

                  case 11:
                    _context32.prev = 11;
                    _context32.prev = 12;

                    if (!_iteratorNormalCompletion57 && _iterator57.return) {
                      _iterator57.return();
                    }

                  case 14:
                    _context32.prev = 14;

                    if (!_didIteratorError57) {
                      _context32.next = 17;
                      break;
                    }

                    throw _iteratorError57;

                  case 17:
                    return _context32.finish(14);

                  case 18:
                    return _context32.finish(11);

                  case 19:
                    _iteratorNormalCompletion58 = true;
                    _didIteratorError58 = false;
                    _iteratorError58 = undefined;
                    _context32.prev = 22;
                    for (_iterator58 = editors[Symbol.iterator](); !(_iteratorNormalCompletion58 = (_step58 = _iterator58.next()).done); _iteratorNormalCompletion58 = true) {
                      _editor = _step58.value;

                      _this69.modelManager.setItemToBeDeleted(_editor);
                    }

                    _context32.next = 30;
                    break;

                  case 26:
                    _context32.prev = 26;
                    _context32.t1 = _context32["catch"](22);
                    _didIteratorError58 = true;
                    _iteratorError58 = _context32.t1;

                  case 30:
                    _context32.prev = 30;
                    _context32.prev = 31;

                    if (!_iteratorNormalCompletion58 && _iterator58.return) {
                      _iterator58.return();
                    }

                  case 33:
                    _context32.prev = 33;

                    if (!_didIteratorError58) {
                      _context32.next = 36;
                      break;
                    }

                    throw _iteratorError58;

                  case 36:
                    return _context32.finish(33);

                  case 37:
                    return _context32.finish(30);

                  case 38:
                    _this69.syncManager.sync();

                  case 39:
                  case "end":
                    return _context32.stop();
                }
              }
            }, _callee32, _this69, [[3, 7, 11, 19], [12,, 14, 18], [22, 26, 30, 38], [31,, 33, 37]]);
          }));

          function handler(_x60) {
            return _ref34.apply(this, arguments);
          }

          return handler;
        }()
      };
    }

    /*
    Migrate component.url fields to component.hosted_url. This involves rewriting any note data that relied on the
    component.url value to store clientData, such as the CodeEditor, which stores the programming language for the note
    in the note's clientData[component.url]. We want to rewrite any matching items to transfer that clientData into
    clientData[component.uuid].
     April 3, 2019 note: it seems this migration is mis-named. The first part of the description doesn't match what the code is actually doing.
    It has nothing to do with url/hosted_url relationship and more to do with just mapping client data from the note's hosted_url to its uuid
     Created: July 6, 2018
    */

  }, {
    key: "componentUrlToHostedUrl",
    value: function componentUrlToHostedUrl() {
      var _this70 = this;

      return {
        name: "component-url-to-hosted-url",
        content_type: "SN|Component",
        handler: function () {
          var _ref35 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee33(components) {
            var hasChanges, notes, _iteratorNormalCompletion59, _didIteratorError59, _iteratorError59, _iterator59, _step59, note, _iteratorNormalCompletion60, _didIteratorError60, _iteratorError60, _iterator60, _step60, component, clientData;

            return _regenerator2.default.wrap(function _callee33$(_context33) {
              while (1) {
                switch (_context33.prev = _context33.next) {
                  case 0:
                    hasChanges = false;
                    notes = _this70.modelManager.validItemsForContentType("Note");
                    _iteratorNormalCompletion59 = true;
                    _didIteratorError59 = false;
                    _iteratorError59 = undefined;
                    _context33.prev = 5;
                    _iterator59 = notes[Symbol.iterator]();

                  case 7:
                    if (_iteratorNormalCompletion59 = (_step59 = _iterator59.next()).done) {
                      _context33.next = 31;
                      break;
                    }

                    note = _step59.value;
                    _iteratorNormalCompletion60 = true;
                    _didIteratorError60 = false;
                    _iteratorError60 = undefined;
                    _context33.prev = 12;

                    for (_iterator60 = components[Symbol.iterator](); !(_iteratorNormalCompletion60 = (_step60 = _iterator60.next()).done); _iteratorNormalCompletion60 = true) {
                      component = _step60.value;
                      clientData = note.getDomainDataItem(component.hosted_url, ComponentManager.ClientDataDomain);

                      if (clientData) {
                        note.setDomainDataItem(component.uuid, clientData, ComponentManager.ClientDataDomain);
                        note.setDomainDataItem(component.hosted_url, null, ComponentManager.ClientDataDomain);
                        _this70.modelManager.setItemDirty(note, true);
                        hasChanges = true;
                      }
                    }
                    _context33.next = 20;
                    break;

                  case 16:
                    _context33.prev = 16;
                    _context33.t0 = _context33["catch"](12);
                    _didIteratorError60 = true;
                    _iteratorError60 = _context33.t0;

                  case 20:
                    _context33.prev = 20;
                    _context33.prev = 21;

                    if (!_iteratorNormalCompletion60 && _iterator60.return) {
                      _iterator60.return();
                    }

                  case 23:
                    _context33.prev = 23;

                    if (!_didIteratorError60) {
                      _context33.next = 26;
                      break;
                    }

                    throw _iteratorError60;

                  case 26:
                    return _context33.finish(23);

                  case 27:
                    return _context33.finish(20);

                  case 28:
                    _iteratorNormalCompletion59 = true;
                    _context33.next = 7;
                    break;

                  case 31:
                    _context33.next = 37;
                    break;

                  case 33:
                    _context33.prev = 33;
                    _context33.t1 = _context33["catch"](5);
                    _didIteratorError59 = true;
                    _iteratorError59 = _context33.t1;

                  case 37:
                    _context33.prev = 37;
                    _context33.prev = 38;

                    if (!_iteratorNormalCompletion59 && _iterator59.return) {
                      _iterator59.return();
                    }

                  case 40:
                    _context33.prev = 40;

                    if (!_didIteratorError59) {
                      _context33.next = 43;
                      break;
                    }

                    throw _iteratorError59;

                  case 43:
                    return _context33.finish(40);

                  case 44:
                    return _context33.finish(37);

                  case 45:

                    if (hasChanges) {
                      _this70.syncManager.sync();
                    }

                  case 46:
                  case "end":
                    return _context33.stop();
                }
              }
            }, _callee33, _this70, [[5, 33, 37, 45], [12, 16, 20, 28], [21,, 23, 27], [38,, 40, 44]]);
          }));

          function handler(_x61) {
            return _ref35.apply(this, arguments);
          }

          return handler;
        }()
      };
    }

    /*
    Migrate notes which have relationships on tags to migrate those relationships to the tags themselves.
    That is, notes.content.references should not include any mention of tags.
    This will apply to notes created before the schema change. Now, only tags reference notes.
    Created: April 3, 2019
    */

  }, {
    key: "removeTagReferencesFromNotes",
    value: function removeTagReferencesFromNotes() {
      var _this71 = this;

      return {
        name: "remove-tag-references-from-notes",
        content_type: "Note",
        handler: function () {
          var _ref36 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee34(notes) {
            var needsSync, status, dirtyCount, _iteratorNormalCompletion61, _didIteratorError61, _iteratorError61, _iterator61, _step61, note, references, newReferences, _iteratorNormalCompletion62, _didIteratorError62, _iteratorError62, _iterator62, _step62, reference, tag;

            return _regenerator2.default.wrap(function _callee34$(_context34) {
              while (1) {
                switch (_context34.prev = _context34.next) {
                  case 0:
                    needsSync = false;
                    status = _this71.statusManager.addStatusFromString("Optimizing data...");
                    dirtyCount = 0;
                    _iteratorNormalCompletion61 = true;
                    _didIteratorError61 = false;
                    _iteratorError61 = undefined;
                    _context34.prev = 6;
                    _iterator61 = notes[Symbol.iterator]();

                  case 8:
                    if (_iteratorNormalCompletion61 = (_step61 = _iterator61.next()).done) {
                      _context34.next = 47;
                      break;
                    }

                    note = _step61.value;

                    if (note.content) {
                      _context34.next = 12;
                      break;
                    }

                    return _context34.abrupt("continue", 44);

                  case 12:
                    references = note.content.references;
                    // Remove any tag references, and transfer them to the tag if neccessary.

                    newReferences = [];
                    _iteratorNormalCompletion62 = true;
                    _didIteratorError62 = false;
                    _iteratorError62 = undefined;
                    _context34.prev = 17;
                    _iterator62 = references[Symbol.iterator]();

                  case 19:
                    if (_iteratorNormalCompletion62 = (_step62 = _iterator62.next()).done) {
                      _context34.next = 29;
                      break;
                    }

                    reference = _step62.value;

                    if (!(reference.content_type != "Tag")) {
                      _context34.next = 24;
                      break;
                    }

                    newReferences.push(reference);
                    return _context34.abrupt("continue", 26);

                  case 24:

                    // is Tag content_type, we will not be adding this to newReferences
                    tag = _this71.modelManager.findItem(reference.uuid);

                    if (tag && !tag.hasRelationshipWithItem(note)) {
                      tag.addItemAsRelationship(note);
                      _this71.modelManager.setItemDirty(tag, true);
                      dirtyCount++;
                    }

                  case 26:
                    _iteratorNormalCompletion62 = true;
                    _context34.next = 19;
                    break;

                  case 29:
                    _context34.next = 35;
                    break;

                  case 31:
                    _context34.prev = 31;
                    _context34.t0 = _context34["catch"](17);
                    _didIteratorError62 = true;
                    _iteratorError62 = _context34.t0;

                  case 35:
                    _context34.prev = 35;
                    _context34.prev = 36;

                    if (!_iteratorNormalCompletion62 && _iterator62.return) {
                      _iterator62.return();
                    }

                  case 38:
                    _context34.prev = 38;

                    if (!_didIteratorError62) {
                      _context34.next = 41;
                      break;
                    }

                    throw _iteratorError62;

                  case 41:
                    return _context34.finish(38);

                  case 42:
                    return _context34.finish(35);

                  case 43:

                    if (newReferences.length != references.length) {
                      note.content.references = newReferences;
                      _this71.modelManager.setItemDirty(note, true);
                      dirtyCount++;
                    }

                  case 44:
                    _iteratorNormalCompletion61 = true;
                    _context34.next = 8;
                    break;

                  case 47:
                    _context34.next = 53;
                    break;

                  case 49:
                    _context34.prev = 49;
                    _context34.t1 = _context34["catch"](6);
                    _didIteratorError61 = true;
                    _iteratorError61 = _context34.t1;

                  case 53:
                    _context34.prev = 53;
                    _context34.prev = 54;

                    if (!_iteratorNormalCompletion61 && _iterator61.return) {
                      _iterator61.return();
                    }

                  case 56:
                    _context34.prev = 56;

                    if (!_didIteratorError61) {
                      _context34.next = 59;
                      break;
                    }

                    throw _iteratorError61;

                  case 59:
                    return _context34.finish(56);

                  case 60:
                    return _context34.finish(53);

                  case 61:
                    if (!(dirtyCount > 0)) {
                      _context34.next = 70;
                      break;
                    }

                    if (isDesktopApplication()) {
                      _this71.desktopManager.saveBackup();
                    }

                    status = _this71.statusManager.replaceStatusWithString(status, dirtyCount + " items optimized.");
                    _context34.next = 66;
                    return _this71.syncManager.sync();

                  case 66:

                    status = _this71.statusManager.replaceStatusWithString(status, "Optimization complete.");
                    setTimeout(function () {
                      _this71.statusManager.removeStatus(status);
                    }, 2000);
                    _context34.next = 71;
                    break;

                  case 70:
                    _this71.statusManager.removeStatus(status);

                  case 71:
                  case "end":
                    return _context34.stop();
                }
              }
            }, _callee34, _this71, [[6, 49, 53, 61], [17, 31, 35, 43], [36,, 38, 42], [54,, 56, 60]]);
          }));

          function handler(_x62) {
            return _ref36.apply(this, arguments);
          }

          return handler;
        }()
      };
    }
  }]);
  return MigrationManager;
}(SFMigrationManager);

angular.module('app').service('migrationManager', MigrationManager);
;SFModelManager.ContentTypeClassMapping = {
  "Note": SNNote,
  "Tag": SNTag,
  "SN|SmartTag": SNSmartTag,
  "Extension": SNExtension,
  "SN|Editor": SNEditor,
  "SN|Theme": SNTheme,
  "SN|Component": SNComponent,
  "SF|Extension": SNServerExtension,
  "SF|MFA": SNMfa,
  "SN|Privileges": SFPrivileges
};

SFItem.AppDomain = "org.standardnotes.sn";

var ModelManager = function (_SFModelManager) {
  (0, _inherits4.default)(ModelManager, _SFModelManager);

  function ModelManager(storageManager, $timeout) {
    (0, _classCallCheck4.default)(this, ModelManager);

    var _this72 = (0, _possibleConstructorReturn4.default)(this, (ModelManager.__proto__ || Object.getPrototypeOf(ModelManager)).call(this, $timeout));

    _this72.notes = [];
    _this72.tags = [];
    _this72.components = [];

    _this72.storageManager = storageManager;

    _this72.buildSystemSmartTags();
    return _this72;
  }

  (0, _createClass4.default)(ModelManager, [{
    key: "handleSignout",
    value: function handleSignout() {
      (0, _get4.default)(ModelManager.prototype.__proto__ || Object.getPrototypeOf(ModelManager.prototype), "handleSignout", this).call(this);
      this.notes.length = 0;
      this.tags.length = 0;
      this.components.length = 0;
    }
  }, {
    key: "noteCount",
    value: function noteCount() {
      return this.notes.filter(function (n) {
        return !n.dummy;
      }).length;
    }
  }, {
    key: "removeAllItemsFromMemory",
    value: function removeAllItemsFromMemory() {
      var _iteratorNormalCompletion63 = true;
      var _didIteratorError63 = false;
      var _iteratorError63 = undefined;

      try {
        for (var _iterator63 = this.items[Symbol.iterator](), _step63; !(_iteratorNormalCompletion63 = (_step63 = _iterator63.next()).done); _iteratorNormalCompletion63 = true) {
          var item = _step63.value;

          item.deleted = true;
        }
      } catch (err) {
        _didIteratorError63 = true;
        _iteratorError63 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion63 && _iterator63.return) {
            _iterator63.return();
          }
        } finally {
          if (_didIteratorError63) {
            throw _iteratorError63;
          }
        }
      }

      this.notifySyncObserversOfModels(this.items);
      this.handleSignout();
    }
  }, {
    key: "findOrCreateTagByTitle",
    value: function findOrCreateTagByTitle(title) {
      var tag = _.find(this.tags, { title: title });
      if (!tag) {
        tag = this.createItem({ content_type: "Tag", content: { title: title } });
        this.addItem(tag);
        this.setItemDirty(tag, true);
      }
      return tag;
    }
  }, {
    key: "addItems",
    value: function addItems(items) {
      var _this73 = this;

      var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      (0, _get4.default)(ModelManager.prototype.__proto__ || Object.getPrototypeOf(ModelManager.prototype), "addItems", this).call(this, items, globalOnly);

      items.forEach(function (item) {
        // In some cases, you just want to add the item to this.items, and not to the individual arrays
        // This applies when you want to keep an item syncable, but not display it via the individual arrays
        if (!globalOnly) {
          if (item.content_type == "Tag") {
            if (!_.find(_this73.tags, { uuid: item.uuid })) {
              _this73.tags.splice(_.sortedIndexBy(_this73.tags, item, function (item) {
                if (item.title) return item.title.toLowerCase();else return '';
              }), 0, item);
            }
          } else if (item.content_type == "Note") {
            if (!_.find(_this73.notes, { uuid: item.uuid })) {
              _this73.notes.unshift(item);
            }
          } else if (item.content_type == "SN|Component") {
            if (!_.find(_this73.components, { uuid: item.uuid })) {
              _this73.components.unshift(item);
            }
          }
        }
      });
    }
  }, {
    key: "resortTag",
    value: function resortTag(tag) {
      _.pull(this.tags, tag);
      this.tags.splice(_.sortedIndexBy(this.tags, tag, function (tag) {
        if (tag.title) return tag.title.toLowerCase();else return '';
      }), 0, tag);
    }
  }, {
    key: "setItemToBeDeleted",
    value: function setItemToBeDeleted(item) {
      (0, _get4.default)(ModelManager.prototype.__proto__ || Object.getPrototypeOf(ModelManager.prototype), "setItemToBeDeleted", this).call(this, item);

      // remove from relevant array, but don't remove from all items.
      // This way, it's removed from the display, but still synced via get dirty items
      this.removeItemFromRespectiveArray(item);
    }
  }, {
    key: "removeItemLocally",
    value: function removeItemLocally(item, callback) {
      (0, _get4.default)(ModelManager.prototype.__proto__ || Object.getPrototypeOf(ModelManager.prototype), "removeItemLocally", this).call(this, item, callback);

      this.removeItemFromRespectiveArray(item);

      this.storageManager.deleteModel(item).then(callback);
    }
  }, {
    key: "removeItemFromRespectiveArray",
    value: function removeItemFromRespectiveArray(item) {
      if (item.content_type == "Tag") {
        _.remove(this.tags, { uuid: item.uuid });
      } else if (item.content_type == "Note") {
        _.remove(this.notes, { uuid: item.uuid });
      } else if (item.content_type == "SN|Component") {
        _.remove(this.components, { uuid: item.uuid });
      }
    }
  }, {
    key: "notesMatchingSmartTag",
    value: function notesMatchingSmartTag(tag) {
      var contentTypePredicate = new SFPredicate("content_type", "=", "Note");
      var predicates = [contentTypePredicate, tag.content.predicate];
      if (!tag.content.isTrashTag) {
        var notTrashedPredicate = new SFPredicate("content.trashed", "=", false);
        predicates.push(notTrashedPredicate);
      }
      var results = this.itemsMatchingPredicates(predicates);
      return results;
    }
  }, {
    key: "trashSmartTag",
    value: function trashSmartTag() {
      return this.systemSmartTags.find(function (tag) {
        return tag.content.isTrashTag;
      });
    }
  }, {
    key: "trashedItems",
    value: function trashedItems() {
      return this.notesMatchingSmartTag(this.trashSmartTag());
    }
  }, {
    key: "emptyTrash",
    value: function emptyTrash() {
      var notes = this.trashedItems();
      var _iteratorNormalCompletion64 = true;
      var _didIteratorError64 = false;
      var _iteratorError64 = undefined;

      try {
        for (var _iterator64 = notes[Symbol.iterator](), _step64; !(_iteratorNormalCompletion64 = (_step64 = _iterator64.next()).done); _iteratorNormalCompletion64 = true) {
          var note = _step64.value;

          this.setItemToBeDeleted(note);
        }
      } catch (err) {
        _didIteratorError64 = true;
        _iteratorError64 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion64 && _iterator64.return) {
            _iterator64.return();
          }
        } finally {
          if (_didIteratorError64) {
            throw _iteratorError64;
          }
        }
      }
    }
  }, {
    key: "buildSystemSmartTags",
    value: function buildSystemSmartTags() {
      this.systemSmartTags = SNSmartTag.systemSmartTags();
    }
  }, {
    key: "getSmartTagWithId",
    value: function getSmartTagWithId(id) {
      return this.getSmartTags().find(function (candidate) {
        return candidate.uuid == id;
      });
    }
  }, {
    key: "getSmartTags",
    value: function getSmartTags() {
      var userTags = this.validItemsForContentType("SN|SmartTag").sort(function (a, b) {
        return a.content.title < b.content.title ? -1 : 1;
      });
      return this.systemSmartTags.concat(userTags);
    }

    /*
    Misc
    */

  }, {
    key: "humanReadableDisplayForContentType",
    value: function humanReadableDisplayForContentType(contentType) {
      return {
        "Note": "note",
        "Tag": "tag",
        "SN|SmartTag": "smart tag",
        "Extension": "action-based extension",
        "SN|Component": "component",
        "SN|Editor": "editor",
        "SN|Theme": "theme",
        "SF|Extension": "server extension",
        "SF|MFA": "two-factor authentication setting",
        "SN|FileSafe|Credentials": "FileSafe credential",
        "SN|FileSafe|FileMetadata": "FileSafe file",
        "SN|FileSafe|Integration": "FileSafe integration"
      }[contentType];
    }
  }]);
  return ModelManager;
}(SFModelManager);

angular.module('app').service('modelManager', ModelManager);
; /* A class for handling installation of system extensions */

var NativeExtManager = function () {
  function NativeExtManager(modelManager, syncManager, singletonManager) {
    (0, _classCallCheck4.default)(this, NativeExtManager);

    this.modelManager = modelManager;
    this.syncManager = syncManager;
    this.singletonManager = singletonManager;

    this.extensionsManagerIdentifier = "org.standardnotes.extensions-manager";
    this.batchManagerIdentifier = "org.standardnotes.batch-manager";
    this.systemExtensions = [];

    this.resolveExtensionsManager();
    this.resolveBatchManager();
  }

  (0, _createClass4.default)(NativeExtManager, [{
    key: "isSystemExtension",
    value: function isSystemExtension(extension) {
      return this.systemExtensions.includes(extension.uuid);
    }
  }, {
    key: "resolveExtensionsManager",
    value: function resolveExtensionsManager() {
      var _this74 = this;

      var contentTypePredicate = new SFPredicate("content_type", "=", "SN|Component");
      var packagePredicate = new SFPredicate("package_info.identifier", "=", this.extensionsManagerIdentifier);

      this.singletonManager.registerSingleton([contentTypePredicate, packagePredicate], function (resolvedSingleton) {
        // Resolved Singleton
        _this74.systemExtensions.push(resolvedSingleton.uuid);

        var needsSync = false;
        if (isDesktopApplication()) {
          if (!resolvedSingleton.local_url) {
            resolvedSingleton.local_url = window._extensions_manager_location;
            needsSync = true;
          }
        } else {
          if (!resolvedSingleton.hosted_url) {
            resolvedSingleton.hosted_url = window._extensions_manager_location;
            needsSync = true;
          }
        }

        // Handle addition of SN|ExtensionRepo permission
        var permission = resolvedSingleton.content.permissions.find(function (p) {
          return p.name == "stream-items";
        });
        if (!permission.content_types.includes("SN|ExtensionRepo")) {
          permission.content_types.push("SN|ExtensionRepo");
          needsSync = true;
        }

        if (needsSync) {
          _this74.modelManager.setItemDirty(resolvedSingleton, true);
          _this74.syncManager.sync();
        }
      }, function (valueCallback) {
        // Safe to create. Create and return object.
        var url = window._extensions_manager_location;
        // console.log("Installing Extensions Manager from URL", url);
        if (!url) {
          console.error("window._extensions_manager_location must be set.");
          return;
        }

        var packageInfo = {
          name: "Extensions",
          identifier: _this74.extensionsManagerIdentifier
        };

        var item = {
          content_type: "SN|Component",
          content: {
            name: packageInfo.name,
            area: "rooms",
            package_info: packageInfo,
            permissions: [{
              name: "stream-items",
              content_types: ["SN|Component", "SN|Theme", "SF|Extension", "Extension", "SF|MFA", "SN|Editor", "SN|ExtensionRepo"]
            }]
          }
        };

        if (isDesktopApplication()) {
          item.content.local_url = window._extensions_manager_location;
        } else {
          item.content.hosted_url = window._extensions_manager_location;
        }

        var component = _this74.modelManager.createItem(item);
        _this74.modelManager.addItem(component);

        _this74.modelManager.setItemDirty(component, true);
        _this74.syncManager.sync();

        _this74.systemExtensions.push(component.uuid);

        valueCallback(component);
      });
    }
  }, {
    key: "resolveBatchManager",
    value: function resolveBatchManager() {
      var _this75 = this;

      var contentTypePredicate = new SFPredicate("content_type", "=", "SN|Component");
      var packagePredicate = new SFPredicate("package_info.identifier", "=", this.batchManagerIdentifier);

      this.singletonManager.registerSingleton([contentTypePredicate, packagePredicate], function (resolvedSingleton) {
        // Resolved Singleton
        _this75.systemExtensions.push(resolvedSingleton.uuid);

        var needsSync = false;
        if (isDesktopApplication()) {
          if (!resolvedSingleton.local_url) {
            resolvedSingleton.local_url = window._batch_manager_location;
            needsSync = true;
          }
        } else {
          if (!resolvedSingleton.hosted_url) {
            resolvedSingleton.hosted_url = window._batch_manager_location;
            needsSync = true;
          }
        }

        if (needsSync) {
          _this75.modelManager.setItemDirty(resolvedSingleton, true);
          _this75.syncManager.sync();
        }
      }, function (valueCallback) {
        // Safe to create. Create and return object.
        var url = window._batch_manager_location;
        // console.log("Installing Batch Manager from URL", url);
        if (!url) {
          console.error("window._batch_manager_location must be set.");
          return;
        }

        var packageInfo = {
          name: "Batch Manager",
          identifier: _this75.batchManagerIdentifier
        };

        var item = {
          content_type: "SN|Component",
          content: {
            name: packageInfo.name,
            area: "modal",
            package_info: packageInfo,
            permissions: [{
              name: "stream-items",
              content_types: ["Note", "Tag", "SN|SmartTag", "SN|Component", "SN|Theme", "SN|UserPreferences", "SF|Extension", "Extension", "SF|MFA", "SN|Editor", "SN|FileSafe|Credentials", "SN|FileSafe|FileMetadata", "SN|FileSafe|Integration"]
            }]
          }
        };

        if (isDesktopApplication()) {
          item.content.local_url = window._batch_manager_location;
        } else {
          item.content.hosted_url = window._batch_manager_location;
        }

        var component = _this75.modelManager.createItem(item);
        _this75.modelManager.addItem(component);

        _this75.modelManager.setItemDirty(component, true);
        _this75.syncManager.sync();

        _this75.systemExtensions.push(component.uuid);

        valueCallback(component);
      });
    }
  }]);
  return NativeExtManager;
}();

angular.module('app').service('nativeExtManager', NativeExtManager);
;var MillisecondsPerSecond = 1000;

var PasscodeManager = function () {
  function PasscodeManager($rootScope, authManager, storageManager, syncManager) {
    (0, _classCallCheck4.default)(this, PasscodeManager);

    this.authManager = authManager;
    this.storageManager = storageManager;
    this.syncManager = syncManager;
    this.$rootScope = $rootScope;

    this._hasPasscode = this.storageManager.getItemSync("offlineParams", StorageManager.Fixed) != null;
    this._locked = this._hasPasscode;

    this.visibilityObservers = [];
    this.passcodeChangeObservers = [];

    this.configureAutoLock();
  }

  (0, _createClass4.default)(PasscodeManager, [{
    key: "addPasscodeChangeObserver",
    value: function addPasscodeChangeObserver(callback) {
      this.passcodeChangeObservers.push(callback);
    }
  }, {
    key: "lockApplication",
    value: function lockApplication() {
      window.location.reload();
      this.cancelAutoLockTimer();
    }
  }, {
    key: "isLocked",
    value: function isLocked() {
      return this._locked;
    }
  }, {
    key: "hasPasscode",
    value: function hasPasscode() {
      return this._hasPasscode;
    }
  }, {
    key: "keys",
    value: function keys() {
      return this._keys;
    }
  }, {
    key: "addVisibilityObserver",
    value: function addVisibilityObserver(callback) {
      this.visibilityObservers.push(callback);
      return callback;
    }
  }, {
    key: "removeVisibilityObserver",
    value: function removeVisibilityObserver(callback) {
      _.pull(this.visibilityObservers, callback);
    }
  }, {
    key: "notifiyVisibilityObservers",
    value: function notifiyVisibilityObservers(visible) {
      var _iteratorNormalCompletion65 = true;
      var _didIteratorError65 = false;
      var _iteratorError65 = undefined;

      try {
        for (var _iterator65 = this.visibilityObservers[Symbol.iterator](), _step65; !(_iteratorNormalCompletion65 = (_step65 = _iterator65.next()).done); _iteratorNormalCompletion65 = true) {
          var callback = _step65.value;

          callback(visible);
        }
      } catch (err) {
        _didIteratorError65 = true;
        _iteratorError65 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion65 && _iterator65.return) {
            _iterator65.return();
          }
        } finally {
          if (_didIteratorError65) {
            throw _iteratorError65;
          }
        }
      }
    }
  }, {
    key: "setAutoLockInterval",
    value: function () {
      var _ref37 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee35(interval) {
        return _regenerator2.default.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                return _context35.abrupt("return", this.storageManager.setItem(PasscodeManager.AutoLockIntervalKey, JSON.stringify(interval), StorageManager.FixedEncrypted));

              case 1:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function setAutoLockInterval(_x64) {
        return _ref37.apply(this, arguments);
      }

      return setAutoLockInterval;
    }()
  }, {
    key: "getAutoLockInterval",
    value: function () {
      var _ref38 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee36() {
        var interval;
        return _regenerator2.default.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.storageManager.getItem(PasscodeManager.AutoLockIntervalKey, StorageManager.FixedEncrypted);

              case 2:
                interval = _context36.sent;

                if (!interval) {
                  _context36.next = 7;
                  break;
                }

                return _context36.abrupt("return", JSON.parse(interval));

              case 7:
                return _context36.abrupt("return", PasscodeManager.AutoLockIntervalNone);

              case 8:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getAutoLockInterval() {
        return _ref38.apply(this, arguments);
      }

      return getAutoLockInterval;
    }()
  }, {
    key: "passcodeAuthParams",
    value: function passcodeAuthParams() {
      var authParams = JSON.parse(this.storageManager.getItemSync("offlineParams", StorageManager.Fixed));
      if (authParams && !authParams.version) {
        var keys = this.keys();
        if (keys && keys.ak) {
          // If there's no version stored, and there's an ak, it has to be 002. Newer versions would have their version stored in authParams.
          authParams.version = "002";
        } else {
          authParams.version = "001";
        }
      }
      return authParams;
    }
  }, {
    key: "verifyPasscode",
    value: function () {
      var _ref39 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee38(passcode) {
        var _this76 = this;

        return _regenerator2.default.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                return _context38.abrupt("return", new Promise(function () {
                  var _ref40 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee37(resolve, reject) {
                    var params, keys;
                    return _regenerator2.default.wrap(function _callee37$(_context37) {
                      while (1) {
                        switch (_context37.prev = _context37.next) {
                          case 0:
                            params = _this76.passcodeAuthParams();
                            _context37.next = 3;
                            return SFJS.crypto.computeEncryptionKeysForUser(passcode, params);

                          case 3:
                            keys = _context37.sent;

                            if (keys.pw !== params.hash) {
                              resolve(false);
                            } else {
                              resolve(true);
                            }

                          case 5:
                          case "end":
                            return _context37.stop();
                        }
                      }
                    }, _callee37, _this76);
                  }));

                  return function (_x66, _x67) {
                    return _ref40.apply(this, arguments);
                  };
                }()));

              case 1:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function verifyPasscode(_x65) {
        return _ref39.apply(this, arguments);
      }

      return verifyPasscode;
    }()
  }, {
    key: "unlock",
    value: function unlock(passcode, callback) {
      var _this77 = this;

      var params = this.passcodeAuthParams();
      SFJS.crypto.computeEncryptionKeysForUser(passcode, params).then(function (keys) {
        if (keys.pw !== params.hash) {
          callback(false);
          return;
        }

        _this77._keys = keys;
        _this77._authParams = params;
        _this77.decryptLocalStorage(keys, params).then(function () {
          _this77._locked = false;
          callback(true);
        });
      });
    }
  }, {
    key: "setPasscode",
    value: function setPasscode(passcode, callback) {
      var _this78 = this;

      var uuid = SFJS.crypto.generateUUIDSync();

      SFJS.crypto.generateInitialKeysAndAuthParamsForUser(uuid, passcode).then(function (results) {
        var keys = results.keys;
        var authParams = results.authParams;

        authParams.hash = keys.pw;
        _this78._keys = keys;
        _this78._hasPasscode = true;
        _this78._authParams = authParams;

        // Encrypting will initially clear localStorage
        _this78.encryptLocalStorage(keys, authParams);

        // After it's cleared, it's safe to write to it
        _this78.storageManager.setItem("offlineParams", JSON.stringify(authParams), StorageManager.Fixed);
        callback(true);

        _this78.notifyObserversOfPasscodeChange();
      });
    }
  }, {
    key: "changePasscode",
    value: function changePasscode(newPasscode, callback) {
      this.setPasscode(newPasscode, callback);
    }
  }, {
    key: "clearPasscode",
    value: function clearPasscode() {
      this.storageManager.setItemsMode(this.authManager.isEphemeralSession() ? StorageManager.Ephemeral : StorageManager.Fixed); // Transfer from Ephemeral
      this.storageManager.removeItem("offlineParams", StorageManager.Fixed);
      this._keys = null;
      this._hasPasscode = false;

      this.notifyObserversOfPasscodeChange();
    }
  }, {
    key: "notifyObserversOfPasscodeChange",
    value: function notifyObserversOfPasscodeChange() {
      var _iteratorNormalCompletion66 = true;
      var _didIteratorError66 = false;
      var _iteratorError66 = undefined;

      try {
        for (var _iterator66 = this.passcodeChangeObservers[Symbol.iterator](), _step66; !(_iteratorNormalCompletion66 = (_step66 = _iterator66.next()).done); _iteratorNormalCompletion66 = true) {
          var observer = _step66.value;

          observer();
        }
      } catch (err) {
        _didIteratorError66 = true;
        _iteratorError66 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion66 && _iterator66.return) {
            _iterator66.return();
          }
        } finally {
          if (_didIteratorError66) {
            throw _iteratorError66;
          }
        }
      }
    }
  }, {
    key: "encryptLocalStorage",
    value: function encryptLocalStorage(keys, authParams) {
      this.storageManager.setKeys(keys, authParams);
      // Switch to Ephemeral storage, wiping Fixed storage
      // Last argument is `force`, which we set to true because in the case of changing passcode
      this.storageManager.setItemsMode(this.authManager.isEphemeralSession() ? StorageManager.Ephemeral : StorageManager.FixedEncrypted, true);
    }
  }, {
    key: "decryptLocalStorage",
    value: function () {
      var _ref41 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee39(keys, authParams) {
        return _regenerator2.default.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                this.storageManager.setKeys(keys, authParams);
                return _context39.abrupt("return", this.storageManager.decryptStorage());

              case 2:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function decryptLocalStorage(_x68, _x69) {
        return _ref41.apply(this, arguments);
      }

      return decryptLocalStorage;
    }()
  }, {
    key: "configureAutoLock",
    value: function configureAutoLock() {
      var _this79 = this;

      if (isDesktopApplication()) {
        // desktop only
        this.$rootScope.$on("window-lost-focus", function () {
          _this79.documentVisibilityChanged(false);
        });
        this.$rootScope.$on("window-gained-focus", function () {
          _this79.documentVisibilityChanged(true);
        });
      } else {
        // tab visibility listender, web only
        document.addEventListener('visibilitychange', function (e) {
          var visible = document.visibilityState == "visible";
          _this79.documentVisibilityChanged(visible);
        });
      }

      PasscodeManager.AutoLockIntervalNone = 0;
      PasscodeManager.AutoLockIntervalImmediate = 1;
      PasscodeManager.AutoLockIntervalOneMinute = 60 * MillisecondsPerSecond;
      PasscodeManager.AutoLockIntervalFiveMinutes = 300 * MillisecondsPerSecond;
      PasscodeManager.AutoLockIntervalOneHour = 3600 * MillisecondsPerSecond;

      PasscodeManager.AutoLockIntervalKey = "AutoLockIntervalKey";
    }
  }, {
    key: "getAutoLockIntervalOptions",
    value: function getAutoLockIntervalOptions() {
      return [{
        value: PasscodeManager.AutoLockIntervalNone,
        label: "Off"
      }, {
        value: PasscodeManager.AutoLockIntervalImmediate,
        label: "Immediately"
      }, {
        value: PasscodeManager.AutoLockIntervalOneMinute,
        label: "1m"
      }, {
        value: PasscodeManager.AutoLockIntervalFiveMinutes,
        label: "5m"
      }, {
        value: PasscodeManager.AutoLockIntervalOneHour,
        label: "1h"
      }];
    }
  }, {
    key: "documentVisibilityChanged",
    value: function documentVisibilityChanged(visible) {
      if (visible) {
        // check to see if lockAfterDate is not null, and if the application isn't locked.
        // if that's the case, it needs to be locked immediately.
        if (this.lockAfterDate && new Date() > this.lockAfterDate && !this.isLocked()) {
          this.lockApplication();
        } else {
          if (!this.isLocked()) {
            this.syncManager.sync();
          }
        }
        this.cancelAutoLockTimer();
      } else {
        this.beginAutoLockTimer();
      }

      this.notifiyVisibilityObservers(visible);
    }
  }, {
    key: "beginAutoLockTimer",
    value: function () {
      var _ref42 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee40() {
        var _this80 = this;

        var interval, addToNow;
        return _regenerator2.default.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.getAutoLockInterval();

              case 2:
                interval = _context40.sent;

                if (!(interval == PasscodeManager.AutoLockIntervalNone)) {
                  _context40.next = 5;
                  break;
                }

                return _context40.abrupt("return");

              case 5:

                // Use a timeout if possible, but if the computer is put to sleep, timeouts won't work.
                // Need to set a date as backup. this.lockAfterDate does not need to be persisted, as
                // living in memory seems sufficient. If memory is cleared, then the application will lock anyway.
                addToNow = function addToNow(seconds) {
                  var date = new Date();
                  date.setSeconds(date.getSeconds() + seconds);
                  return date;
                };

                this.lockAfterDate = addToNow(interval / MillisecondsPerSecond);
                this.lockTimeout = setTimeout(function () {
                  _this80.lockApplication();
                  // We don't need to look at this anymore since we've succeeded with timeout lock
                  _this80.lockAfterDate = null;
                }, interval);

              case 8:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function beginAutoLockTimer() {
        return _ref42.apply(this, arguments);
      }

      return beginAutoLockTimer;
    }()
  }, {
    key: "cancelAutoLockTimer",
    value: function cancelAutoLockTimer() {
      clearTimeout(this.lockTimeout);
      this.lockAfterDate = null;
    }
  }]);
  return PasscodeManager;
}();

angular.module('app').service('passcodeManager', PasscodeManager);
;
var PrivilegesManager = function (_SFPrivilegesManager) {
  (0, _inherits4.default)(PrivilegesManager, _SFPrivilegesManager);

  function PrivilegesManager(passcodeManager, authManager, syncManager, singletonManager, modelManager, storageManager, $rootScope, $compile) {
    var _this82 = this;

    (0, _classCallCheck4.default)(this, PrivilegesManager);

    var _this81 = (0, _possibleConstructorReturn4.default)(this, (PrivilegesManager.__proto__ || Object.getPrototypeOf(PrivilegesManager)).call(this, modelManager, syncManager, singletonManager));

    _this81.$rootScope = $rootScope;
    _this81.$compile = $compile;

    _this81.setDelegate({
      isOffline: function () {
        var _ref43 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee41() {
          return _regenerator2.default.wrap(function _callee41$(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  return _context41.abrupt("return", authManager.offline());

                case 1:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee41, _this82);
        }));

        function isOffline() {
          return _ref43.apply(this, arguments);
        }

        return isOffline;
      }(),
      hasLocalPasscode: function () {
        var _ref44 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee42() {
          return _regenerator2.default.wrap(function _callee42$(_context42) {
            while (1) {
              switch (_context42.prev = _context42.next) {
                case 0:
                  return _context42.abrupt("return", passcodeManager.hasPasscode());

                case 1:
                case "end":
                  return _context42.stop();
              }
            }
          }, _callee42, _this82);
        }));

        function hasLocalPasscode() {
          return _ref44.apply(this, arguments);
        }

        return hasLocalPasscode;
      }(),
      saveToStorage: function () {
        var _ref45 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee43(key, value) {
          return _regenerator2.default.wrap(function _callee43$(_context43) {
            while (1) {
              switch (_context43.prev = _context43.next) {
                case 0:
                  return _context43.abrupt("return", storageManager.setItem(key, value, storageManager.bestStorageMode()));

                case 1:
                case "end":
                  return _context43.stop();
              }
            }
          }, _callee43, _this82);
        }));

        function saveToStorage(_x70, _x71) {
          return _ref45.apply(this, arguments);
        }

        return saveToStorage;
      }(),
      getFromStorage: function () {
        var _ref46 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee44(key) {
          return _regenerator2.default.wrap(function _callee44$(_context44) {
            while (1) {
              switch (_context44.prev = _context44.next) {
                case 0:
                  return _context44.abrupt("return", storageManager.getItem(key, storageManager.bestStorageMode()));

                case 1:
                case "end":
                  return _context44.stop();
              }
            }
          }, _callee44, _this82);
        }));

        function getFromStorage(_x72) {
          return _ref46.apply(this, arguments);
        }

        return getFromStorage;
      }(),
      verifyAccountPassword: function () {
        var _ref47 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee45(password) {
          return _regenerator2.default.wrap(function _callee45$(_context45) {
            while (1) {
              switch (_context45.prev = _context45.next) {
                case 0:
                  return _context45.abrupt("return", authManager.verifyAccountPassword(password));

                case 1:
                case "end":
                  return _context45.stop();
              }
            }
          }, _callee45, _this82);
        }));

        function verifyAccountPassword(_x73) {
          return _ref47.apply(this, arguments);
        }

        return verifyAccountPassword;
      }(),
      verifyLocalPasscode: function () {
        var _ref48 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee46(passcode) {
          return _regenerator2.default.wrap(function _callee46$(_context46) {
            while (1) {
              switch (_context46.prev = _context46.next) {
                case 0:
                  return _context46.abrupt("return", passcodeManager.verifyPasscode(passcode));

                case 1:
                case "end":
                  return _context46.stop();
              }
            }
          }, _callee46, _this82);
        }));

        function verifyLocalPasscode(_x74) {
          return _ref48.apply(this, arguments);
        }

        return verifyLocalPasscode;
      }()
    });
    return _this81;
  }

  (0, _createClass4.default)(PrivilegesManager, [{
    key: "presentPrivilegesModal",
    value: function presentPrivilegesModal(action, onSuccess, onCancel) {
      var _this83 = this;

      if (this.authenticationInProgress()) {
        onCancel && onCancel();
        return;
      }

      var customSuccess = function customSuccess() {
        onSuccess && onSuccess();
        _this83.currentAuthenticationElement = null;
      };

      var customCancel = function customCancel() {
        onCancel && onCancel();
        _this83.currentAuthenticationElement = null;
      };

      var scope = this.$rootScope.$new(true);
      scope.action = action;
      scope.onSuccess = customSuccess;
      scope.onCancel = customCancel;
      var el = this.$compile("<privileges-auth-modal action='action' on-success='onSuccess' on-cancel='onCancel' class='sk-modal'></privileges-auth-modal>")(scope);
      angular.element(document.body).append(el);

      this.currentAuthenticationElement = el;
    }
  }, {
    key: "presentPrivilegesManagementModal",
    value: function presentPrivilegesManagementModal() {
      var scope = this.$rootScope.$new(true);
      var el = this.$compile("<privileges-management-modal class='sk-modal'></privileges-management-modal>")(scope);
      angular.element(document.body).append(el);
    }
  }, {
    key: "authenticationInProgress",
    value: function authenticationInProgress() {
      return this.currentAuthenticationElement != null;
    }
  }]);
  return PrivilegesManager;
}(SFPrivilegesManager);

angular.module('app').service('privilegesManager', PrivilegesManager);
;
var SessionHistory = function (_SFSessionHistoryMana) {
  (0, _inherits4.default)(SessionHistory, _SFSessionHistoryMana);

  function SessionHistory(modelManager, storageManager, authManager, passcodeManager, $timeout) {
    var _this85 = this;

    var _this84;

    (0, _classCallCheck4.default)(this, SessionHistory);


    SFItemHistory.HistoryEntryClassMapping = {
      "Note": NoteHistoryEntry

      // Session History can be encrypted with passcode keys. If it changes, we need to resave session
      // history with the new keys.
    };passcodeManager.addPasscodeChangeObserver(function () {
      _this84.saveToDisk();
    });

    var keyRequestHandler = function () {
      var _ref49 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee47() {
        var offline, auth_params, keys;
        return _regenerator2.default.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                offline = authManager.offline();

                if (!offline) {
                  _context47.next = 5;
                  break;
                }

                _context47.t0 = passcodeManager.passcodeAuthParams();
                _context47.next = 8;
                break;

              case 5:
                _context47.next = 7;
                return authManager.getAuthParams();

              case 7:
                _context47.t0 = _context47.sent;

              case 8:
                auth_params = _context47.t0;

                if (!offline) {
                  _context47.next = 13;
                  break;
                }

                _context47.t1 = passcodeManager.keys();
                _context47.next = 16;
                break;

              case 13:
                _context47.next = 15;
                return authManager.keys();

              case 15:
                _context47.t1 = _context47.sent;

              case 16:
                keys = _context47.t1;
                return _context47.abrupt("return", {
                  keys: keys,
                  offline: offline,
                  auth_params: auth_params
                });

              case 18:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, _this85);
      }));

      return function keyRequestHandler() {
        return _ref49.apply(this, arguments);
      };
    }();

    var contentTypes = ["Note"];
    return _this84 = (0, _possibleConstructorReturn4.default)(this, (SessionHistory.__proto__ || Object.getPrototypeOf(SessionHistory)).call(this, modelManager, storageManager, keyRequestHandler, contentTypes, $timeout));
  }

  return SessionHistory;
}(SFSessionHistoryManager);

angular.module('app').service('sessionHistory', SessionHistory);
;
var SingletonManager = function (_SFSingletonManager) {
  (0, _inherits4.default)(SingletonManager, _SFSingletonManager);

  function SingletonManager(modelManager, syncManager) {
    (0, _classCallCheck4.default)(this, SingletonManager);
    return (0, _possibleConstructorReturn4.default)(this, (SingletonManager.__proto__ || Object.getPrototypeOf(SingletonManager)).call(this, modelManager, syncManager));
  }

  return SingletonManager;
}(SFSingletonManager);

angular.module('app').service('singletonManager', SingletonManager);
;
var StatusManager = function () {
  function StatusManager() {
    (0, _classCallCheck4.default)(this, StatusManager);

    this.statuses = [];
    this.observers = [];
  }

  (0, _createClass4.default)(StatusManager, [{
    key: "statusFromString",
    value: function statusFromString(string) {
      return { string: string };
    }
  }, {
    key: "replaceStatusWithString",
    value: function replaceStatusWithString(status, string) {
      this.removeStatus(status);
      return this.addStatusFromString(string);
    }
  }, {
    key: "addStatusFromString",
    value: function addStatusFromString(string) {
      return this.addStatus(this.statusFromString(string));
    }
  }, {
    key: "addStatus",
    value: function addStatus(status) {
      if ((typeof status === "undefined" ? "undefined" : (0, _typeof3.default)(status)) !== "object") {
        console.error("Attempting to set non-object status", status);
        return;
      }

      this.statuses.push(status);
      this.notifyObservers();
      return status;
    }
  }, {
    key: "removeStatus",
    value: function removeStatus(status) {
      _.pull(this.statuses, status);
      this.notifyObservers();
      return null;
    }
  }, {
    key: "getStatusString",
    value: function getStatusString() {
      var result = "";
      this.statuses.forEach(function (status, index) {
        if (index > 0) {
          result += "  ";
        }
        result += status.string;
      });

      return result;
    }
  }, {
    key: "notifyObservers",
    value: function notifyObservers() {
      var _iteratorNormalCompletion67 = true;
      var _didIteratorError67 = false;
      var _iteratorError67 = undefined;

      try {
        for (var _iterator67 = this.observers[Symbol.iterator](), _step67; !(_iteratorNormalCompletion67 = (_step67 = _iterator67.next()).done); _iteratorNormalCompletion67 = true) {
          var observer = _step67.value;

          observer(this.getStatusString());
        }
      } catch (err) {
        _didIteratorError67 = true;
        _iteratorError67 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion67 && _iterator67.return) {
            _iterator67.return();
          }
        } finally {
          if (_didIteratorError67) {
            throw _iteratorError67;
          }
        }
      }
    }
  }, {
    key: "addStatusObserver",
    value: function addStatusObserver(callback) {
      this.observers.push(callback);
    }
  }, {
    key: "removeStatusObserver",
    value: function removeStatusObserver(callback) {
      _.pull(this.statuses, callback);
    }
  }]);
  return StatusManager;
}();

angular.module('app').service('statusManager', StatusManager);
;
var MemoryStorage = function () {
  function MemoryStorage() {
    (0, _classCallCheck4.default)(this, MemoryStorage);

    this.memory = {};
  }

  (0, _createClass4.default)(MemoryStorage, [{
    key: "getItem",
    value: function getItem(key) {
      return this.memory[key] || null;
    }
  }, {
    key: "getItemSync",
    value: function getItemSync(key) {
      return this.getItem(key);
    }
  }, {
    key: "setItem",
    value: function setItem(key, value) {
      this.memory[key] = value;
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {
      delete this.memory[key];
    }
  }, {
    key: "clear",
    value: function clear() {
      this.memory = {};
    }
  }, {
    key: "keys",
    value: function keys() {
      return Object.keys(this.memory);
    }
  }, {
    key: "key",
    value: function key(index) {
      return Object.keys(this.memory)[index];
    }
  }, {
    key: "length",
    get: function get() {
      return Object.keys(this.memory).length;
    }
  }]);
  return MemoryStorage;
}();

var StorageManager = function (_SFStorageManager) {
  (0, _inherits4.default)(StorageManager, _SFStorageManager);

  function StorageManager(dbManager) {
    (0, _classCallCheck4.default)(this, StorageManager);

    var _this87 = (0, _possibleConstructorReturn4.default)(this, (StorageManager.__proto__ || Object.getPrototypeOf(StorageManager)).call(this));

    _this87.dbManager = dbManager;
    return _this87;
  }

  (0, _createClass4.default)(StorageManager, [{
    key: "initialize",
    value: function initialize(hasPasscode, ephemeral) {
      if (hasPasscode) {
        // We don't want to save anything in fixed storage except for actual item data (in IndexedDB)
        this.storage = this.memoryStorage;
        this.itemsStorageMode = StorageManager.FixedEncrypted;
      } else if (ephemeral) {
        // We don't want to save anything in fixed storage as well as IndexedDB
        this.storage = this.memoryStorage;
        this.itemsStorageMode = StorageManager.Ephemeral;
      } else {
        this.storage = localStorage;
        this.itemsStorageMode = StorageManager.Fixed;
      }

      this.modelStorageMode = ephemeral ? StorageManager.Ephemeral : StorageManager.Fixed;
    }
  }, {
    key: "setItemsMode",
    value: function setItemsMode(mode, force) {
      var newStorage = this.getVault(mode);
      if (newStorage !== this.storage || mode !== this.itemsStorageMode || force) {
        // transfer storages
        var length = this.storage.length;
        for (var i = 0; i < length; i++) {
          var key = this.storage.key(i);
          newStorage.setItem(key, this.storage.getItem(key));
        }

        this.itemsStorageMode = mode;
        if (newStorage !== this.storage) {
          // Only clear if this.storage isn't the same reference as newStorage
          this.storage.clear();
        }
        this.storage = newStorage;

        if (mode == StorageManager.FixedEncrypted) {
          this.writeEncryptedStorageToDisk();
        } else if (mode == StorageManager.Fixed) {
          // Remove encrypted storage
          this.removeItem("encryptedStorage", StorageManager.Fixed);
        }
      }
    }
  }, {
    key: "getVault",
    value: function getVault(vaultKey) {
      if (vaultKey) {
        if (vaultKey == StorageManager.Ephemeral || vaultKey == StorageManager.FixedEncrypted) {
          return this.memoryStorage;
        } else {
          return localStorage;
        }
      } else {
        return this.storage;
      }
    }
  }, {
    key: "setItem",
    value: function () {
      var _ref50 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee48(key, value, vaultKey) {
        var storage;
        return _regenerator2.default.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                storage = this.getVault(vaultKey);

                try {
                  storage.setItem(key, value);
                } catch (e) {
                  console.error("Exception while trying to setItem in StorageManager:", e);
                  alert("The application's local storage is out of space. If you have Session History save-to-disk enabled, please disable it, and try again.");
                }

                if (vaultKey === StorageManager.FixedEncrypted || !vaultKey && this.itemsStorageMode === StorageManager.FixedEncrypted) {
                  this.writeEncryptedStorageToDisk();
                }

              case 3:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function setItem(_x75, _x76, _x77) {
        return _ref50.apply(this, arguments);
      }

      return setItem;
    }()
  }, {
    key: "getItem",
    value: function () {
      var _ref51 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee49(key, vault) {
        return _regenerator2.default.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                return _context49.abrupt("return", this.getItemSync(key, vault));

              case 1:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function getItem(_x78, _x79) {
        return _ref51.apply(this, arguments);
      }

      return getItem;
    }()
  }, {
    key: "getItemSync",
    value: function getItemSync(key, vault) {
      var storage = this.getVault(vault);
      return storage.getItem(key);
    }
  }, {
    key: "removeItem",
    value: function () {
      var _ref52 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee50(key, vault) {
        var storage;
        return _regenerator2.default.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                storage = this.getVault(vault);
                return _context50.abrupt("return", storage.removeItem(key));

              case 2:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function removeItem(_x80, _x81) {
        return _ref52.apply(this, arguments);
      }

      return removeItem;
    }()
  }, {
    key: "clear",
    value: function () {
      var _ref53 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee51() {
        return _regenerator2.default.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                this.memoryStorage.clear();
                localStorage.clear();

              case 2:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function clear() {
        return _ref53.apply(this, arguments);
      }

      return clear;
    }()
  }, {
    key: "storageAsHash",
    value: function storageAsHash() {
      var hash = {};
      var length = this.storage.length;
      for (var i = 0; i < length; i++) {
        var key = this.storage.key(i);
        hash[key] = this.storage.getItem(key);
      }
      return hash;
    }
  }, {
    key: "setKeys",
    value: function setKeys(keys, authParams) {
      this.encryptedStorageKeys = keys;
      this.encryptedStorageAuthParams = authParams;
    }
  }, {
    key: "writeEncryptedStorageToDisk",
    value: function writeEncryptedStorageToDisk() {
      var _this88 = this;

      var encryptedStorage = new SNEncryptedStorage();
      // Copy over totality of current storage
      encryptedStorage.content.storage = this.storageAsHash();

      // Save new encrypted storage in Fixed storage
      var params = new SFItemParams(encryptedStorage, this.encryptedStorageKeys, this.encryptedStorageAuthParams);
      params.paramsForSync().then(function (syncParams) {
        _this88.setItem("encryptedStorage", JSON.stringify(syncParams), StorageManager.Fixed);
      });
    }
  }, {
    key: "decryptStorage",
    value: function () {
      var _ref54 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee52() {
        var stored, encryptedStorage, _iteratorNormalCompletion68, _didIteratorError68, _iteratorError68, _iterator68, _step68, key;

        return _regenerator2.default.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                stored = JSON.parse(this.getItemSync("encryptedStorage", StorageManager.Fixed));
                _context52.next = 3;
                return SFJS.itemTransformer.decryptItem(stored, this.encryptedStorageKeys);

              case 3:
                encryptedStorage = new SNEncryptedStorage(stored);
                _iteratorNormalCompletion68 = true;
                _didIteratorError68 = false;
                _iteratorError68 = undefined;
                _context52.prev = 7;


                for (_iterator68 = Object.keys(encryptedStorage.content.storage)[Symbol.iterator](); !(_iteratorNormalCompletion68 = (_step68 = _iterator68.next()).done); _iteratorNormalCompletion68 = true) {
                  key = _step68.value;

                  this.setItem(key, encryptedStorage.storage[key]);
                }
                _context52.next = 15;
                break;

              case 11:
                _context52.prev = 11;
                _context52.t0 = _context52["catch"](7);
                _didIteratorError68 = true;
                _iteratorError68 = _context52.t0;

              case 15:
                _context52.prev = 15;
                _context52.prev = 16;

                if (!_iteratorNormalCompletion68 && _iterator68.return) {
                  _iterator68.return();
                }

              case 18:
                _context52.prev = 18;

                if (!_didIteratorError68) {
                  _context52.next = 21;
                  break;
                }

                throw _iteratorError68;

              case 21:
                return _context52.finish(18);

              case 22:
                return _context52.finish(15);

              case 23:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this, [[7, 11, 15, 23], [16,, 18, 22]]);
      }));

      function decryptStorage() {
        return _ref54.apply(this, arguments);
      }

      return decryptStorage;
    }()
  }, {
    key: "hasPasscode",
    value: function hasPasscode() {
      return this.getItemSync("encryptedStorage", StorageManager.Fixed) !== null;
    }
  }, {
    key: "bestStorageMode",
    value: function bestStorageMode() {
      return this.hasPasscode() ? StorageManager.FixedEncrypted : StorageManager.Fixed;
    }

    /*
    Model Storage
     If using ephemeral storage, we don't need to write it to anything as references will be held already by controllers
    and the global modelManager service.
    */

  }, {
    key: "setModelStorageMode",
    value: function setModelStorageMode(mode) {
      if (mode == this.modelStorageMode) {
        return;
      }

      if (mode == StorageManager.Ephemeral) {
        // Clear IndexedDB
        this.dbManager.clearAllModels(null);
      } else {
        // Fixed
      }

      this.modelStorageMode = mode;
    }
  }, {
    key: "getAllModels",
    value: function () {
      var _ref55 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee53() {
        var _this89 = this;

        return _regenerator2.default.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                return _context53.abrupt("return", new Promise(function (resolve, reject) {
                  if (_this89.modelStorageMode == StorageManager.Fixed) {
                    _this89.dbManager.getAllModels(resolve);
                  } else {
                    resolve();
                  }
                }));

              case 1:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));

      function getAllModels() {
        return _ref55.apply(this, arguments);
      }

      return getAllModels;
    }()
  }, {
    key: "saveModel",
    value: function () {
      var _ref56 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee54(item) {
        return _regenerator2.default.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                return _context54.abrupt("return", this.saveModels([item]));

              case 1:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function saveModel(_x82) {
        return _ref56.apply(this, arguments);
      }

      return saveModel;
    }()
  }, {
    key: "saveModels",
    value: function () {
      var _ref57 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee55(items, onsuccess, onerror) {
        var _this90 = this;

        return _regenerator2.default.wrap(function _callee55$(_context55) {
          while (1) {
            switch (_context55.prev = _context55.next) {
              case 0:
                return _context55.abrupt("return", new Promise(function (resolve, reject) {
                  if (_this90.modelStorageMode == StorageManager.Fixed) {
                    _this90.dbManager.saveModels(items, resolve, reject);
                  } else {
                    resolve();
                  }
                }));

              case 1:
              case "end":
                return _context55.stop();
            }
          }
        }, _callee55, this);
      }));

      function saveModels(_x83, _x84, _x85) {
        return _ref57.apply(this, arguments);
      }

      return saveModels;
    }()
  }, {
    key: "deleteModel",
    value: function () {
      var _ref58 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee56(item) {
        var _this91 = this;

        return _regenerator2.default.wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                return _context56.abrupt("return", new Promise(function (resolve, reject) {
                  if (_this91.modelStorageMode == StorageManager.Fixed) {
                    _this91.dbManager.deleteModel(item, resolve);
                  } else {
                    resolve();
                  }
                }));

              case 1:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56, this);
      }));

      function deleteModel(_x86) {
        return _ref58.apply(this, arguments);
      }

      return deleteModel;
    }()
  }, {
    key: "clearAllModels",
    value: function () {
      var _ref59 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee57() {
        var _this92 = this;

        return _regenerator2.default.wrap(function _callee57$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                return _context57.abrupt("return", new Promise(function (resolve, reject) {
                  _this92.dbManager.clearAllModels(resolve);
                }));

              case 1:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee57, this);
      }));

      function clearAllModels() {
        return _ref59.apply(this, arguments);
      }

      return clearAllModels;
    }()
  }, {
    key: "memoryStorage",
    get: function get() {
      if (!this._memoryStorage) {
        this._memoryStorage = new MemoryStorage();
      }
      return this._memoryStorage;
    }
  }]);
  return StorageManager;
}(SFStorageManager);

StorageManager.FixedEncrypted = "FixedEncrypted"; // encrypted memoryStorage + localStorage persistence
StorageManager.Ephemeral = "Ephemeral"; // memoryStorage
StorageManager.Fixed = "Fixed"; // localStorage

angular.module('app').service('storageManager', StorageManager);
;
var SyncManager = function (_SFSyncManager) {
  (0, _inherits4.default)(SyncManager, _SFSyncManager);

  function SyncManager(modelManager, storageManager, httpManager, $timeout, $interval, $compile, $rootScope) {
    (0, _classCallCheck4.default)(this, SyncManager);

    var _this93 = (0, _possibleConstructorReturn4.default)(this, (SyncManager.__proto__ || Object.getPrototypeOf(SyncManager)).call(this, modelManager, storageManager, httpManager, $timeout, $interval));

    _this93.$rootScope = $rootScope;
    _this93.$compile = $compile;

    // this.loggingEnabled = true;

    // Content types appearing first are always mapped first
    _this93.contentTypeLoadPriority = ["SN|UserPreferences", "SN|Privileges", "SN|Component", "SN|Theme"];
    return _this93;
  }

  (0, _createClass4.default)(SyncManager, [{
    key: "presentConflictResolutionModal",
    value: function presentConflictResolutionModal(items, callback) {
      var scope = this.$rootScope.$new(true);
      scope.item1 = items[0];
      scope.item2 = items[1];
      scope.callback = callback;
      var el = this.$compile("<conflict-resolution-modal item1='item1' item2='item2' callback='callback' class='sk-modal'></conflict-resolution-modal>")(scope);
      angular.element(document.body).append(el);
    }
  }]);
  return SyncManager;
}(SFSyncManager);

angular.module('app').service('syncManager', SyncManager);
;
var ThemeManager = function () {
  function ThemeManager(componentManager, desktopManager, storageManager, passcodeManager) {
    var _this94 = this;

    (0, _classCallCheck4.default)(this, ThemeManager);

    this.componentManager = componentManager;
    this.storageManager = storageManager;
    this.desktopManager = desktopManager;
    this.activeThemes = [];

    ThemeManager.CachedThemesKey = "cachedThemes";

    this.registerObservers();

    // When a passcode is added, all local storage will be encrypted (it doesn't know what was
    // originally saved as Fixed or FixedEncrypted). We want to rewrite cached themes here to Fixed
    // so that it's readable without authentication.
    passcodeManager.addPasscodeChangeObserver(function () {
      _this94.cacheThemes();
    });

    // The desktop application won't have its applicationDataPath until the angular document is ready,
    // so it wont be able to resolve local theme urls until thats ready
    angular.element(document).ready(function () {
      _this94.activateCachedThemes();
    });
  }

  (0, _createClass4.default)(ThemeManager, [{
    key: "activateCachedThemes",
    value: function activateCachedThemes() {
      var cachedThemes = this.getCachedThemes();
      var writeToCache = false;
      var _iteratorNormalCompletion69 = true;
      var _didIteratorError69 = false;
      var _iteratorError69 = undefined;

      try {
        for (var _iterator69 = cachedThemes[Symbol.iterator](), _step69; !(_iteratorNormalCompletion69 = (_step69 = _iterator69.next()).done); _iteratorNormalCompletion69 = true) {
          var theme = _step69.value;

          this.activateTheme(theme, writeToCache);
        }
      } catch (err) {
        _didIteratorError69 = true;
        _iteratorError69 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion69 && _iterator69.return) {
            _iterator69.return();
          }
        } finally {
          if (_didIteratorError69) {
            throw _iteratorError69;
          }
        }
      }
    }
  }, {
    key: "registerObservers",
    value: function registerObservers() {
      var _this95 = this;

      this.desktopManager.registerUpdateObserver(function (component) {
        // Reload theme if active
        if (component.active && component.isTheme()) {
          _this95.deactivateTheme(component);
          setTimeout(function () {
            _this95.activateTheme(component);
          }, 10);
        }
      });

      this.componentManager.registerHandler({ identifier: "themeManager", areas: ["themes"], activationHandler: function activationHandler(component) {
          if (component.active) {
            _this95.activateTheme(component);
          } else {
            _this95.deactivateTheme(component);
          }
        } });
    }
  }, {
    key: "hasActiveTheme",
    value: function hasActiveTheme() {
      return this.componentManager.getActiveThemes().length > 0;
    }
  }, {
    key: "deactivateAllThemes",
    value: function deactivateAllThemes() {
      var activeThemes = this.componentManager.getActiveThemes();
      var _iteratorNormalCompletion70 = true;
      var _didIteratorError70 = false;
      var _iteratorError70 = undefined;

      try {
        for (var _iterator70 = activeThemes[Symbol.iterator](), _step70; !(_iteratorNormalCompletion70 = (_step70 = _iterator70.next()).done); _iteratorNormalCompletion70 = true) {
          var theme = _step70.value;

          if (theme) {
            this.componentManager.deactivateComponent(theme);
          }
        }
      } catch (err) {
        _didIteratorError70 = true;
        _iteratorError70 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion70 && _iterator70.return) {
            _iterator70.return();
          }
        } finally {
          if (_didIteratorError70) {
            throw _iteratorError70;
          }
        }
      }

      this.decacheThemes();
    }
  }, {
    key: "activateTheme",
    value: function activateTheme(theme) {
      var writeToCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (_.find(this.activeThemes, { uuid: theme.uuid })) {
        return;
      }

      this.activeThemes.push(theme);

      var url = this.componentManager.urlForComponent(theme);
      var link = document.createElement("link");
      link.href = url;
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      link.id = theme.uuid;
      document.getElementsByTagName("head")[0].appendChild(link);

      if (writeToCache) {
        this.cacheThemes();
      }
    }
  }, {
    key: "deactivateTheme",
    value: function deactivateTheme(theme) {
      var element = document.getElementById(theme.uuid);
      if (element) {
        element.disabled = true;
        element.parentNode.removeChild(element);
      }

      _.remove(this.activeThemes, { uuid: theme.uuid });

      this.cacheThemes();
    }
  }, {
    key: "cacheThemes",
    value: function () {
      var _ref60 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee59() {
        var _this96 = this;

        var mapped, data;
        return _regenerator2.default.wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                _context59.next = 2;
                return Promise.all(this.activeThemes.map(function () {
                  var _ref61 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee58(theme) {
                    var transformer, params;
                    return _regenerator2.default.wrap(function _callee58$(_context58) {
                      while (1) {
                        switch (_context58.prev = _context58.next) {
                          case 0:
                            transformer = new SFItemParams(theme);
                            _context58.next = 3;
                            return transformer.paramsForLocalStorage();

                          case 3:
                            params = _context58.sent;
                            return _context58.abrupt("return", params);

                          case 5:
                          case "end":
                            return _context58.stop();
                        }
                      }
                    }, _callee58, _this96);
                  }));

                  return function (_x88) {
                    return _ref61.apply(this, arguments);
                  };
                }()));

              case 2:
                mapped = _context59.sent;
                data = JSON.stringify(mapped);
                return _context59.abrupt("return", this.storageManager.setItem(ThemeManager.CachedThemesKey, data, StorageManager.Fixed));

              case 5:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59, this);
      }));

      function cacheThemes() {
        return _ref60.apply(this, arguments);
      }

      return cacheThemes;
    }()
  }, {
    key: "decacheThemes",
    value: function () {
      var _ref62 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee60() {
        return _regenerator2.default.wrap(function _callee60$(_context60) {
          while (1) {
            switch (_context60.prev = _context60.next) {
              case 0:
                return _context60.abrupt("return", this.storageManager.removeItem(ThemeManager.CachedThemesKey, StorageManager.Fixed));

              case 1:
              case "end":
                return _context60.stop();
            }
          }
        }, _callee60, this);
      }));

      function decacheThemes() {
        return _ref62.apply(this, arguments);
      }

      return decacheThemes;
    }()
  }, {
    key: "getCachedThemes",
    value: function getCachedThemes() {
      var cachedThemes = this.storageManager.getItemSync(ThemeManager.CachedThemesKey, StorageManager.Fixed);
      if (cachedThemes) {
        var parsed = JSON.parse(cachedThemes);
        return parsed.map(function (theme) {
          return new SNTheme(theme);
        });
      } else {
        return [];
      }
    }
  }]);
  return ThemeManager;
}();

angular.module('app').service('themeManager', ThemeManager);
; // reuse
var locale, formatter;

angular.module('app').filter('appDate', function ($filter) {
  return function (input) {
    return input ? $filter('date')(new Date(input), 'MM/dd/yyyy', 'UTC') : '';
  };
}).filter('appDateTime', function ($filter) {
  return function (input) {
    if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
      if (!formatter) {
        locale = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language;
        formatter = new Intl.DateTimeFormat(locale, {
          year: 'numeric',
          month: 'numeric',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      return formatter.format(input);
    } else {
      return input ? $filter('date')(new Date(input), 'MM/dd/yyyy h:mm a') : '';
    }
  };
});
;angular.module('app').filter('trusted', ['$sce', function ($sce) {
  return function (url) {
    return $sce.trustAsResourceUrl(url);
  };
}]);
;angular.module('app').directive('snAutofocus', ['$timeout', function ($timeout) {
  return {
    restrict: 'A',
    scope: {
      shouldFocus: "="
    },
    link: function link($scope, $element) {
      $timeout(function () {
        if ($scope.shouldFocus) {
          $element[0].focus();
        }
      });
    }
  };
}]);
;angular.module('app').directive('clickOutside', ['$document', function ($document) {
  return {
    restrict: 'A',
    replace: false,
    link: function link($scope, $element, attrs) {

      var didApplyClickOutside = false;

      $element.bind('click', function (e) {
        didApplyClickOutside = false;
        if (attrs.isOpen) {
          e.stopPropagation();
        }
      });

      $document.bind('click', function () {
        if (!didApplyClickOutside) {
          $scope.$apply(attrs.clickOutside);
          didApplyClickOutside = true;
        }
      });
    }
  };
}]);
;angular.module('app').directive('delayHide', function ($timeout) {
  return {
    restrict: 'A',
    scope: {
      show: '=',
      delay: '@'
    },
    link: function link(scope, elem, attrs) {
      var showTimer;

      showElement(false);

      //This is where all the magic happens!
      // Whenever the scope variable updates we simply
      // show if it evaluates to 'true' and hide if 'false'
      scope.$watch('show', function (newVal) {
        newVal ? showSpinner() : hideSpinner();
      });

      function showSpinner() {
        if (scope.hidePromise) {
          $timeout.cancel(scope.hidePromise);
          scope.hidePromise = null;
        }
        showElement(true);
      }

      function hideSpinner() {
        scope.hidePromise = $timeout(showElement.bind(this, false), getDelay());
      }

      function showElement(show) {
        show ? elem.css({ display: '' }) : elem.css({ display: 'none' });
      }

      function getDelay() {
        var delay = parseInt(scope.delay);

        return angular.isNumber(delay) ? delay : 200;
      }
    }

  };
});
;angular.module('app').directive('elemReady', function ($parse) {
  return {
    restrict: 'A',
    link: function link($scope, elem, attrs) {
      elem.ready(function () {
        $scope.$apply(function () {
          var func = $parse(attrs.elemReady);
          func($scope);
        });
      });
    }
  };
});angular.module('app').directive('fileChange', function () {
  return {
    restrict: 'A',
    scope: {
      handler: '&'
    },
    link: function link(scope, element) {
      element.on('change', function (event) {
        scope.$apply(function () {
          scope.handler({ files: event.target.files });
        });
      });
    }
  };
});
;angular.module('app').directive('infiniteScroll', ['$rootScope', '$window', '$timeout', function ($rootScope, $window, $timeout) {
  return {
    link: function link(scope, elem, attrs) {
      var offset = parseInt(attrs.threshold) || 0;
      var e = elem[0];

      elem.on('scroll', function () {
        if (scope.$eval(attrs.canLoad) && e.scrollTop + e.offsetHeight >= e.scrollHeight - offset) {
          scope.$apply(attrs.infiniteScroll);
        }
      });
    }
  };
}]);
;angular.module('app').directive('lowercase', function () {
  return {
    require: 'ngModel',
    link: function link(scope, element, attrs, modelCtrl) {
      var lowercase = function lowercase(inputValue) {
        if (inputValue == undefined) inputValue = '';
        var lowercased = inputValue.toLowerCase();
        if (lowercased !== inputValue) {
          modelCtrl.$setViewValue(lowercased);
          modelCtrl.$render();
        }
        return lowercased;
      };
      modelCtrl.$parsers.push(lowercase);
      lowercase(scope[attrs.ngModel]);
    }
  };
});
;angular.module('app').directive('selectOnClick', ['$window', function ($window) {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.on('focus', function () {
        if (!$window.getSelection().toString()) {
          // Required for mobile Safari
          this.setSelectionRange(0, this.value.length);
        }
      });
    }
  };
}]);
;angular.module('app').directive('snEnter', function () {
  return function (scope, element, attrs) {
    element.bind("keydown keypress", function (event) {
      if (event.which === 13) {
        scope.$apply(function () {
          scope.$eval(attrs.snEnter, { 'event': event });
        });

        event.preventDefault();
      }
    });
  };
});
;
var AccountMenu = function () {
  function AccountMenu() {
    (0, _classCallCheck4.default)(this, AccountMenu);

    this.restrict = "E";
    this.templateUrl = "directives/account-menu.html";
    this.scope = {
      "onSuccessfulAuth": "&",
      "closeFunction": "&"
    };
  }

  (0, _createClass4.default)(AccountMenu, [{
    key: "controller",
    value: function controller($scope, $rootScope, authManager, modelManager, syncManager, storageManager, dbManager, passcodeManager, $timeout, $compile, archiveManager, privilegesManager, appVersion) {
      'ngInject';

      $scope.appVersion = "v" + appVersion;
      $scope.formData = { mergeLocal: true, ephemeral: false };

      $scope.user = authManager.user;

      syncManager.getServerURL().then(function (url) {
        $timeout(function () {
          $scope.server = url;
          $scope.formData.url = url;
        });
      });

      authManager.checkForSecurityUpdate().then(function (available) {
        $scope.securityUpdateAvailable = available;
      });

      $scope.close = function () {
        $timeout(function () {
          $scope.closeFunction()();
        });
      };

      $scope.encryptedBackupsAvailable = function () {
        return authManager.user || passcodeManager.hasPasscode();
      };

      $scope.canAddPasscode = !authManager.isEphemeralSession();
      $scope.syncStatus = syncManager.syncStatus;

      $scope.submitMfaForm = function () {
        var params = {};
        params[$scope.formData.mfa.payload.mfa_key] = $scope.formData.userMfaCode;
        $scope.login(params);
      };

      $scope.submitAuthForm = function () {
        if (!$scope.formData.email || !$scope.formData.user_password) {
          return;
        }
        if ($scope.formData.showLogin) {
          $scope.login();
        } else {
          $scope.register();
        }
      };

      $scope.login = function (extraParams) {
        // Prevent a timed sync from occuring while signing in. There may be a race condition where when
        // calling `markAllItemsDirtyAndSaveOffline` during sign in, if an authenticated sync happens to occur
        // right before that's called, items retreived from that sync will be marked as dirty, then resynced, causing mass duplication.
        // Unlock sync after all sign in processes are complete.
        syncManager.lockSyncing();

        $scope.formData.status = "Generating Login Keys...";
        $scope.formData.authenticating = true;
        $timeout(function () {
          authManager.login($scope.formData.url, $scope.formData.email, $scope.formData.user_password, $scope.formData.ephemeral, $scope.formData.strictSignin, extraParams).then(function (response) {
            $timeout(function () {
              if (!response || response.error) {

                syncManager.unlockSyncing();

                $scope.formData.status = null;
                var error = response ? response.error : { message: "An unknown error occured."

                  // MFA Error
                };if (error.tag == "mfa-required" || error.tag == "mfa-invalid") {
                  $scope.formData.showLogin = false;
                  $scope.formData.mfa = error;
                }
                // General Error
                else {
                    $scope.formData.showLogin = true;
                    $scope.formData.mfa = null;
                    if (error.message) {
                      alert(error.message);
                    }
                  }

                $scope.formData.authenticating = false;
              }
              // Success
              else {
                  $scope.onAuthSuccess(function () {
                    syncManager.unlockSyncing();
                    syncManager.sync({ performIntegrityCheck: true });
                  });
                }
            });
          });
        });
      };

      $scope.register = function () {
        var confirmation = $scope.formData.password_conf;
        if (confirmation !== $scope.formData.user_password) {
          alert("The two passwords you entered do not match. Please try again.");
          return;
        }

        $scope.formData.confirmPassword = false;
        $scope.formData.status = "Generating Account Keys...";
        $scope.formData.authenticating = true;

        $timeout(function () {
          authManager.register($scope.formData.url, $scope.formData.email, $scope.formData.user_password, $scope.formData.ephemeral).then(function (response) {
            $timeout(function () {
              if (!response || response.error) {
                $scope.formData.status = null;
                var error = response ? response.error : { message: "An unknown error occured." };
                $scope.formData.authenticating = false;
                alert(error.message);
              } else {
                $scope.onAuthSuccess(function () {
                  syncManager.sync();
                });
              }
            });
          });
        });
      };

      $scope.mergeLocalChanged = function () {
        if (!$scope.formData.mergeLocal) {
          if (!confirm("Unchecking this option means any of the notes you have written while you were signed out will be deleted. Are you sure you want to discard these notes?")) {
            $scope.formData.mergeLocal = true;
          }
        }
      };

      $scope.onAuthSuccess = function (callback) {
        var block = function block() {
          $timeout(function () {
            $scope.formData.authenticating = false;
            $scope.onSuccessfulAuth()();
            syncManager.refreshErroredItems();
            callback && callback();
          });
        };

        if ($scope.formData.mergeLocal) {
          // Allows desktop to make backup file
          $rootScope.$broadcast("major-data-change");
          $scope.clearDatabaseAndRewriteAllItems(true, block);
        } else {
          modelManager.removeAllItemsFromMemory();
          storageManager.clearAllModels().then(function () {
            block();
          });
        }
      };

      $scope.openPasswordWizard = function (type) {
        // Close the account menu
        $scope.close();
        authManager.presentPasswordWizard(type);
      };

      $scope.openPrivilegesModal = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee61() {
        var run;
        return _regenerator2.default.wrap(function _callee61$(_context61) {
          while (1) {
            switch (_context61.prev = _context61.next) {
              case 0:
                $scope.close();

                run = function run() {
                  $timeout(function () {
                    privilegesManager.presentPrivilegesManagementModal();
                  });
                };

                _context61.next = 4;
                return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManagePrivileges);

              case 4:
                if (!_context61.sent) {
                  _context61.next = 8;
                  break;
                }

                privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManagePrivileges, function () {
                  run();
                });
                _context61.next = 9;
                break;

              case 8:
                run();

              case 9:
              case "end":
                return _context61.stop();
            }
          }
        }, _callee61, this);
      }));

      // Allows indexeddb unencrypted logs to be deleted
      // clearAllModels will remove data from backing store, but not from working memory
      // See: https://github.com/standardnotes/desktop/issues/131
      $scope.clearDatabaseAndRewriteAllItems = function (alternateUuids, callback) {
        storageManager.clearAllModels().then(function () {
          syncManager.markAllItemsDirtyAndSaveOffline(alternateUuids).then(function () {
            callback && callback();
          });
        });
      };

      $scope.destroyLocalData = function () {
        if (!confirm("Are you sure you want to end your session? This will delete all local items and extensions.")) {
          return;
        }

        authManager.signout(true).then(function () {
          window.location.reload();
        });
      };

      /* Import/Export */

      $scope.archiveFormData = { encrypted: $scope.encryptedBackupsAvailable() ? true : false };
      $scope.user = authManager.user;

      $scope.submitImportPassword = function () {
        $scope.performImport($scope.importData.data, $scope.importData.password);
      };

      $scope.performImport = function (data, password) {
        $scope.importData.loading = true;
        // allow loading indicator to come up with timeout
        $timeout(function () {
          $scope.importJSONData(data, password, function (response, errorCount) {
            $timeout(function () {
              $scope.importData.loading = false;
              $scope.importData = null;

              // Update UI before showing alert
              setTimeout(function () {
                // Response can be null if syncing offline
                if (response && response.error) {
                  alert("There was an error importing your data. Please try again.");
                } else {
                  if (errorCount > 0) {
                    var message = "Import complete. " + errorCount + " items were not imported because there was an error decrypting them. Make sure the password is correct and try again.";
                    alert(message);
                  } else {
                    alert("Your data has been successfully imported.");
                  }
                }
              }, 10);
            });
          });
        });
      };

      $scope.importFileSelected = function () {
        var _ref64 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee62(files) {
          var run;
          return _regenerator2.default.wrap(function _callee62$(_context62) {
            while (1) {
              switch (_context62.prev = _context62.next) {
                case 0:
                  run = function run() {
                    $timeout(function () {
                      $scope.importData = {};

                      var file = files[0];
                      var reader = new FileReader();
                      reader.onload = function (e) {
                        try {
                          var data = JSON.parse(e.target.result);
                          $timeout(function () {
                            if (data.auth_params) {
                              // request password
                              $scope.importData.requestPassword = true;
                              $scope.importData.data = data;

                              $timeout(function () {
                                var element = document.getElementById("import-password-request");
                                if (element) {
                                  element.scrollIntoView(false);
                                }
                              });
                            } else {
                              $scope.performImport(data, null);
                            }
                          });
                        } catch (e) {
                          alert("Unable to open file. Ensure it is a proper JSON file and try again.");
                        }
                      };

                      reader.readAsText(file);
                    });
                  };

                  _context62.next = 3;
                  return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManageBackups);

                case 3:
                  if (!_context62.sent) {
                    _context62.next = 7;
                    break;
                  }

                  privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManageBackups, function () {
                    run();
                  });
                  _context62.next = 8;
                  break;

                case 7:
                  run();

                case 8:
                case "end":
                  return _context62.stop();
              }
            }
          }, _callee62, this);
        }));

        return function (_x89) {
          return _ref64.apply(this, arguments);
        };
      }();

      $scope.importJSONData = function (data, password, callback) {
        var _this97 = this;

        var onDataReady = function () {
          var _ref65 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee63(errorCount) {
            var items, _iteratorNormalCompletion71, _didIteratorError71, _iteratorError71, _iterator71, _step71, item;

            return _regenerator2.default.wrap(function _callee63$(_context63) {
              while (1) {
                switch (_context63.prev = _context63.next) {
                  case 0:
                    _context63.next = 2;
                    return modelManager.importItems(data.items);

                  case 2:
                    items = _context63.sent;
                    _iteratorNormalCompletion71 = true;
                    _didIteratorError71 = false;
                    _iteratorError71 = undefined;
                    _context63.prev = 6;

                    for (_iterator71 = items[Symbol.iterator](); !(_iteratorNormalCompletion71 = (_step71 = _iterator71.next()).done); _iteratorNormalCompletion71 = true) {
                      item = _step71.value;

                      // We don't want to activate any components during import process in case of exceptions
                      // breaking up the import proccess
                      if (item.content_type == "SN|Component") {
                        item.active = false;
                      }
                    }

                    _context63.next = 14;
                    break;

                  case 10:
                    _context63.prev = 10;
                    _context63.t0 = _context63["catch"](6);
                    _didIteratorError71 = true;
                    _iteratorError71 = _context63.t0;

                  case 14:
                    _context63.prev = 14;
                    _context63.prev = 15;

                    if (!_iteratorNormalCompletion71 && _iterator71.return) {
                      _iterator71.return();
                    }

                  case 17:
                    _context63.prev = 17;

                    if (!_didIteratorError71) {
                      _context63.next = 20;
                      break;
                    }

                    throw _iteratorError71;

                  case 20:
                    return _context63.finish(17);

                  case 21:
                    return _context63.finish(14);

                  case 22:
                    syncManager.sync().then(function (response) {
                      // Response can be null if syncing offline
                      callback(response, errorCount);
                    });

                  case 23:
                  case "end":
                    return _context63.stop();
                }
              }
            }, _callee63, _this97, [[6, 10, 14, 22], [15,, 17, 21]]);
          }));

          return function onDataReady(_x90) {
            return _ref65.apply(this, arguments);
          };
        }();

        if (data.auth_params) {
          SFJS.crypto.computeEncryptionKeysForUser(password, data.auth_params).then(function (keys) {
            try {
              SFJS.itemTransformer.decryptMultipleItems(data.items, keys, false) /* throws = false as we don't want to interrupt all decryption if just one fails */
              .then(function () {
                // delete items enc_item_key since the user's actually key will do the encrypting once its passed off
                data.items.forEach(function (item) {
                  item.enc_item_key = null;
                  item.auth_hash = null;
                });

                var errorCount = 0;
                // Don't import items that didn't decrypt properly
                data.items = data.items.filter(function (item) {
                  if (item.errorDecrypting) {
                    errorCount++;
                    return false;
                  }
                  return true;
                });

                onDataReady(errorCount);
              });
            } catch (e) {
              console.log("Error decrypting", e);
              alert("There was an error decrypting your items. Make sure the password you entered is correct and try again.");
              callback(null);
              return;
            }
          });
        } else {
          onDataReady();
        }
      };

      /*
      Export
      */

      $scope.downloadDataArchive = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee64() {
        return _regenerator2.default.wrap(function _callee64$(_context64) {
          while (1) {
            switch (_context64.prev = _context64.next) {
              case 0:
                archiveManager.downloadBackup($scope.archiveFormData.encrypted);

              case 1:
              case "end":
                return _context64.stop();
            }
          }
        }, _callee64, this);
      }));

      /*
      Encryption Status
      */

      $scope.notesAndTagsCount = function () {
        var items = modelManager.allItemsMatchingTypes(["Note", "Tag"]);
        return items.length;
      };

      $scope.encryptionStatusForNotes = function () {
        var length = $scope.notesAndTagsCount();
        return length + "/" + length + " notes and tags encrypted";
      };

      $scope.encryptionEnabled = function () {
        return passcodeManager.hasPasscode() || !authManager.offline();
      };

      $scope.encryptionSource = function () {
        if (!authManager.offline()) {
          return "Account keys";
        } else if (passcodeManager.hasPasscode()) {
          return "Local Passcode";
        } else {
          return null;
        }
      };

      $scope.encryptionStatusString = function () {
        if (!authManager.offline()) {
          return "End-to-end encryption is enabled. Your data is encrypted before syncing to your private account.";
        } else if (passcodeManager.hasPasscode()) {
          return "Encryption is enabled. Your data is encrypted using your passcode before saving to your device storage.";
        } else {
          return "Encryption is not enabled. Sign in, register, or add a passcode lock to enable encryption.";
        }
      };

      /*
      Passcode Lock
      */

      $scope.passcodeAutoLockOptions = passcodeManager.getAutoLockIntervalOptions();

      $scope.reloadAutoLockInterval = function () {
        passcodeManager.getAutoLockInterval().then(function (interval) {
          $timeout(function () {
            $scope.selectedAutoLockInterval = interval;
          });
        });
      };

      $scope.reloadAutoLockInterval();

      $scope.selectAutoLockInterval = function () {
        var _ref67 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee66(interval) {
          var _this98 = this;

          var run;
          return _regenerator2.default.wrap(function _callee66$(_context66) {
            while (1) {
              switch (_context66.prev = _context66.next) {
                case 0:
                  run = function () {
                    var _ref68 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee65() {
                      return _regenerator2.default.wrap(function _callee65$(_context65) {
                        while (1) {
                          switch (_context65.prev = _context65.next) {
                            case 0:
                              _context65.next = 2;
                              return passcodeManager.setAutoLockInterval(interval);

                            case 2:
                              $timeout(function () {
                                $scope.reloadAutoLockInterval();
                              });

                            case 3:
                            case "end":
                              return _context65.stop();
                          }
                        }
                      }, _callee65, _this98);
                    }));

                    return function run() {
                      return _ref68.apply(this, arguments);
                    };
                  }();

                  _context66.next = 3;
                  return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManagePasscode);

                case 3:
                  if (!_context66.sent) {
                    _context66.next = 7;
                    break;
                  }

                  privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManagePasscode, function () {
                    run();
                  });
                  _context66.next = 8;
                  break;

                case 7:
                  run();

                case 8:
                case "end":
                  return _context66.stop();
              }
            }
          }, _callee66, this);
        }));

        return function (_x91) {
          return _ref67.apply(this, arguments);
        };
      }();

      $scope.hasPasscode = function () {
        return passcodeManager.hasPasscode();
      };

      $scope.addPasscodeClicked = function () {
        $scope.formData.showPasscodeForm = true;
      };

      $scope.submitPasscodeForm = function () {
        var passcode = $scope.formData.passcode;
        if (passcode !== $scope.formData.confirmPasscode) {
          alert("The two passcodes you entered do not match. Please try again.");
          return;
        }

        var fn = $scope.formData.changingPasscode ? passcodeManager.changePasscode.bind(passcodeManager) : passcodeManager.setPasscode.bind(passcodeManager);

        fn(passcode, function () {
          $timeout(function () {
            $scope.formData.passcode = null;
            $scope.formData.confirmPasscode = null;
            $scope.formData.showPasscodeForm = false;
            var offline = authManager.offline();

            if (offline) {
              // Allows desktop to make backup file
              $rootScope.$broadcast("major-data-change");
              $scope.clearDatabaseAndRewriteAllItems(false);
            }
          });
        });
      };

      $scope.changePasscodePressed = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee67() {
        var run;
        return _regenerator2.default.wrap(function _callee67$(_context67) {
          while (1) {
            switch (_context67.prev = _context67.next) {
              case 0:
                run = function run() {
                  $timeout(function () {
                    $scope.formData.changingPasscode = true;
                    $scope.addPasscodeClicked();
                  });
                };

                _context67.next = 3;
                return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManagePasscode);

              case 3:
                if (!_context67.sent) {
                  _context67.next = 7;
                  break;
                }

                privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManagePasscode, function () {
                  run();
                });
                _context67.next = 8;
                break;

              case 7:
                run();

              case 8:
              case "end":
                return _context67.stop();
            }
          }
        }, _callee67, this);
      }));

      $scope.removePasscodePressed = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee68() {
        var run;
        return _regenerator2.default.wrap(function _callee68$(_context68) {
          while (1) {
            switch (_context68.prev = _context68.next) {
              case 0:
                run = function run() {
                  $timeout(function () {
                    var signedIn = !authManager.offline();
                    var message = "Are you sure you want to remove your local passcode?";
                    if (!signedIn) {
                      message += " This will remove encryption from your local data.";
                    }
                    if (confirm(message)) {
                      passcodeManager.clearPasscode();

                      if (authManager.offline()) {
                        syncManager.markAllItemsDirtyAndSaveOffline();
                        // Don't create backup here, as if the user is temporarily removing the passcode to change it,
                        // we don't want to write unencrypted data to disk.
                        // $rootScope.$broadcast("major-data-change");
                      }
                    }
                  });
                };

                _context68.next = 3;
                return privilegesManager.actionRequiresPrivilege(PrivilegesManager.ActionManagePasscode);

              case 3:
                if (!_context68.sent) {
                  _context68.next = 7;
                  break;
                }

                privilegesManager.presentPrivilegesModal(PrivilegesManager.ActionManagePasscode, function () {
                  run();
                });
                _context68.next = 8;
                break;

              case 7:
                run();

              case 8:
              case "end":
                return _context68.stop();
            }
          }
        }, _callee68, this);
      }));

      $scope.isDesktopApplication = function () {
        return isDesktopApplication();
      };
    }
  }]);
  return AccountMenu;
}();

angular.module('app').directive('accountMenu', function () {
  return new AccountMenu();
});
;
var ActionsMenu = function () {
  function ActionsMenu() {
    (0, _classCallCheck4.default)(this, ActionsMenu);

    this.restrict = "E";
    this.templateUrl = "directives/actions-menu.html";
    this.scope = {
      item: "="
    };
  }

  (0, _createClass4.default)(ActionsMenu, [{
    key: "controller",
    value: function controller($scope, modelManager, actionsManager) {
      'ngInject';

      $scope.extensions = actionsManager.extensions.sort(function (a, b) {
        return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
      });

      var _loop9 = function _loop9(ext) {
        ext.loading = true;
        actionsManager.loadExtensionInContextOfItem(ext, $scope.item, function (scopedExtension) {
          ext.loading = false;
        });
      };

      var _iteratorNormalCompletion72 = true;
      var _didIteratorError72 = false;
      var _iteratorError72 = undefined;

      try {
        for (var _iterator72 = $scope.extensions[Symbol.iterator](), _step72; !(_iteratorNormalCompletion72 = (_step72 = _iterator72.next()).done); _iteratorNormalCompletion72 = true) {
          var ext = _step72.value;

          _loop9(ext);
        }
      } catch (err) {
        _didIteratorError72 = true;
        _iteratorError72 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion72 && _iterator72.return) {
            _iterator72.return();
          }
        } finally {
          if (_didIteratorError72) {
            throw _iteratorError72;
          }
        }
      }

      $scope.executeAction = function (action, extension, parentAction) {
        if (action.verb == "nested") {
          if (!action.subrows) {
            action.subrows = $scope.subRowsForAction(action, extension);
          } else {
            action.subrows = null;
          }
          return;
        }

        action.running = true;
        actionsManager.executeAction(action, extension, $scope.item, function (response, error) {
          if (error) {
            return;
          }

          action.running = false;
          $scope.handleActionResponse(action, response);

          // reload extension actions
          actionsManager.loadExtensionInContextOfItem(extension, $scope.item, function (ext) {
            // keep nested state
            // 4/1/2019: We're not going to do this anymore because we're no longer using nested actions for version history,
            // and also because finding the parentAction based on only label is not good enough. Two actions can have same label.
            // We'd need a way to track actions after they are reloaded, but there's no good way to do this.
            // if(parentAction) {
            //   var matchingAction = _.find(ext.actions, {label: parentAction.label});
            //   matchingAction.subrows = $scope.subRowsForAction(parentAction, extension);
            // }
          });
        });
      };

      $scope.handleActionResponse = function (action, response) {
        switch (action.verb) {
          case "render":
            {
              var item = response.item;
              actionsManager.presentRevisionPreviewModal(item.uuid, item.content);
            }
        }
      };

      $scope.subRowsForAction = function (parentAction, extension) {
        var _this99 = this;

        if (!parentAction.subactions) {
          return null;
        }
        return parentAction.subactions.map(function (subaction) {
          return {
            onClick: function onClick() {
              _this99.executeAction(subaction, extension, parentAction);
            },
            label: subaction.label,
            subtitle: subaction.desc,
            spinnerClass: subaction.running ? 'info' : null
          };
        });
      };
    }
  }]);
  return ActionsMenu;
}();

angular.module('app').directive('actionsMenu', function () {
  return new ActionsMenu();
});
;
var ComponentModal = function () {
  function ComponentModal() {
    (0, _classCallCheck4.default)(this, ComponentModal);

    this.restrict = "E";
    this.templateUrl = "directives/component-modal.html";
    this.scope = {
      show: "=",
      component: "=",
      callback: "=",
      onDismiss: "&"
    };
  }

  (0, _createClass4.default)(ComponentModal, [{
    key: "link",
    value: function link($scope, el, attrs) {
      $scope.el = el;
    }
  }, {
    key: "controller",
    value: function controller($scope, $timeout, componentManager) {
      'ngInject';

      $scope.dismiss = function (callback) {
        $scope.el.remove();
        $scope.$destroy();
        $scope.onDismiss && $scope.onDismiss() && $scope.onDismiss()($scope.component);
        callback && callback();
      };
    }
  }]);
  return ComponentModal;
}();

angular.module('app').directive('componentModal', function () {
  return new ComponentModal();
});
;
var ComponentView = function () {
  function ComponentView($rootScope, componentManager, desktopManager, $timeout, themeManager) {
    (0, _classCallCheck4.default)(this, ComponentView);

    this.restrict = "E";
    this.templateUrl = "directives/component-view.html";
    this.scope = {
      component: "=",
      onLoad: "=?",
      manualDealloc: "=?"
    };

    this.desktopManager = desktopManager;
  }

  (0, _createClass4.default)(ComponentView, [{
    key: "link",
    value: function link($scope, el, attrs, ctrl) {
      $scope.el = el;

      $scope.componentValid = true;

      $scope.updateObserver = this.desktopManager.registerUpdateObserver(function (component) {
        if (component == $scope.component && component.active) {
          $scope.reloadComponent();
        }
      });

      $scope.$watch('component', function (component, prevComponent) {
        ctrl.componentValueChanging(component, prevComponent);
      });
    }
  }, {
    key: "controller",
    value: function controller($scope, $rootScope, $timeout, componentManager, desktopManager, themeManager) {
      'ngInject';

      $scope.onVisibilityChange = function () {
        if (document.visibilityState == "hidden") {
          return;
        }

        if ($scope.issueLoading) {
          $scope.reloadComponent();
        }
      };

      $scope.themeHandlerIdentifier = "component-view-" + Math.random();
      componentManager.registerHandler({ identifier: $scope.themeHandlerIdentifier, areas: ["themes"], activationHandler: function activationHandler(component) {
          $scope.reloadThemeStatus();
        } });

      $scope.identifier = "component-view-" + Math.random();

      componentManager.registerHandler({
        identifier: $scope.identifier,
        areas: [$scope.component.area],
        activationHandler: function activationHandler(component) {
          if (component !== $scope.component) {
            return;
          }

          $timeout(function () {
            $scope.handleActivation();
          });
        },
        actionHandler: function actionHandler(component, action, data) {
          if (action == "set-size") {
            componentManager.handleSetSizeEvent(component, data);
          }
        }
      });

      $scope.handleActivation = function () {
        // activationHandlers may be called multiple times, design below to be idempotent
        var component = $scope.component;
        if (!component.active) {
          return;
        }

        var iframe = componentManager.iframeForComponent(component);
        if (iframe) {
          $scope.loading = true;
          // begin loading error handler. If onload isn't called in x seconds, display an error
          if ($scope.loadTimeout) {
            $timeout.cancel($scope.loadTimeout);
          }
          $scope.loadTimeout = $timeout(function () {
            if ($scope.loading) {
              $scope.loading = false;
              $scope.issueLoading = true;

              if (!$scope.didAttemptReload) {
                $scope.didAttemptReload = true;
                $scope.reloadComponent();
              } else {
                // We'll attempt to reload when the tab gains focus
                document.addEventListener("visibilitychange", $scope.onVisibilityChange);
              }
            }
          }, 3500);
          iframe.onload = function (event) {
            var desktopError = false;
            try {
              // Accessing iframe.contentWindow.origin will throw an exception if we are in the web app, or if the iframe content
              // is remote content. The only reason it works in this case is because we're accessing a local extension.
              // In the future when the desktop app falls back to the web location if local fail loads, we won't be able to access this property anymore.
              if (isDesktopApplication() && (iframe.contentWindow.origin == null || iframe.contentWindow.origin == 'null')) {
                /*
                Don't attempt reload in this case, as it results in infinite loop, since a reload will deactivate the extension and then reactivate.
                This can cause this componentView to be dealloced and a new one to be instantiated. This happens in editor.js, which we'll need to look into.
                Don't return from this clause either, since we don't want to cancel loadTimeout (that will trigger reload). Instead, handle custom fail logic here.
                */
                desktopError = true;
              }
            } catch (e) {}

            $timeout.cancel($scope.loadTimeout);
            componentManager.registerComponentWindow(component, iframe.contentWindow).then(function () {
              // Add small timeout to, as $scope.loading controls loading overlay,
              // which is used to avoid flicker when enabling extensions while having an enabled theme
              // we don't use ng-show because it causes problems with rendering iframes after timeout, for some reason.
              $timeout(function () {
                $scope.loading = false;
                $scope.issueLoading = desktopError; /* Typically we'd just set this to false at this point, but we now account for desktopError */
                $scope.onLoad && $scope.onLoad($scope.component);
              }, 7);
            });
          };
        }
      };

      /*
      General note regarding activation/deactivation of components:
      We pass `true` to componentManager.ac/detivateComponent for the `dontSync` parameter.
      The activation we do in here is not global, but just local, so we don't need to sync the state.
      For example, if we activate an editor, we just need to do that for display purposes, but dont
      need to perform a sync to propagate that .active flag.
      */

      this.componentValueChanging = function (component, prevComponent) {
        //
        // See comment above about passing true to componentManager.ac/detivateComponent
        //
        if (prevComponent && component !== prevComponent) {
          // Deactive old component
          componentManager.deactivateComponent(prevComponent, true);
        }

        if (component) {
          componentManager.activateComponent(component, true);
          // console.log("Loading", $scope.component.name, $scope.getUrl(), component.valid_until);

          $scope.reloadStatus();
        }
      };

      $scope.$on("ext-reload-complete", function () {
        $scope.reloadStatus(false);
      });

      $scope.reloadComponent = function () {
        // console.log("Reloading component", $scope.component);
        // force iFrame to deinit, allows new one to be created
        $scope.componentValid = false;
        componentManager.reloadComponent($scope.component).then(function () {
          $scope.reloadStatus();
        });
      };

      $scope.reloadStatus = function () {
        var doManualReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var component = $scope.component;
        $scope.reloading = true;
        var previouslyValid = $scope.componentValid;

        var offlineRestricted = component.offlineOnly && !isDesktopApplication();

        var urlError = !isDesktopApplication() && !component.hasValidHostedUrl() || isDesktopApplication() && !component.local_url && !component.hasValidHostedUrl();

        $scope.expired = component.valid_until && component.valid_until <= new Date();

        // Here we choose our own readonly state based on custom logic. However, if a parent
        // wants to implement their own readonly logic, they can lock it.
        if (!component.lockReadonly) {
          component.readonly = $scope.expired;
        }

        $scope.componentValid = !offlineRestricted && !urlError;

        if (!$scope.componentValid) {
          // required to disable overlay
          $scope.loading = false;
        }

        if (offlineRestricted) $scope.error = 'offline-restricted';else if (urlError) $scope.error = 'url-missing';else $scope.error = null;

        if ($scope.componentValid !== previouslyValid) {
          if ($scope.componentValid) {
            // We want to reload here, rather than `activateComponent`, because the component will already have attempted to been activated.
            componentManager.reloadComponent(component, true);
          }
        }

        if ($scope.expired && doManualReload) {
          // Try reloading, handled by footer, which will open Extensions window momentarily to pull in latest data
          // Upon completion, this method, reloadStatus, will be called, upon where doManualReload will be false to prevent recursion.
          $rootScope.$broadcast("reload-ext-data");
        }

        $scope.reloadThemeStatus();

        $timeout(function () {
          $scope.reloading = false;
        }, 500);
      };

      $scope.reloadThemeStatus = function () {
        if (!$scope.component.acceptsThemes()) {
          if (themeManager.hasActiveTheme()) {
            if (!$scope.dismissedNoThemesMessage) {
              $scope.showNoThemesMessage = true;
            }
          } else {
            // Can be the case if we've just deactivated a theme
            $scope.showNoThemesMessage = false;
          }
        }
      };

      $scope.noThemesMessageDismiss = function () {
        $scope.showNoThemesMessage = false;
        $scope.dismissedNoThemesMessage = true;
      };

      $scope.disableActiveTheme = function () {
        themeManager.deactivateAllThemes();
        $scope.noThemesMessageDismiss();
      };

      $scope.getUrl = function () {
        var url = componentManager.urlForComponent($scope.component);
        $scope.component.runningLocally = url == $scope.component.local_url;
        return url;
      };

      $scope.destroy = function () {
        componentManager.deregisterHandler($scope.themeHandlerIdentifier);
        componentManager.deregisterHandler($scope.identifier);
        if ($scope.component && !$scope.manualDealloc) {
          componentManager.deactivateComponent($scope.component, true);
        }

        desktopManager.deregisterUpdateObserver($scope.updateObserver);
        document.removeEventListener("visibilitychange", $scope.onVisibilityChange);
      };

      $scope.$on("$destroy", function () {
        $scope.destroy();
      });
    }
  }]);
  return ComponentView;
}();

angular.module('app').directive('componentView', function ($rootScope, componentManager, desktopManager, $timeout) {
  return new ComponentView($rootScope, componentManager, desktopManager, $timeout);
});
; /*
   The purpose of the conflict resoltion modal is to present two versions of a conflicted item,
   and allow the user to choose which to keep (or to keep both.)
  */

var ConflictResolutionModal = function () {
  function ConflictResolutionModal() {
    (0, _classCallCheck4.default)(this, ConflictResolutionModal);

    this.restrict = "E";
    this.templateUrl = "directives/conflict-resolution-modal.html";
    this.scope = {
      item1: "=",
      item2: "=",
      callback: "="
    };
  }

  (0, _createClass4.default)(ConflictResolutionModal, [{
    key: "link",
    value: function link($scope, el, attrs) {

      $scope.dismiss = function () {
        el.remove();
      };
    }
  }, {
    key: "controller",
    value: function controller($scope, modelManager, syncManager, archiveManager) {
      'ngInject';

      $scope.createContentString = function (item) {
        return JSON.stringify(Object.assign({ created_at: item.created_at, updated_at: item.updated_at }, item.content), null, 2);
      };

      $scope.contentType = $scope.item1.content_type;

      $scope.item1Content = $scope.createContentString($scope.item1);
      $scope.item2Content = $scope.createContentString($scope.item2);

      $scope.keepItem1 = function () {
        if (!confirm("Are you sure you want to delete the item on the right?")) {
          return;
        }
        modelManager.setItemToBeDeleted($scope.item2);
        syncManager.sync().then(function () {
          $scope.applyCallback();
        });

        $scope.dismiss();
      };

      $scope.keepItem2 = function () {
        if (!confirm("Are you sure you want to delete the item on the left?")) {
          return;
        }
        modelManager.setItemToBeDeleted($scope.item1);
        syncManager.sync().then(function () {
          $scope.applyCallback();
        });

        $scope.dismiss();
      };

      $scope.keepBoth = function () {
        $scope.applyCallback();
        $scope.dismiss();
      };

      $scope.export = function () {
        archiveManager.downloadBackupOfItems([$scope.item1, $scope.item2], true);
      };

      $scope.applyCallback = function () {
        $scope.callback && $scope.callback();
      };
    }
  }]);
  return ConflictResolutionModal;
}();

angular.module('app').directive('conflictResolutionModal', function () {
  return new ConflictResolutionModal();
});
;
var EditorMenu = function () {
  function EditorMenu() {
    (0, _classCallCheck4.default)(this, EditorMenu);

    this.restrict = "E";
    this.templateUrl = "directives/editor-menu.html";
    this.scope = {
      callback: "&",
      selectedEditor: "=",
      currentItem: "="
    };
  }

  (0, _createClass4.default)(EditorMenu, [{
    key: "controller",
    value: function controller($scope, componentManager, syncManager, modelManager, $timeout) {
      'ngInject';

      $scope.formData = {};

      $scope.editors = componentManager.componentsForArea("editor-editor").sort(function (a, b) {
        return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
      });

      $scope.isDesktop = isDesktopApplication();

      $scope.defaultEditor = $scope.editors.filter(function (e) {
        return e.isDefaultEditor();
      })[0];

      $scope.selectComponent = function (component) {
        if (component) {
          if (component.content.conflict_of) {
            component.content.conflict_of = null; // clear conflict if applicable
            modelManager.setItemDirty(component, true);
            syncManager.sync();
          }
        }
        $timeout(function () {
          $scope.callback()(component);
        });
      };

      $scope.toggleDefaultForEditor = function (editor) {
        if ($scope.defaultEditor == editor) {
          $scope.removeEditorDefault(editor);
        } else {
          $scope.makeEditorDefault(editor);
        }
      };

      $scope.offlineAvailableForComponent = function (component) {
        return component.local_url && isDesktopApplication();
      };

      $scope.makeEditorDefault = function (component) {
        var currentDefault = componentManager.componentsForArea("editor-editor").filter(function (e) {
          return e.isDefaultEditor();
        })[0];
        if (currentDefault) {
          currentDefault.setAppDataItem("defaultEditor", false);
          modelManager.setItemDirty(currentDefault, true);
        }

        component.setAppDataItem("defaultEditor", true);
        modelManager.setItemDirty(component, true);
        syncManager.sync();

        $scope.defaultEditor = component;
      };

      $scope.removeEditorDefault = function (component) {
        component.setAppDataItem("defaultEditor", false);
        modelManager.setItemDirty(component, true);
        syncManager.sync();

        $scope.defaultEditor = null;
      };

      $scope.shouldDisplayRunningLocallyLabel = function (component) {
        if (!component.runningLocally) {
          return false;
        }

        if (component == $scope.selectedEditor) {
          return true;
        } else {
          return false;
        }
      };
    }
  }]);
  return EditorMenu;
}();

angular.module('app').directive('editorMenu', function () {
  return new EditorMenu();
});
;
var InputModal = function () {
  function InputModal() {
    (0, _classCallCheck4.default)(this, InputModal);

    this.restrict = "E";
    this.templateUrl = "directives/input-modal.html";
    this.scope = {
      type: "=",
      title: "=",
      message: "=",
      placeholder: "=",
      callback: "&"
    };
  }

  (0, _createClass4.default)(InputModal, [{
    key: "link",
    value: function link($scope, el, attrs) {
      $scope.el = el;
    }
  }, {
    key: "controller",
    value: function controller($scope, modelManager, archiveManager, authManager, syncManager, $timeout) {
      'ngInject';

      $scope.formData = {};

      $scope.dismiss = function () {
        $scope.el.remove();
        $scope.$destroy();
      };

      $scope.submit = function () {
        $scope.callback()($scope.formData.input);
        $scope.dismiss();
      };
    }
  }]);
  return InputModal;
}();

angular.module('app').directive('inputModal', function () {
  return new InputModal();
});
;
var MenuRow = function () {
  function MenuRow() {
    (0, _classCallCheck4.default)(this, MenuRow);

    this.restrict = "E";
    this.transclude = true;
    this.templateUrl = "directives/menu-row.html";
    this.scope = {
      action: "&",
      circle: "=",
      circleAlign: "=",
      label: "=",
      subtitle: "=",
      hasButton: "=",
      buttonText: "=",
      buttonClass: "=",
      buttonAction: "&",
      spinnerClass: "=",
      subRows: "=",
      faded: "=",
      desc: "=",
      disabled: "=",
      stylekitClass: "="
    };
  }

  (0, _createClass4.default)(MenuRow, [{
    key: "controller",
    value: function controller($scope, componentManager) {
      'ngInject';

      $scope.onClick = function ($event) {
        if ($scope.disabled) {
          return;
        }
        $event.stopPropagation();
        $scope.action();
      };

      // This is for the accessory button
      $scope.clickButton = function ($event) {
        if ($scope.disabled) {
          return;
        }
        $event.stopPropagation();
        $scope.buttonAction();
      };
    }
  }]);
  return MenuRow;
}();

angular.module('app').directive('menuRow', function () {
  return new MenuRow();
});
;
var PanelResizer = function () {
  function PanelResizer() {
    (0, _classCallCheck4.default)(this, PanelResizer);

    this.restrict = "E";
    this.templateUrl = "directives/panel-resizer.html";
    this.scope = {
      index: "=",
      panelId: "=",
      onResize: "&",
      defaultWidth: "=",
      onResizeFinish: "&",
      control: "=",
      alwaysVisible: "=",
      minWidth: "=",
      property: "=",
      hoverable: "=",
      collapsable: "="
    };
  }

  (0, _createClass4.default)(PanelResizer, [{
    key: "link",
    value: function link(scope, elem, attrs, ctrl) {
      scope.elem = elem;

      scope.control.setWidth = function (value) {
        scope.setWidth(value, true);
      };

      scope.control.setLeft = function (value) {
        scope.setLeft(value);
      };

      scope.control.flash = function () {
        scope.flash();
      };

      scope.control.isCollapsed = function () {
        return scope.isCollapsed();
      };
    }
  }, {
    key: "controller",
    value: function controller($scope, $element, modelManager, actionsManager, $timeout, $compile) {
      'ngInject';

      var panel = document.getElementById($scope.panelId);
      if (!panel) {
        console.log("Panel not found for", $scope.panelId);
      }

      var resizerColumn = $element[0];
      var resizerWidth = resizerColumn.offsetWidth;
      var minWidth = $scope.minWidth || resizerWidth;
      var pressed = false;
      var startWidth = panel.scrollWidth,
          startX = 0,
          lastDownX = 0,
          collapsed,
          lastWidth = startWidth,
          startLeft = panel.offsetLeft,
          lastLeft = startLeft;
      var appFrame;

      $scope.isAtMaxWidth = function () {
        return Math.round(lastWidth + lastLeft) == Math.round(getParentRect().width);
      };

      $scope.isCollapsed = function () {
        return lastWidth <= minWidth;
      };

      // Handle Double Click Event
      var widthBeforeLastDblClick = 0;
      resizerColumn.ondblclick = function () {
        $timeout(function () {
          var preClickCollapseState = $scope.isCollapsed();
          if (preClickCollapseState) {
            $scope.setWidth(widthBeforeLastDblClick || $scope.defaultWidth);
          } else {
            widthBeforeLastDblClick = lastWidth;
            $scope.setWidth(minWidth);
          }

          $scope.finishSettingWidth();

          var newCollapseState = !preClickCollapseState;
          $scope.onResizeFinish()(lastWidth, lastLeft, $scope.isAtMaxWidth(), newCollapseState);
        });
      };

      function getParentRect() {
        return panel.parentNode.getBoundingClientRect();
      }

      if ($scope.property == "right") {
        var handleReize = debounce(function (event) {
          reloadDefaultValues();
          handleWidthEvent();
          $timeout(function () {
            $scope.finishSettingWidth();
          });
        }, 250);

        window.addEventListener('resize', handleReize);

        $scope.$on("$destroy", function () {
          window.removeEventListener('resize', handleReize);
        });
      }

      function reloadDefaultValues() {
        startWidth = $scope.isAtMaxWidth() ? getParentRect().width : panel.scrollWidth;
        lastWidth = startWidth;
        appFrame = document.getElementById("app").getBoundingClientRect();
      }
      reloadDefaultValues();

      if ($scope.alwaysVisible) {
        resizerColumn.classList.add("always-visible");
      }

      if ($scope.hoverable) {
        resizerColumn.classList.add("hoverable");
      }

      $scope.setWidth = function (width, finish) {
        if (width < minWidth) {
          width = minWidth;
        }

        var parentRect = getParentRect();

        if (width > parentRect.width) {
          width = parentRect.width;
        }

        var maxWidth = appFrame.width - panel.getBoundingClientRect().x;
        if (width > maxWidth) {
          width = maxWidth;
        }

        if (Math.round(width + lastLeft) == Math.round(parentRect.width)) {
          panel.style.width = "calc(100% - " + lastLeft + "px)";
          panel.style.flexBasis = "calc(100% - " + lastLeft + "px)";
        } else {
          panel.style.flexBasis = width + "px";
          panel.style.width = width + "px";
        }

        lastWidth = width;

        if (finish) {
          $scope.finishSettingWidth();
        }
      };

      $scope.setLeft = function (left) {
        panel.style.left = left + "px";
        lastLeft = left;
      };

      $scope.finishSettingWidth = function () {
        if (!$scope.collapsable) {
          return;
        }

        collapsed = $scope.isCollapsed();
        if (collapsed) {
          resizerColumn.classList.add("collapsed");
        } else {
          resizerColumn.classList.remove("collapsed");
        }
      };

      /*
        If an iframe is displayed adjacent to our panel, and your mouse exits over the iframe,
        document[onmouseup] is not triggered because the document is no longer the same over the iframe.
        We add an invisible overlay while resizing so that the mouse context remains in our main document.
       */
      $scope.addInvisibleOverlay = function () {
        if ($scope.overlay) {
          return;
        }

        $scope.overlay = $compile("<div id='resizer-overlay'></div>")($scope);
        angular.element(document.body).prepend($scope.overlay);
      };

      $scope.removeInvisibleOverlay = function () {
        if ($scope.overlay) {
          $scope.overlay.remove();
          $scope.overlay = null;
        }
      };

      $scope.flash = function () {
        resizerColumn.classList.add("animate-opacity");
        $timeout(function () {
          resizerColumn.classList.remove("animate-opacity");
        }, 3000);
      };

      resizerColumn.addEventListener("mousedown", function (event) {
        $scope.addInvisibleOverlay();

        pressed = true;
        lastDownX = event.clientX;
        startWidth = panel.scrollWidth;
        startLeft = panel.offsetLeft;
        panel.classList.add("no-selection");

        if ($scope.hoverable) {
          resizerColumn.classList.add("dragging");
        }
      });

      document.addEventListener("mousemove", function (event) {
        if (!pressed) {
          return;
        }

        event.preventDefault();

        if ($scope.property && $scope.property == 'left') {
          handleLeftEvent(event);
        } else {
          handleWidthEvent(event);
        }
      });

      function handleWidthEvent(event) {
        var x = void 0;
        if (event) {
          x = event.clientX;
        } else {
          // coming from resize event
          x = 0;
          lastDownX = 0;
        }

        var deltaX = x - lastDownX;
        var newWidth = startWidth + deltaX;

        $scope.setWidth(newWidth, false);

        if ($scope.onResize()) {
          $scope.onResize()(lastWidth, panel);
        }
      }

      function handleLeftEvent(event) {
        var panelRect = panel.getBoundingClientRect();
        var x = event.clientX || panelRect.x;
        var deltaX = x - lastDownX;
        var newLeft = startLeft + deltaX;
        if (newLeft < 0) {
          newLeft = 0;
          deltaX = -startLeft;
        }

        var parentRect = getParentRect();

        var newWidth = startWidth - deltaX;
        if (newWidth < minWidth) {
          newWidth = minWidth;
        }

        if (newWidth > parentRect.width) {
          newWidth = parentRect.width;
        }

        if (newLeft + newWidth > parentRect.width) {
          newLeft = parentRect.width - newWidth;
        }

        $scope.setLeft(newLeft, false);
        $scope.setWidth(newWidth, false);
      }

      document.addEventListener("mouseup", function (event) {
        $scope.removeInvisibleOverlay();

        if (pressed) {
          pressed = false;
          resizerColumn.classList.remove("dragging");
          panel.classList.remove("no-selection");

          var isMaxWidth = $scope.isAtMaxWidth();

          if ($scope.onResizeFinish) {
            $scope.onResizeFinish()(lastWidth, lastLeft, isMaxWidth, $scope.isCollapsed());
          }

          $scope.finishSettingWidth();
        }
      });
    }
  }]);
  return PanelResizer;
}();

angular.module('app').directive('panelResizer', function () {
  return new PanelResizer();
});

/* via https://davidwalsh.name/javascript-debounce-function */
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};
;
var PasswordWizard = function () {
  function PasswordWizard() {
    (0, _classCallCheck4.default)(this, PasswordWizard);

    this.restrict = "E";
    this.templateUrl = "directives/password-wizard.html";
    this.scope = {
      type: "="
    };
  }

  (0, _createClass4.default)(PasswordWizard, [{
    key: "link",
    value: function link($scope, el, attrs) {
      $scope.el = el;
    }
  }, {
    key: "controller",
    value: function controller($scope, modelManager, archiveManager, authManager, syncManager, $timeout) {
      'ngInject';

      window.onbeforeunload = function (e) {
        // Confirms with user to close tab before closing
        return true;
      };

      $scope.$on("$destroy", function () {
        window.onbeforeunload = null;
      });

      $scope.dismiss = function () {
        if ($scope.lockContinue) {
          alert("Cannot close window until pending tasks are complete.");
          return;
        }
        $scope.el.remove();
        $scope.$destroy();
      };

      $scope.syncStatus = syncManager.syncStatus;
      $scope.formData = {};

      var IntroStep = 0;
      var BackupStep = 1;
      var SignoutStep = 2;
      var PasswordStep = 3;
      var SyncStep = 4;
      var FinishStep = 5;

      var DefaultContinueTitle = "Continue";
      $scope.continueTitle = DefaultContinueTitle;

      $scope.step = IntroStep;

      $scope.titleForStep = function (step) {
        switch (step) {
          case BackupStep:
            return "Download a backup of your data";
          case SignoutStep:
            return "Sign out of all your devices";
          case PasswordStep:
            return $scope.changePassword ? "Password information" : "Enter your current password";
          case SyncStep:
            return "Encrypt and sync data with new keys";
          case FinishStep:
            return "Sign back in to your devices";
          default:
            return null;
        }
      };

      $scope.configure = function () {
        if ($scope.type == "change-pw") {
          $scope.title = "Change Password";
          $scope.changePassword = true;
        } else if ($scope.type == "upgrade-security") {
          $scope.title = "Security Update";
          $scope.securityUpdate = true;
        }
      }();

      $scope.continue = function () {

        if ($scope.lockContinue || $scope.isContinuing) {
          return;
        }

        // isContinuing is a way to lock the continue function separate from lockContinue
        // lockContinue can be locked by other places, but isContinuing is only lockable from within this function.

        $scope.isContinuing = true;

        if ($scope.step == FinishStep) {
          $scope.dismiss();
          return;
        }

        var next = function next() {
          $scope.step += 1;
          $scope.initializeStep($scope.step);

          $scope.isContinuing = false;
        };

        var preprocessor = $scope.preprocessorForStep($scope.step);
        if (preprocessor) {
          preprocessor(function () {
            next();
          }, function () {
            // on fail
            $scope.isContinuing = false;
          });
        } else {
          next();
        }
      };

      $scope.downloadBackup = function (encrypted) {
        archiveManager.downloadBackup(encrypted);
      };

      $scope.preprocessorForStep = function (step) {
        if (step == PasswordStep) {
          return function (onSuccess, onFail) {
            $scope.showSpinner = true;
            $scope.continueTitle = "Generating Keys...";
            $timeout(function () {
              $scope.validateCurrentPassword(function (success) {
                $scope.showSpinner = false;
                $scope.continueTitle = DefaultContinueTitle;
                if (success) {
                  onSuccess();
                } else {
                  onFail && onFail();
                }
              });
            });
          };
        }
      };

      var FailedSyncMessage = "There was an error re-encrypting your items. Your password was changed, but not all your items were properly re-encrypted and synced. You should try syncing again. If all else fails, you should restore your notes from backup.";

      $scope.initializeStep = function (step) {
        if (step == SyncStep) {
          $scope.lockContinue = true;
          $scope.formData.status = "Processing encryption keys...";
          $scope.formData.processing = true;

          $scope.processPasswordChange(function (passwordSuccess) {
            $scope.formData.statusError = !passwordSuccess;
            $scope.formData.processing = passwordSuccess;

            if (passwordSuccess) {
              $scope.formData.status = "Encrypting and syncing data with new keys...";

              $scope.resyncData(function (syncSuccess) {
                $scope.formData.statusError = !syncSuccess;
                $scope.formData.processing = !syncSuccess;
                if (syncSuccess) {
                  $scope.lockContinue = false;

                  if ($scope.changePassword) {
                    $scope.formData.status = "Successfully changed password and synced all items.";
                  } else if ($scope.securityUpdate) {
                    $scope.formData.status = "Successfully performed security update and synced all items.";
                  }
                } else {
                  $scope.formData.status = FailedSyncMessage;
                }
              });
            } else {
              $scope.formData.status = "Unable to process your password. Please try again.";
            }
          });
        } else if (step == FinishStep) {
          $scope.continueTitle = "Finish";
        }
      };

      $scope.validateCurrentPassword = function () {
        var _ref71 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee70(callback) {
          var _this100 = this;

          var currentPassword, newPass, authParams, password;
          return _regenerator2.default.wrap(function _callee70$(_context70) {
            while (1) {
              switch (_context70.prev = _context70.next) {
                case 0:
                  currentPassword = $scope.formData.currentPassword;
                  newPass = $scope.securityUpdate ? currentPassword : $scope.formData.newPassword;

                  if (!(!currentPassword || currentPassword.length == 0)) {
                    _context70.next = 6;
                    break;
                  }

                  alert("Please enter your current password.");
                  callback(false);
                  return _context70.abrupt("return");

                case 6:
                  if (!$scope.changePassword) {
                    _context70.next = 16;
                    break;
                  }

                  if (!(!newPass || newPass.length == 0)) {
                    _context70.next = 11;
                    break;
                  }

                  alert("Please enter a new password.");
                  callback(false);
                  return _context70.abrupt("return");

                case 11:
                  if (!(newPass != $scope.formData.newPasswordConfirmation)) {
                    _context70.next = 16;
                    break;
                  }

                  alert("Your new password does not match its confirmation.");
                  $scope.formData.status = null;
                  callback(false);
                  return _context70.abrupt("return");

                case 16:
                  if (authManager.user.email) {
                    _context70.next = 21;
                    break;
                  }

                  alert("We don't have your email stored. Please log out then log back in to fix this issue.");
                  $scope.formData.status = null;
                  callback(false);
                  return _context70.abrupt("return");

                case 21:
                  _context70.next = 23;
                  return authManager.getAuthParams();

                case 23:
                  authParams = _context70.sent;
                  password = $scope.formData.currentPassword;

                  SFJS.crypto.computeEncryptionKeysForUser(password, authParams).then(function () {
                    var _ref72 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee69(keys) {
                      var success;
                      return _regenerator2.default.wrap(function _callee69$(_context69) {
                        while (1) {
                          switch (_context69.prev = _context69.next) {
                            case 0:
                              _context69.t0 = keys.mk;
                              _context69.next = 3;
                              return authManager.keys();

                            case 3:
                              _context69.t1 = _context69.sent.mk;
                              success = _context69.t0 === _context69.t1;

                              if (success) {
                                _this100.currentServerPw = keys.pw;
                              } else {
                                alert("The current password you entered is not correct. Please try again.");
                              }
                              $timeout(function () {
                                return callback(success);
                              });

                            case 7:
                            case "end":
                              return _context69.stop();
                          }
                        }
                      }, _callee69, _this100);
                    }));

                    return function (_x94) {
                      return _ref72.apply(this, arguments);
                    };
                  }());

                case 26:
                case "end":
                  return _context70.stop();
              }
            }
          }, _callee70, this);
        }));

        return function (_x93) {
          return _ref71.apply(this, arguments);
        };
      }();

      $scope.resyncData = function (callback) {
        modelManager.setAllItemsDirty();
        syncManager.sync().then(function (response) {
          if (!response || response.error) {
            alert(FailedSyncMessage);
            $timeout(function () {
              return callback(false);
            });
          } else {
            $timeout(function () {
              return callback(true);
            });
          }
        });
      };

      $scope.processPasswordChange = function () {
        var _ref73 = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee71(callback) {
          var newUserPassword, currentServerPw, results, newKeys, newAuthParams, syncResponse;
          return _regenerator2.default.wrap(function _callee71$(_context71) {
            while (1) {
              switch (_context71.prev = _context71.next) {
                case 0:
                  newUserPassword = $scope.securityUpdate ? $scope.formData.currentPassword : $scope.formData.newPassword;
                  currentServerPw = this.currentServerPw;
                  _context71.next = 4;
                  return SFJS.crypto.generateInitialKeysAndAuthParamsForUser(authManager.user.email, newUserPassword);

                case 4:
                  results = _context71.sent;
                  newKeys = results.keys;
                  newAuthParams = results.authParams;

                  // perform a sync beforehand to pull in any last minutes changes before we change the encryption key (and thus cant decrypt new changes)

                  _context71.next = 9;
                  return syncManager.sync();

                case 9:
                  syncResponse = _context71.sent;
                  _context71.t0 = authManager;
                  _context71.next = 13;
                  return syncManager.getServerURL();

                case 13:
                  _context71.t1 = _context71.sent;
                  _context71.t2 = authManager.user.email;
                  _context71.t3 = currentServerPw;
                  _context71.t4 = newKeys;
                  _context71.t5 = newAuthParams;

                  _context71.t6 = function (response) {
                    if (response.error) {
                      alert(response.error.message ? response.error.message : "There was an error changing your password. Please try again.");
                      $timeout(function () {
                        return callback(false);
                      });
                    } else {
                      $timeout(function () {
                        return callback(true);
                      });
                    }
                  };

                  _context71.t0.changePassword.call(_context71.t0, _context71.t1, _context71.t2, _context71.t3, _context71.t4, _context71.t5).then(_context71.t6);

                case 20:
                case "end":
                  return _context71.stop();
              }
            }
          }, _callee71, this);
        }));

        return function (_x95) {
          return _ref73.apply(this, arguments);
        };
      }();
    }
  }]);
  return PasswordWizard;
}();

angular.module('app').directive('passwordWizard', function () {
  return new PasswordWizard();
});
;
var PermissionsModal = function () {
  function PermissionsModal() {
    (0, _classCallCheck4.default)(this, PermissionsModal);

    this.restrict = "E";
    this.templateUrl = "directives/permissions-modal.html";
    this.scope = {
      show: "=",
      component: "=",
      permissionsString: "=",
      callback: "="
    };
  }

  (0, _createClass4.default)(PermissionsModal, [{
    key: "link",
    value: function link($scope, el, attrs) {

      $scope.dismiss = function () {
        el.remove();
      };

      $scope.accept = function () {
        $scope.callback(true);
        $scope.dismiss();
      };

      $scope.deny = function () {
        $scope.callback(false);
        $scope.dismiss();
      };
    }
  }, {
    key: "controller",
    value: function controller($scope, modelManager) {
      'ngInject';
    }
  }]);
  return PermissionsModal;
}();

angular.module('app').directive('permissionsModal', function () {
  return new PermissionsModal();
});
;
var PrivilegesAuthModal = function () {
  function PrivilegesAuthModal() {
    (0, _classCallCheck4.default)(this, PrivilegesAuthModal);

    this.restrict = "E";
    this.templateUrl = "directives/privileges-auth-modal.html";
    this.scope = {
      action: "=",
      onSuccess: "=",
      onCancel: "="
    };
  }

  (0, _createClass4.default)(PrivilegesAuthModal, [{
    key: "link",
    value: function link($scope, el, attrs) {
      $scope.dismiss = function () {
        el.remove();
      };
    }
  }, {
    key: "controller",
    value: function controller($scope, privilegesManager, passcodeManager, authManager, $timeout) {
      'ngInject';

      $scope.authenticationParameters = {};
      $scope.sessionLengthOptions = privilegesManager.getSessionLengthOptions();

      privilegesManager.getSelectedSessionLength().then(function (length) {
        $timeout(function () {
          $scope.selectedSessionLength = length;
        });
      });

      $scope.selectSessionLength = function (length) {
        $scope.selectedSessionLength = length;
      };

      privilegesManager.netCredentialsForAction($scope.action).then(function (credentials) {
        $timeout(function () {
          $scope.requiredCredentials = credentials.sort();
        });
      });

      $scope.promptForCredential = function (credential) {
        return privilegesManager.displayInfoForCredential(credential).prompt;
      };

      $scope.cancel = function () {
        $scope.dismiss();
        $scope.onCancel && $scope.onCancel();
      };

      $scope.isCredentialInFailureState = function (credential) {
        if (!$scope.failedCredentials) {
          return false;
        }
        return $scope.failedCredentials.find(function (candidate) {
          return candidate == credential;
        }) != null;
      };

      $scope.validate = function () {
        var failed = [];
        var _iteratorNormalCompletion73 = true;
        var _didIteratorError73 = false;
        var _iteratorError73 = undefined;

        try {
          for (var _iterator73 = $scope.requiredCredentials[Symbol.iterator](), _step73; !(_iteratorNormalCompletion73 = (_step73 = _iterator73.next()).done); _iteratorNormalCompletion73 = true) {
            var cred = _step73.value;

            var value = $scope.authenticationParameters[cred];
            if (!value || value.length == 0) {
              failed.push(cred);
            }
          }
        } catch (err) {
          _didIteratorError73 = true;
          _iteratorError73 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion73 && _iterator73.return) {
              _iterator73.return();
            }
          } finally {
            if (_didIteratorError73) {
              throw _iteratorError73;
            }
          }
        }

        $scope.failedCredentials = failed;
        return failed.length == 0;
      };

      $scope.submit = function () {
        if (!$scope.validate()) {
          return;
        }
        privilegesManager.authenticateAction($scope.action, $scope.authenticationParameters).then(function (result) {
          $timeout(function () {
            if (result.success) {
              privilegesManager.setSessionLength($scope.selectedSessionLength);
              $scope.onSuccess();
              $scope.dismiss();
            } else {
              $scope.failedCredentials = result.failedCredentials;
            }
          });
        });
      };
    }
  }]);
  return PrivilegesAuthModal;
}();

angular.module('app').directive('privilegesAuthModal', function () {
  return new PrivilegesAuthModal();
});
;
var PrivilegesManagementModal = function () {
  function PrivilegesManagementModal() {
    (0, _classCallCheck4.default)(this, PrivilegesManagementModal);

    this.restrict = "E";
    this.templateUrl = "directives/privileges-management-modal.html";
    this.scope = {};
  }

  (0, _createClass4.default)(PrivilegesManagementModal, [{
    key: "link",
    value: function link($scope, el, attrs) {
      $scope.dismiss = function () {
        el.remove();
      };
    }
  }, {
    key: "controller",
    value: function controller($scope, privilegesManager, passcodeManager, authManager, $timeout) {
      'ngInject';

      $scope.dummy = {};

      $scope.hasPasscode = passcodeManager.hasPasscode();
      $scope.hasAccount = !authManager.offline();

      $scope.displayInfoForCredential = function (credential) {
        var info = privilegesManager.displayInfoForCredential(credential);
        if (credential == PrivilegesManager.CredentialLocalPasscode) {
          info["availability"] = $scope.hasPasscode;
        } else if (credential == PrivilegesManager.CredentialAccountPassword) {
          info["availability"] = $scope.hasAccount;
        } else {
          info["availability"] = true;
        }

        return info;
      };

      $scope.displayInfoForAction = function (action) {
        return privilegesManager.displayInfoForAction(action).label;
      };

      $scope.isCredentialRequiredForAction = function (action, credential) {
        if (!$scope.privileges) {
          return false;
        }
        return $scope.privileges.isCredentialRequiredForAction(action, credential);
      };

      $scope.clearSession = function () {
        privilegesManager.clearSession().then(function () {
          $scope.reloadPrivileges();
        });
      };

      $scope.reloadPrivileges = (0, _asyncToGenerator4.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee72() {
        var sessionEndDate, _iteratorNormalCompletion74, _didIteratorError74, _iteratorError74, _iterator74, _step74, cred;

        return _regenerator2.default.wrap(function _callee72$(_context72) {
          while (1) {
            switch (_context72.prev = _context72.next) {
              case 0:
                $scope.availableActions = privilegesManager.getAvailableActions();
                $scope.availableCredentials = privilegesManager.getAvailableCredentials();
                _context72.next = 4;
                return privilegesManager.getSessionExpirey();

              case 4:
                sessionEndDate = _context72.sent;

                $scope.sessionExpirey = sessionEndDate.toLocaleString();
                $scope.sessionExpired = new Date() >= sessionEndDate;

                $scope.credentialDisplayInfo = {};
                _iteratorNormalCompletion74 = true;
                _didIteratorError74 = false;
                _iteratorError74 = undefined;
                _context72.prev = 11;
                for (_iterator74 = $scope.availableCredentials[Symbol.iterator](); !(_iteratorNormalCompletion74 = (_step74 = _iterator74.next()).done); _iteratorNormalCompletion74 = true) {
                  cred = _step74.value;

                  $scope.credentialDisplayInfo[cred] = $scope.displayInfoForCredential(cred);
                }

                _context72.next = 19;
                break;

              case 15:
                _context72.prev = 15;
                _context72.t0 = _context72["catch"](11);
                _didIteratorError74 = true;
                _iteratorError74 = _context72.t0;

              case 19:
                _context72.prev = 19;
                _context72.prev = 20;

                if (!_iteratorNormalCompletion74 && _iterator74.return) {
                  _iterator74.return();
                }

              case 22:
                _context72.prev = 22;

                if (!_didIteratorError74) {
                  _context72.next = 25;
                  break;
                }

                throw _iteratorError74;

              case 25:
                return _context72.finish(22);

              case 26:
                return _context72.finish(19);

              case 27:
                privilegesManager.getPrivileges().then(function (privs) {
                  $timeout(function () {
                    $scope.privileges = privs;
                  });
                });

              case 28:
              case "end":
                return _context72.stop();
            }
          }
        }, _callee72, this, [[11, 15, 19, 27], [20,, 22, 26]]);
      }));

      $scope.checkboxValueChanged = function (action, credential) {
        $scope.privileges.toggleCredentialForAction(action, credential);
        privilegesManager.savePrivileges();
      };

      $scope.reloadPrivileges();

      $scope.cancel = function () {
        $scope.dismiss();
        $scope.onCancel && $scope.onCancel();
      };
    }
  }]);
  return PrivilegesManagementModal;
}();

angular.module('app').directive('privilegesManagementModal', function () {
  return new PrivilegesManagementModal();
});
;
var RevisionPreviewModal = function () {
  function RevisionPreviewModal() {
    (0, _classCallCheck4.default)(this, RevisionPreviewModal);

    this.restrict = "E";
    this.templateUrl = "directives/revision-preview-modal.html";
    this.scope = {
      uuid: "=",
      content: "="
    };
  }

  (0, _createClass4.default)(RevisionPreviewModal, [{
    key: "link",
    value: function link($scope, el, attrs) {
      $scope.el = el;
    }
  }, {
    key: "controller",
    value: function controller($scope, modelManager, syncManager, componentManager, $timeout) {
      'ngInject';

      $scope.dismiss = function () {
        $scope.el.remove();
        $scope.$destroy();
      };

      $scope.$on("$destroy", function () {
        if ($scope.identifier) {
          componentManager.deregisterHandler($scope.identifier);
        }
      });

      $scope.note = new SFItem({ content: $scope.content, content_type: "Note" });
      // Set UUID to editoForNote can find proper editor,
      // but then generate new uuid for note as not to save changes to original, if editor makes changes.
      $scope.note.uuid = $scope.uuid;
      var editorForNote = componentManager.editorForNote($scope.note);
      $scope.note.uuid = SFJS.crypto.generateUUIDSync();

      if (editorForNote) {
        // Create temporary copy, as a lot of componentManager is uuid based,
        // so might interfere with active editor. Be sure to copy only the content, as the
        // top level editor object has non-copyable properties like .window, which cannot be transfered
        var editorCopy = new SNComponent({ content: editorForNote.content });
        editorCopy.readonly = true;
        editorCopy.lockReadonly = true;
        $scope.identifier = editorCopy.uuid;

        componentManager.registerHandler({ identifier: $scope.identifier, areas: ["editor-editor"],
          contextRequestHandler: function contextRequestHandler(component) {
            if (component == $scope.editor) {
              return $scope.note;
            }
          },
          componentForSessionKeyHandler: function componentForSessionKeyHandler(key) {
            if (key == $scope.editor.sessionKey) {
              return $scope.editor;
            }
          }
        });

        $scope.editor = editorCopy;
      }

      $scope.restore = function (asCopy) {
        if (!asCopy && !confirm("Are you sure you want to replace the current note's contents with what you see in this preview?")) {
          return;
        }

        var item;
        if (asCopy) {
          var contentCopy = Object.assign({}, $scope.content);
          if (contentCopy.title) {
            contentCopy.title += " (copy)";
          }
          item = modelManager.createItem({ content_type: "Note", content: contentCopy });
          modelManager.addItem(item);
        } else {
          var uuid = $scope.uuid;
          item = modelManager.findItem(uuid);
          item.content = Object.assign({}, $scope.content);
          // mapResponseItemsToLocalModels is async, but we don't need to wait here.
          modelManager.mapResponseItemsToLocalModels([item], SFModelManager.MappingSourceRemoteActionRetrieved);
        }

        modelManager.setItemDirty(item, true);
        syncManager.sync();

        $scope.dismiss();
      };
    }
  }]);
  return RevisionPreviewModal;
}();

angular.module('app').directive('revisionPreviewModal', function () {
  return new RevisionPreviewModal();
});
;
var SessionHistoryMenu = function () {
  function SessionHistoryMenu() {
    (0, _classCallCheck4.default)(this, SessionHistoryMenu);

    this.restrict = "E";
    this.templateUrl = "directives/session-history-menu.html";
    this.scope = {
      item: "="
    };
  }

  (0, _createClass4.default)(SessionHistoryMenu, [{
    key: "controller",
    value: function controller($scope, modelManager, sessionHistory, actionsManager, $timeout) {
      'ngInject';

      $scope.diskEnabled = sessionHistory.diskEnabled;
      $scope.autoOptimize = sessionHistory.autoOptimize;

      $scope.reloadHistory = function () {
        var history = sessionHistory.historyForItem($scope.item);
        // make copy as not to sort inline
        $scope.entries = history.entries.slice(0).sort(function (a, b) {
          return a.item.updated_at < b.item.updated_at ? 1 : -1;
        });
        $scope.history = history;
      };

      $scope.reloadHistory();

      $scope.openRevision = function (revision) {
        actionsManager.presentRevisionPreviewModal(revision.item.uuid, revision.item.content);
      };

      $scope.classForRevision = function (revision) {
        var vector = revision.operationVector();
        if (vector == 0) {
          return "default";
        } else if (vector == 1) {
          return "success";
        } else if (vector == -1) {
          return "danger";
        }
      };

      $scope.clearItemHistory = function () {
        if (!confirm("Are you sure you want to delete the local session history for this note?")) {
          return;
        }

        sessionHistory.clearItemHistory($scope.item).then(function () {
          $timeout(function () {
            $scope.reloadHistory();
          });
        });
      };

      $scope.clearAllHistory = function () {
        if (!confirm("Are you sure you want to delete the local session history for all notes?")) {
          return;
        }

        sessionHistory.clearAllHistory().then(function () {
          $timeout(function () {
            $scope.reloadHistory();
          });
        });
      };

      $scope.toggleDiskSaving = function () {
        if (!sessionHistory.diskEnabled) {
          if (!confirm("Are you sure you want to save history to disk? This will decrease general performance, especially as you type. You are advised to disable this feature if you experience any lagging.")) {
            return;
          }
        }
        sessionHistory.toggleDiskSaving().then(function () {
          $timeout(function () {
            $scope.diskEnabled = sessionHistory.diskEnabled;
          });
        });
      };

      $scope.toggleAutoOptimize = function () {
        sessionHistory.toggleAutoOptimize().then(function () {
          $timeout(function () {
            $scope.autoOptimize = sessionHistory.autoOptimize;
          });
        });
      };
    }
  }]);
  return SessionHistoryMenu;
}();

angular.module('app').directive('sessionHistoryMenu', function () {
  return new SessionHistoryMenu();
});
;
var SyncResolutionMenu = function () {
  function SyncResolutionMenu() {
    (0, _classCallCheck4.default)(this, SyncResolutionMenu);

    this.restrict = "E";
    this.templateUrl = "directives/sync-resolution-menu.html";
    this.scope = {
      "closeFunction": "&"
    };
  }

  (0, _createClass4.default)(SyncResolutionMenu, [{
    key: "controller",
    value: function controller($scope, modelManager, syncManager, archiveManager, $timeout) {
      'ngInject';

      $scope.status = {};

      $scope.close = function () {
        $timeout(function () {
          $scope.closeFunction()();
        });
      };

      $scope.downloadBackup = function (encrypted) {
        archiveManager.downloadBackup(encrypted);
        $scope.status.backupFinished = true;
      };

      $scope.skipBackup = function () {
        $scope.status.backupFinished = true;
      };

      $scope.performSyncResolution = function () {
        $scope.status.resolving = true;
        syncManager.resolveOutOfSync().then(function () {
          $scope.status.resolving = false;
          $scope.status.attemptedResolution = true;
          if (syncManager.isOutOfSync()) {
            $scope.status.fail = true;
          } else {
            $scope.status.success = true;
          }
        });
      };
    }
  }]);
  return SyncResolutionMenu;
}();

angular.module('app').directive('syncResolutionMenu', function () {
  return new SyncResolutionMenu();
});


},{"babel-runtime/helpers/asyncToGenerator":10,"babel-runtime/helpers/classCallCheck":11,"babel-runtime/helpers/createClass":12,"babel-runtime/helpers/get":13,"babel-runtime/helpers/inherits":14,"babel-runtime/helpers/possibleConstructorReturn":15,"babel-runtime/helpers/typeof":16,"babel-runtime/regenerator":17,"standard-file-js":117}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":18}],3:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":19}],4:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":20}],5:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":21}],6:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":22}],7:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":23}],8:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":24}],9:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":25}],10:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _promise = require("../core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};
},{"../core-js/promise":7}],11:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],12:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":3}],13:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};
},{"../core-js/object/get-own-property-descriptor":4,"../core-js/object/get-prototype-of":5}],14:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":2,"../core-js/object/set-prototype-of":6,"../helpers/typeof":16}],15:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":16}],16:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":8,"../core-js/symbol/iterator":9}],17:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":115}],18:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":33,"../../modules/es6.object.create":101}],19:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":33,"../../modules/es6.object.define-property":102}],20:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":33,"../../modules/es6.object.get-own-property-descriptor":103}],21:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":33,"../../modules/es6.object.get-prototype-of":104}],22:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":33,"../../modules/es6.object.set-prototype-of":105}],23:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
require('../modules/es7.promise.finally');
require('../modules/es7.promise.try');
module.exports = require('../modules/_core').Promise;

},{"../modules/_core":33,"../modules/es6.object.to-string":106,"../modules/es6.promise":107,"../modules/es6.string.iterator":108,"../modules/es7.promise.finally":110,"../modules/es7.promise.try":111,"../modules/web.dom.iterable":114}],24:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":33,"../../modules/es6.object.to-string":106,"../../modules/es6.symbol":109,"../../modules/es7.symbol.async-iterator":112,"../../modules/es7.symbol.observable":113}],25:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":97,"../../modules/es6.string.iterator":108,"../../modules/web.dom.iterable":114}],26:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],27:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],28:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],29:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":52}],30:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":88,"./_to-iobject":90,"./_to-length":91}],31:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":32,"./_wks":98}],32:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],33:[function(require,module,exports){
var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],34:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":26}],35:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],36:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":41}],37:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":43,"./_is-object":52}],38:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],39:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":69,"./_object-keys":72,"./_object-pie":73}],40:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":33,"./_ctx":34,"./_global":43,"./_has":44,"./_hide":45}],41:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],42:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":29,"./_ctx":34,"./_is-array-iter":50,"./_iter-call":53,"./_to-length":91,"./core.get-iterator-method":99}],43:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],44:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],45:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":36,"./_object-dp":64,"./_property-desc":77}],46:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":43}],47:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":36,"./_dom-create":37,"./_fails":41}],48:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],49:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":32}],50:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":58,"./_wks":98}],51:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":32}],52:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],53:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":29}],54:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":45,"./_object-create":63,"./_property-desc":77,"./_set-to-string-tag":82,"./_wks":98}],55:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":40,"./_hide":45,"./_iter-create":54,"./_iterators":58,"./_library":59,"./_object-gpo":70,"./_redefine":79,"./_set-to-string-tag":82,"./_wks":98}],56:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":98}],57:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],58:[function(require,module,exports){
module.exports = {};

},{}],59:[function(require,module,exports){
module.exports = true;

},{}],60:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":41,"./_has":44,"./_is-object":52,"./_object-dp":64,"./_uid":94}],61:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":32,"./_global":43,"./_task":87}],62:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":26}],63:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":29,"./_dom-create":37,"./_enum-bug-keys":38,"./_html":46,"./_object-dps":65,"./_shared-key":83}],64:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":29,"./_descriptors":36,"./_ie8-dom-define":47,"./_to-primitive":93}],65:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":29,"./_descriptors":36,"./_object-dp":64,"./_object-keys":72}],66:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":36,"./_has":44,"./_ie8-dom-define":47,"./_object-pie":73,"./_property-desc":77,"./_to-iobject":90,"./_to-primitive":93}],67:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":68,"./_to-iobject":90}],68:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":38,"./_object-keys-internal":71}],69:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],70:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":44,"./_shared-key":83,"./_to-object":92}],71:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":30,"./_has":44,"./_shared-key":83,"./_to-iobject":90}],72:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":38,"./_object-keys-internal":71}],73:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],74:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":33,"./_export":40,"./_fails":41}],75:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],76:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":29,"./_is-object":52,"./_new-promise-capability":62}],77:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],78:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":45}],79:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":45}],80:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":29,"./_ctx":34,"./_is-object":52,"./_object-gopd":66}],81:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":33,"./_descriptors":36,"./_global":43,"./_object-dp":64,"./_wks":98}],82:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":44,"./_object-dp":64,"./_wks":98}],83:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":84,"./_uid":94}],84:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":33,"./_global":43,"./_library":59}],85:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":26,"./_an-object":29,"./_wks":98}],86:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":35,"./_to-integer":89}],87:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":32,"./_ctx":34,"./_dom-create":37,"./_global":43,"./_html":46,"./_invoke":48}],88:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":89}],89:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],90:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":35,"./_iobject":49}],91:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":89}],92:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":35}],93:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":52}],94:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],95:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":43}],96:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":33,"./_global":43,"./_library":59,"./_object-dp":64,"./_wks-ext":97}],97:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":98}],98:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":43,"./_shared":84,"./_uid":94}],99:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":31,"./_core":33,"./_iterators":58,"./_wks":98}],100:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":27,"./_iter-define":55,"./_iter-step":57,"./_iterators":58,"./_to-iobject":90}],101:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":40,"./_object-create":63}],102:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":36,"./_export":40,"./_object-dp":64}],103:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":66,"./_object-sap":74,"./_to-iobject":90}],104:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":70,"./_object-sap":74,"./_to-object":92}],105:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":40,"./_set-proto":80}],106:[function(require,module,exports){

},{}],107:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":26,"./_an-instance":28,"./_classof":31,"./_core":33,"./_ctx":34,"./_export":40,"./_for-of":42,"./_global":43,"./_is-object":52,"./_iter-detect":56,"./_library":59,"./_microtask":61,"./_new-promise-capability":62,"./_perform":75,"./_promise-resolve":76,"./_redefine-all":78,"./_set-species":81,"./_set-to-string-tag":82,"./_species-constructor":85,"./_task":87,"./_user-agent":95,"./_wks":98}],108:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":55,"./_string-at":86}],109:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":29,"./_descriptors":36,"./_enum-keys":39,"./_export":40,"./_fails":41,"./_global":43,"./_has":44,"./_hide":45,"./_is-array":51,"./_is-object":52,"./_library":59,"./_meta":60,"./_object-create":63,"./_object-dp":64,"./_object-gopd":66,"./_object-gopn":68,"./_object-gopn-ext":67,"./_object-gops":69,"./_object-keys":72,"./_object-pie":73,"./_property-desc":77,"./_redefine":79,"./_set-to-string-tag":82,"./_shared":84,"./_to-iobject":90,"./_to-primitive":93,"./_uid":94,"./_wks":98,"./_wks-define":96,"./_wks-ext":97}],110:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":33,"./_export":40,"./_global":43,"./_promise-resolve":76,"./_species-constructor":85}],111:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":40,"./_new-promise-capability":62,"./_perform":75}],112:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":96}],113:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":96}],114:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":43,"./_hide":45,"./_iterators":58,"./_wks":98,"./es6.array.iterator":100}],115:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":116}],116:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],117:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SF = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=l.WordArray=t.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=p?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,e=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var k=0;k<a;k++)c[j+k>>>2]|=(e[k>>>2]>>>24-8*(k%4)&255)<<24-8*((j+k)%4);else if(65535<e.length)for(k=0;k<a;k+=4)c[j+k>>>2]=e[k>>>2];else c.push.apply(c,e);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e<a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++){var k=c[j>>>2]>>>24-8*(j%4)&255;e.push((k>>>4).toString(16));e.push((k&15).toString(16))}return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j+=2)e[j>>>3]|=parseInt(a.substr(j,
2),16)<<24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++)e.push(String.fromCharCode(c[j>>>2]>>>24-8*(j%4)&255));return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j++)e[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q<a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
;/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
d)).finalize(c)}}});var t=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();
;/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(a,j){var c={},b=c.lib={},f=function(){},l=b.Base={extend:function(a){f.prototype=this;var d=new f;a&&d.mixIn(a);d.hasOwnProperty("init")||(d.init=function(){d.$super.init.apply(this,arguments)});d.init.prototype=d;d.$super=this;return d},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var d in a)a.hasOwnProperty(d)&&(this[d]=a[d]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
u=b.WordArray=l.extend({init:function(a,d){a=this.words=a||[];this.sigBytes=d!=j?d:4*a.length},toString:function(a){return(a||m).stringify(this)},concat:function(a){var d=this.words,M=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var b=0;b<a;b++)d[e+b>>>2]|=(M[b>>>2]>>>24-8*(b%4)&255)<<24-8*((e+b)%4);else if(65535<M.length)for(b=0;b<a;b+=4)d[e+b>>>2]=M[b>>>2];else d.push.apply(d,M);this.sigBytes+=a;return this},clamp:function(){var D=this.words,d=this.sigBytes;D[d>>>2]&=4294967295<<
32-8*(d%4);D.length=a.ceil(d/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(D){for(var d=[],b=0;b<D;b+=4)d.push(4294967296*a.random()|0);return new u.init(d,D)}}),k=c.enc={},m=k.Hex={stringify:function(a){var d=a.words;a=a.sigBytes;for(var b=[],e=0;e<a;e++){var c=d[e>>>2]>>>24-8*(e%4)&255;b.push((c>>>4).toString(16));b.push((c&15).toString(16))}return b.join("")},parse:function(a){for(var d=a.length,b=[],e=0;e<d;e+=2)b[e>>>3]|=parseInt(a.substr(e,
2),16)<<24-4*(e%8);return new u.init(b,d/2)}},y=k.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],e=0;e<a;e++)c.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return c.join("")},parse:function(a){for(var b=a.length,c=[],e=0;e<b;e++)c[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new u.init(c,b)}},z=k.Utf8={stringify:function(a){try{return decodeURIComponent(escape(y.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return y.parse(unescape(encodeURIComponent(a)))}},
x=b.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new u.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=z.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(b){var d=this._data,c=d.words,e=d.sigBytes,l=this.blockSize,k=e/(4*l),k=b?a.ceil(k):a.max((k|0)-this._minBufferSize,0);b=k*l;e=a.min(4*b,e);if(b){for(var x=0;x<b;x+=l)this._doProcessBlock(c,x);x=c.splice(0,b);d.sigBytes-=e}return new u.init(x,e)},clone:function(){var a=l.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});b.Hasher=x.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,c){return(new a.init(c)).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return(new ja.HMAC.init(a,
c)).finalize(b)}}});var ja=c.algo={};return c}(Math);
(function(a){var j=CryptoJS,c=j.lib,b=c.Base,f=c.WordArray,j=j.x64={};j.Word=b.extend({init:function(a,b){this.high=a;this.low=b}});j.WordArray=b.extend({init:function(b,c){b=this.words=b||[];this.sigBytes=c!=a?c:8*b.length},toX32:function(){for(var a=this.words,b=a.length,c=[],m=0;m<b;m++){var y=a[m];c.push(y.high);c.push(y.low)}return f.create(c,this.sigBytes)},clone:function(){for(var a=b.clone.call(this),c=a.words=this.words.slice(0),k=c.length,f=0;f<k;f++)c[f]=c[f].clone();return a}})})();
(function(){function a(){return f.create.apply(f,arguments)}for(var j=CryptoJS,c=j.lib.Hasher,b=j.x64,f=b.Word,l=b.WordArray,b=j.algo,u=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],k=[],m=0;80>m;m++)k[m]=a();b=b.SHA512=c.extend({_doReset:function(){this._hash=new l.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,b){for(var c=this._hash.words,
f=c[0],j=c[1],d=c[2],l=c[3],e=c[4],m=c[5],N=c[6],c=c[7],aa=f.high,O=f.low,ba=j.high,P=j.low,ca=d.high,Q=d.low,da=l.high,R=l.low,ea=e.high,S=e.low,fa=m.high,T=m.low,ga=N.high,U=N.low,ha=c.high,V=c.low,r=aa,n=O,G=ba,E=P,H=ca,F=Q,Y=da,I=R,s=ea,p=S,W=fa,J=T,X=ga,K=U,Z=ha,L=V,t=0;80>t;t++){var A=k[t];if(16>t)var q=A.high=a[b+2*t]|0,g=A.low=a[b+2*t+1]|0;else{var q=k[t-15],g=q.high,v=q.low,q=(g>>>1|v<<31)^(g>>>8|v<<24)^g>>>7,v=(v>>>1|g<<31)^(v>>>8|g<<24)^(v>>>7|g<<25),C=k[t-2],g=C.high,h=C.low,C=(g>>>19|
h<<13)^(g<<3|h>>>29)^g>>>6,h=(h>>>19|g<<13)^(h<<3|g>>>29)^(h>>>6|g<<26),g=k[t-7],$=g.high,B=k[t-16],w=B.high,B=B.low,g=v+g.low,q=q+$+(g>>>0<v>>>0?1:0),g=g+h,q=q+C+(g>>>0<h>>>0?1:0),g=g+B,q=q+w+(g>>>0<B>>>0?1:0);A.high=q;A.low=g}var $=s&W^~s&X,B=p&J^~p&K,A=r&G^r&H^G&H,ka=n&E^n&F^E&F,v=(r>>>28|n<<4)^(r<<30|n>>>2)^(r<<25|n>>>7),C=(n>>>28|r<<4)^(n<<30|r>>>2)^(n<<25|r>>>7),h=u[t],la=h.high,ia=h.low,h=L+((p>>>14|s<<18)^(p>>>18|s<<14)^(p<<23|s>>>9)),w=Z+((s>>>14|p<<18)^(s>>>18|p<<14)^(s<<23|p>>>9))+(h>>>
0<L>>>0?1:0),h=h+B,w=w+$+(h>>>0<B>>>0?1:0),h=h+ia,w=w+la+(h>>>0<ia>>>0?1:0),h=h+g,w=w+q+(h>>>0<g>>>0?1:0),g=C+ka,A=v+A+(g>>>0<C>>>0?1:0),Z=X,L=K,X=W,K=J,W=s,J=p,p=I+h|0,s=Y+w+(p>>>0<I>>>0?1:0)|0,Y=H,I=F,H=G,F=E,G=r,E=n,n=h+g|0,r=w+A+(n>>>0<h>>>0?1:0)|0}O=f.low=O+n;f.high=aa+r+(O>>>0<n>>>0?1:0);P=j.low=P+E;j.high=ba+G+(P>>>0<E>>>0?1:0);Q=d.low=Q+F;d.high=ca+H+(Q>>>0<F>>>0?1:0);R=l.low=R+I;l.high=da+Y+(R>>>0<I>>>0?1:0);S=e.low=S+p;e.high=ea+s+(S>>>0<p>>>0?1:0);T=m.low=T+J;m.high=fa+W+(T>>>0<J>>>0?1:
0);U=N.low=U+K;N.high=ga+X+(U>>>0<K>>>0?1:0);V=c.low=V+L;c.high=ha+Z+(V>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,b=a.words,c=8*this._nDataBytes,f=8*a.sigBytes;b[f>>>5]|=128<<24-f%32;b[(f+128>>>10<<5)+30]=Math.floor(c/4294967296);b[(f+128>>>10<<5)+31]=c;a.sigBytes=4*b.length;this._process();return this._hash.toX32()},clone:function(){var a=c.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});j.SHA512=c._createHelper(b);j.HmacSHA512=c._createHmacHelper(b)})();
(function(){var a=CryptoJS,j=a.enc.Utf8;a.algo.HMAC=a.lib.Base.extend({init:function(a,b){a=this._hasher=new a.init;"string"==typeof b&&(b=j.parse(b));var f=a.blockSize,l=4*f;b.sigBytes>l&&(b=a.finalize(b));b.clamp();for(var u=this._oKey=b.clone(),k=this._iKey=b.clone(),m=u.words,y=k.words,z=0;z<f;z++)m[z]^=1549556828,y[z]^=909522486;u.sigBytes=k.sigBytes=l;this.reset()},reset:function(){var a=this._hasher;a.reset();a.update(this._iKey)},update:function(a){this._hasher.update(a);return this},finalize:function(a){var b=
this._hasher;a=b.finalize(a);b.reset();return b.finalize(this._oKey.clone().concat(a))}})})();
;/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(g,j){var e={},d=e.lib={},m=function(){},n=d.Base={extend:function(a){m.prototype=this;var c=new m;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=d.WordArray=n.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=j?c:4*a.length},toString:function(a){return(a||l).stringify(this)},concat:function(a){var c=this.words,p=a.words,f=this.sigBytes;a=a.sigBytes;this.clamp();if(f%4)for(var b=0;b<a;b++)c[f+b>>>2]|=(p[b>>>2]>>>24-8*(b%4)&255)<<24-8*((f+b)%4);else if(65535<p.length)for(b=0;b<a;b+=4)c[f+b>>>2]=p[b>>>2];else c.push.apply(c,p);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=n.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),b=e.enc={},l=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++){var d=c[f>>>2]>>>24-8*(f%4)&255;b.push((d>>>4).toString(16));b.push((d&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f+=2)b[f>>>3]|=parseInt(a.substr(f,
2),16)<<24-4*(f%8);return new q.init(b,c/2)}},k=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++)b.push(String.fromCharCode(c[f>>>2]>>>24-8*(f%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f++)b[f>>>2]|=(a.charCodeAt(f)&255)<<24-8*(f%4);return new q.init(b,c)}},h=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},
u=d.BufferedBlockAlgorithm=n.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=h.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,f=b.sigBytes,l=this.blockSize,e=f/(4*l),e=a?g.ceil(e):g.max((e|0)-this._minBufferSize,0);a=e*l;f=g.min(4*a,f);if(a){for(var h=0;h<a;h+=l)this._doProcessBlock(d,h);h=d.splice(0,a);b.sigBytes-=f}return new q.init(h,f)},clone:function(){var a=n.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});d.Hasher=u.extend({cfg:n.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new w.HMAC.init(a,
d)).finalize(b)}}});var w=e.algo={};return e}(Math);
(function(){var g=CryptoJS,j=g.lib,e=j.WordArray,d=j.Hasher,m=[],j=g.algo.SHA1=d.extend({_doReset:function(){this._hash=new e.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(d,e){for(var b=this._hash.words,l=b[0],k=b[1],h=b[2],g=b[3],j=b[4],a=0;80>a;a++){if(16>a)m[a]=d[e+a]|0;else{var c=m[a-3]^m[a-8]^m[a-14]^m[a-16];m[a]=c<<1|c>>>31}c=(l<<5|l>>>27)+j+m[a];c=20>a?c+((k&h|~k&g)+1518500249):40>a?c+((k^h^g)+1859775393):60>a?c+((k&h|k&g|h&g)-1894007588):c+((k^h^
g)-899497514);j=g;g=h;h=k<<30|k>>>2;k=l;l=c}b[0]=b[0]+l|0;b[1]=b[1]+k|0;b[2]=b[2]+h|0;b[3]=b[3]+g|0;b[4]=b[4]+j|0},_doFinalize:function(){var d=this._data,e=d.words,b=8*this._nDataBytes,l=8*d.sigBytes;e[l>>>5]|=128<<24-l%32;e[(l+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(l+64>>>9<<4)+15]=b;d.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=d.clone.call(this);e._hash=this._hash.clone();return e}});g.SHA1=d._createHelper(j);g.HmacSHA1=d._createHmacHelper(j)})();
(function(){var g=CryptoJS,j=g.enc.Utf8;g.algo.HMAC=g.lib.Base.extend({init:function(e,d){e=this._hasher=new e.init;"string"==typeof d&&(d=j.parse(d));var g=e.blockSize,n=4*g;d.sigBytes>n&&(d=e.finalize(d));d.clamp();for(var q=this._oKey=d.clone(),b=this._iKey=d.clone(),l=q.words,k=b.words,h=0;h<g;h++)l[h]^=1549556828,k[h]^=909522486;q.sigBytes=b.sigBytes=n;this.reset()},reset:function(){var e=this._hasher;e.reset();e.update(this._iKey)},update:function(e){this._hasher.update(e);return this},finalize:function(e){var d=
this._hasher;e=d.finalize(e);d.reset();return d.finalize(this._oKey.clone().concat(e))}})})();
(function(){var g=CryptoJS,j=g.lib,e=j.Base,d=j.WordArray,j=g.algo,m=j.HMAC,n=j.PBKDF2=e.extend({cfg:e.extend({keySize:4,hasher:j.SHA1,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(e,b){for(var g=this.cfg,k=m.create(g.hasher,e),h=d.create(),j=d.create([1]),n=h.words,a=j.words,c=g.keySize,g=g.iterations;n.length<c;){var p=k.update(b).finalize(j);k.reset();for(var f=p.words,v=f.length,s=p,t=1;t<g;t++){s=k.finalize(s);k.reset();for(var x=s.words,r=0;r<v;r++)f[r]^=x[r]}h.concat(p);
a[0]++}h.sigBytes=4*c;return h}});g.PBKDF2=function(d,b,e){return n.create(e).compute(d,b)}})();
;/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
n=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,
2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},
k=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,
f)).finalize(b)}}});var s=p.algo={};return p}(Math);
(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^
k)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();
;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SFAlertManager = exports.SFAlertManager = function () {
  function SFAlertManager() {
    _classCallCheck(this, SFAlertManager);
  }

  _createClass(SFAlertManager, [{
    key: "alert",
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  window.alert(params.text);
                  resolve();
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function alert(_x) {
        return _ref.apply(this, arguments);
      }

      return alert;
    }()
  }, {
    key: "confirm",
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(params) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  if (window.confirm(params.text)) {
                    resolve();
                  } else {
                    reject();
                  }
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function confirm(_x2) {
        return _ref2.apply(this, arguments);
      }

      return confirm;
    }()
  }]);

  return SFAlertManager;
}();

;
var SFAuthManager = exports.SFAuthManager = function () {
  function SFAuthManager(storageManager, httpManager, alertManager, timeout) {
    _classCallCheck(this, SFAuthManager);

    SFAuthManager.DidSignOutEvent = "DidSignOutEvent";
    SFAuthManager.WillSignInEvent = "WillSignInEvent";
    SFAuthManager.DidSignInEvent = "DidSignInEvent";

    this.httpManager = httpManager;
    this.storageManager = storageManager;
    this.alertManager = alertManager || new SFAlertManager();
    this.$timeout = timeout || setTimeout.bind(window);

    this.eventHandlers = [];
  }

  _createClass(SFAuthManager, [{
    key: "addEventHandler",
    value: function addEventHandler(handler) {
      this.eventHandlers.push(handler);
      return handler;
    }
  }, {
    key: "removeEventHandler",
    value: function removeEventHandler(handler) {
      _.pull(this.eventHandlers, handler);
    }
  }, {
    key: "notifyEvent",
    value: function notifyEvent(event, data) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.eventHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var handler = _step.value;

          handler(event, data || {});
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "saveKeys",
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(keys) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._keys = keys;
                _context3.next = 3;
                return this.storageManager.setItem("mk", keys.mk);

              case 3:
                _context3.next = 5;
                return this.storageManager.setItem("ak", keys.ak);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function saveKeys(_x3) {
        return _ref3.apply(this, arguments);
      }

      return saveKeys;
    }()
  }, {
    key: "signout",
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(clearAllData) {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._keys = null;
                this._authParams = null;

                if (!clearAllData) {
                  _context4.next = 6;
                  break;
                }

                return _context4.abrupt("return", this.storageManager.clearAllData().then(function () {
                  _this.notifyEvent(SFAuthManager.DidSignOutEvent);
                }));

              case 6:
                this.notifyEvent(SFAuthManager.DidSignOutEvent);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function signout(_x4) {
        return _ref4.apply(this, arguments);
      }

      return signout;
    }()
  }, {
    key: "keys",
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var mk;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this._keys) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 3;
                return this.storageManager.getItem("mk");

              case 3:
                mk = _context5.sent;

                if (mk) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return", null);

              case 6:
                _context5.t0 = mk;
                _context5.next = 9;
                return this.storageManager.getItem("ak");

              case 9:
                _context5.t1 = _context5.sent;
                this._keys = {
                  mk: _context5.t0,
                  ak: _context5.t1
                };

              case 11:
                return _context5.abrupt("return", this._keys);

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function keys() {
        return _ref5.apply(this, arguments);
      }

      return keys;
    }()
  }, {
    key: "getAuthParams",
    value: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var data;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this._authParams) {
                  _context6.next = 5;
                  break;
                }

                _context6.next = 3;
                return this.storageManager.getItem("auth_params");

              case 3:
                data = _context6.sent;

                this._authParams = JSON.parse(data);

              case 5:
                if (!(this._authParams && !this._authParams.version)) {
                  _context6.next = 9;
                  break;
                }

                _context6.next = 8;
                return this.defaultProtocolVersion();

              case 8:
                this._authParams.version = _context6.sent;

              case 9:
                return _context6.abrupt("return", this._authParams);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getAuthParams() {
        return _ref6.apply(this, arguments);
      }

      return getAuthParams;
    }()
  }, {
    key: "defaultProtocolVersion",
    value: function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var keys;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.keys();

              case 2:
                keys = _context7.sent;

                if (!(keys && keys.ak)) {
                  _context7.next = 7;
                  break;
                }

                return _context7.abrupt("return", "002");

              case 7:
                return _context7.abrupt("return", "001");

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function defaultProtocolVersion() {
        return _ref7.apply(this, arguments);
      }

      return defaultProtocolVersion;
    }()
  }, {
    key: "protocolVersion",
    value: function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var authParams;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getAuthParams();

              case 2:
                authParams = _context8.sent;

                if (!(authParams && authParams.version)) {
                  _context8.next = 5;
                  break;
                }

                return _context8.abrupt("return", authParams.version);

              case 5:
                return _context8.abrupt("return", this.defaultProtocolVersion());

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function protocolVersion() {
        return _ref8.apply(this, arguments);
      }

      return protocolVersion;
    }()
  }, {
    key: "getAuthParamsForEmail",
    value: function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(url, email, extraParams) {
        var _this2 = this;

        var params;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                params = _.merge({ email: email }, extraParams);

                params['api'] = SFHttpManager.getApiVersion();
                return _context9.abrupt("return", new Promise(function (resolve, reject) {
                  var requestUrl = url + "/auth/params";
                  _this2.httpManager.getAbsolute(requestUrl, params, function (response) {
                    resolve(response);
                  }, function (response) {
                    console.error("Error getting auth params", response);
                    if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                      response = { error: { message: "A server error occurred while trying to sign in. Please try again." } };
                    }
                    resolve(response);
                  });
                }));

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getAuthParamsForEmail(_x5, _x6, _x7) {
        return _ref9.apply(this, arguments);
      }

      return getAuthParamsForEmail;
    }()
  }, {
    key: "lock",
    value: function lock() {
      this.locked = true;
    }
  }, {
    key: "unlock",
    value: function unlock() {
      this.locked = false;
    }
  }, {
    key: "isLocked",
    value: function isLocked() {
      return this.locked == true;
    }
  }, {
    key: "unlockAndResolve",
    value: function unlockAndResolve(resolve, param) {
      this.unlock();
      resolve(param);
    }
  }, {
    key: "login",
    value: function () {
      var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(url, email, password, strictSignin, extraParams) {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", new Promise(function () {
                  var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(resolve, reject) {
                    var existingKeys, authParams, message, _message, abort, _message2, minimum, _message3, latestVersion, _message4, keys, requestUrl, params;

                    return regeneratorRuntime.wrap(function _callee11$(_context11) {
                      while (1) {
                        switch (_context11.prev = _context11.next) {
                          case 0:
                            _context11.next = 2;
                            return _this3.keys();

                          case 2:
                            existingKeys = _context11.sent;

                            if (!(existingKeys != null)) {
                              _context11.next = 6;
                              break;
                            }

                            resolve({ error: { message: "Cannot log in because already signed in." } });
                            return _context11.abrupt("return");

                          case 6:
                            if (!_this3.isLocked()) {
                              _context11.next = 9;
                              break;
                            }

                            resolve({ error: { message: "Login already in progress." } });
                            return _context11.abrupt("return");

                          case 9:

                            _this3.lock();

                            _this3.notifyEvent(SFAuthManager.WillSignInEvent);

                            _context11.next = 13;
                            return _this3.getAuthParamsForEmail(url, email, extraParams);

                          case 13:
                            authParams = _context11.sent;


                            // SF3 requires a unique identifier in the auth params
                            authParams.identifier = email;

                            if (!authParams.error) {
                              _context11.next = 18;
                              break;
                            }

                            _this3.unlockAndResolve(resolve, authParams);
                            return _context11.abrupt("return");

                          case 18:
                            if (!(!authParams || !authParams.pw_cost)) {
                              _context11.next = 21;
                              break;
                            }

                            _this3.unlockAndResolve(resolve, { error: { message: "Invalid email or password." } });
                            return _context11.abrupt("return");

                          case 21:
                            if (SFJS.supportedVersions().includes(authParams.version)) {
                              _context11.next = 25;
                              break;
                            }

                            if (SFJS.isVersionNewerThanLibraryVersion(authParams.version)) {
                              // The user has a new account type, but is signing in to an older client.
                              message = "This version of the application does not support your newer account type. Please upgrade to the latest version of Standard Notes to sign in.";
                            } else {
                              // The user has a very old account type, which is no longer supported by this client
                              message = "The protocol version associated with your account is outdated and no longer supported by this application. Please visit standardnotes.org/help/security for more information.";
                            }
                            _this3.unlockAndResolve(resolve, { error: { message: message } });
                            return _context11.abrupt("return");

                          case 25:
                            if (!SFJS.isProtocolVersionOutdated(authParams.version)) {
                              _context11.next = 32;
                              break;
                            }

                            _message = "The encryption version for your account, " + authParams.version + ", is outdated and requires upgrade. You may proceed with login, but are advised to perform a security update using the web or desktop application. Please visit standardnotes.org/help/security for more information.";
                            abort = false;
                            _context11.next = 30;
                            return _this3.alertManager.confirm({
                              title: "Update Needed",
                              text: _message,
                              confirmButtonText: "Sign In"
                            }).catch(function () {
                              _this3.unlockAndResolve(resolve, { error: {} });
                              abort = true;
                            });

                          case 30:
                            if (!abort) {
                              _context11.next = 32;
                              break;
                            }

                            return _context11.abrupt("return");

                          case 32:
                            if (SFJS.supportsPasswordDerivationCost(authParams.pw_cost)) {
                              _context11.next = 36;
                              break;
                            }

                            _message2 = "Your account was created on a platform with higher security capabilities than this browser supports. " + "If we attempted to generate your login keys here, it would take hours. " + "Please use a browser with more up to date security capabilities, like Google Chrome or Firefox, to log in.";

                            _this3.unlockAndResolve(resolve, { error: { message: _message2 } });
                            return _context11.abrupt("return");

                          case 36:
                            minimum = SFJS.costMinimumForVersion(authParams.version);

                            if (!(authParams.pw_cost < minimum)) {
                              _context11.next = 41;
                              break;
                            }

                            _message3 = "Unable to login due to insecure password parameters. Please visit standardnotes.org/help/security for more information.";

                            _this3.unlockAndResolve(resolve, { error: { message: _message3 } });
                            return _context11.abrupt("return");

                          case 41:
                            if (!strictSignin) {
                              _context11.next = 47;
                              break;
                            }

                            // Refuse sign in if authParams.version is anything but the latest version
                            latestVersion = SFJS.version();

                            if (!(authParams.version !== latestVersion)) {
                              _context11.next = 47;
                              break;
                            }

                            _message4 = "Strict sign in refused server sign in parameters. The latest security version is " + latestVersion + ", but your account is reported to have version " + authParams.version + ". If you'd like to proceed with sign in anyway, please disable strict sign in and try again.";

                            _this3.unlockAndResolve(resolve, { error: { message: _message4 } });
                            return _context11.abrupt("return");

                          case 47:
                            _context11.next = 49;
                            return SFJS.crypto.computeEncryptionKeysForUser(password, authParams);

                          case 49:
                            keys = _context11.sent;
                            requestUrl = url + "/auth/sign_in";
                            params = _.merge({ password: keys.pw, email: email }, extraParams);


                            params['api'] = SFHttpManager.getApiVersion();

                            _this3.httpManager.postAbsolute(requestUrl, params, function () {
                              var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(response) {
                                return regeneratorRuntime.wrap(function _callee10$(_context10) {
                                  while (1) {
                                    switch (_context10.prev = _context10.next) {
                                      case 0:
                                        _context10.next = 2;
                                        return _this3.handleAuthResponse(response, email, url, authParams, keys);

                                      case 2:
                                        _this3.notifyEvent(SFAuthManager.DidSignInEvent);
                                        _this3.$timeout(function () {
                                          return _this3.unlockAndResolve(resolve, response);
                                        });

                                      case 4:
                                      case "end":
                                        return _context10.stop();
                                    }
                                  }
                                }, _callee10, _this3);
                              }));

                              return function (_x15) {
                                return _ref12.apply(this, arguments);
                              };
                            }(), function (response) {
                              console.error("Error logging in", response);
                              if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                                response = { error: { message: "A server error occurred while trying to sign in. Please try again." } };
                              }
                              _this3.$timeout(function () {
                                return _this3.unlockAndResolve(resolve, response);
                              });
                            });

                          case 54:
                          case "end":
                            return _context11.stop();
                        }
                      }
                    }, _callee11, _this3);
                  }));

                  return function (_x13, _x14) {
                    return _ref11.apply(this, arguments);
                  };
                }()));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function login(_x8, _x9, _x10, _x11, _x12) {
        return _ref10.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "register",
    value: function register(url, email, password) {
      var _this4 = this;

      return new Promise(function () {
        var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(resolve, reject) {
          var results, keys, authParams, requestUrl, params;
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  if (!_this4.isLocked()) {
                    _context14.next = 3;
                    break;
                  }

                  resolve({ error: { message: "Register already in progress." } });
                  return _context14.abrupt("return");

                case 3:

                  _this4.lock();

                  _context14.next = 6;
                  return SFJS.crypto.generateInitialKeysAndAuthParamsForUser(email, password);

                case 6:
                  results = _context14.sent;
                  keys = results.keys;
                  authParams = results.authParams;
                  requestUrl = url + "/auth";
                  params = _.merge({ password: keys.pw, email: email }, authParams);

                  params['api'] = SFHttpManager.getApiVersion();

                  _this4.httpManager.postAbsolute(requestUrl, params, function () {
                    var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(response) {
                      return regeneratorRuntime.wrap(function _callee13$(_context13) {
                        while (1) {
                          switch (_context13.prev = _context13.next) {
                            case 0:
                              _context13.next = 2;
                              return _this4.handleAuthResponse(response, email, url, authParams, keys);

                            case 2:
                              _this4.unlockAndResolve(resolve, response);

                            case 3:
                            case "end":
                              return _context13.stop();
                          }
                        }
                      }, _callee13, _this4);
                    }));

                    return function (_x18) {
                      return _ref14.apply(this, arguments);
                    };
                  }(), function (response) {
                    console.error("Registration error", response);
                    if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                      response = { error: { message: "A server error occurred while trying to register. Please try again." } };
                    }
                    _this4.unlockAndResolve(resolve, response);
                  });

                case 13:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14, _this4);
        }));

        return function (_x16, _x17) {
          return _ref13.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "changePassword",
    value: function () {
      var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(url, email, current_server_pw, newKeys, newAuthParams) {
        var _this5 = this;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                return _context17.abrupt("return", new Promise(function () {
                  var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(resolve, reject) {
                    var newServerPw, requestUrl, params;
                    return regeneratorRuntime.wrap(function _callee16$(_context16) {
                      while (1) {
                        switch (_context16.prev = _context16.next) {
                          case 0:
                            if (!_this5.isLocked()) {
                              _context16.next = 3;
                              break;
                            }

                            resolve({ error: { message: "Change password already in progress." } });
                            return _context16.abrupt("return");

                          case 3:

                            _this5.lock();

                            newServerPw = newKeys.pw;
                            requestUrl = url + "/auth/change_pw";
                            params = _.merge({ new_password: newServerPw, current_password: current_server_pw }, newAuthParams);

                            params['api'] = SFHttpManager.getApiVersion();

                            _this5.httpManager.postAuthenticatedAbsolute(requestUrl, params, function () {
                              var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(response) {
                                return regeneratorRuntime.wrap(function _callee15$(_context15) {
                                  while (1) {
                                    switch (_context15.prev = _context15.next) {
                                      case 0:
                                        _context15.next = 2;
                                        return _this5.handleAuthResponse(response, email, null, newAuthParams, newKeys);

                                      case 2:
                                        _this5.unlockAndResolve(resolve, response);

                                      case 3:
                                      case "end":
                                        return _context15.stop();
                                    }
                                  }
                                }, _callee15, _this5);
                              }));

                              return function (_x26) {
                                return _ref17.apply(this, arguments);
                              };
                            }(), function (response) {
                              if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                                response = { error: { message: "Something went wrong while changing your password. Your password was not changed. Please try again." } };
                              }
                              _this5.unlockAndResolve(resolve, response);
                            });

                          case 9:
                          case "end":
                            return _context16.stop();
                        }
                      }
                    }, _callee16, _this5);
                  }));

                  return function (_x24, _x25) {
                    return _ref16.apply(this, arguments);
                  };
                }()));

              case 1:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function changePassword(_x19, _x20, _x21, _x22, _x23) {
        return _ref15.apply(this, arguments);
      }

      return changePassword;
    }()
  }, {
    key: "handleAuthResponse",
    value: function () {
      var _ref18 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(response, email, url, authParams, keys) {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!url) {
                  _context18.next = 3;
                  break;
                }

                _context18.next = 3;
                return this.storageManager.setItem("server", url);

              case 3:
                this._authParams = authParams;
                _context18.next = 6;
                return this.storageManager.setItem("auth_params", JSON.stringify(authParams));

              case 6:
                _context18.next = 8;
                return this.storageManager.setItem("jwt", response.token);

              case 8:
                return _context18.abrupt("return", this.saveKeys(keys));

              case 9:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function handleAuthResponse(_x27, _x28, _x29, _x30, _x31) {
        return _ref18.apply(this, arguments);
      }

      return handleAuthResponse;
    }()
  }]);

  return SFAuthManager;
}();

;var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

var SFHttpManager = exports.SFHttpManager = function () {
  _createClass(SFHttpManager, null, [{
    key: "getApiVersion",
    value: function getApiVersion() {
      // Applicable only to Standard File requests. Requests to external acitons should not use this.
      // syncManager and authManager must include this API version as part of its request params.
      return "20190520";
    }
  }]);

  function SFHttpManager(timeout, apiVersion) {
    _classCallCheck(this, SFHttpManager);

    // calling callbacks in a $timeout allows UI to update
    this.$timeout = timeout || setTimeout.bind(globalScope);
  }

  _createClass(SFHttpManager, [{
    key: "setJWTRequestHandler",
    value: function setJWTRequestHandler(handler) {
      this.jwtRequestHandler = handler;
    }
  }, {
    key: "setAuthHeadersForRequest",
    value: function () {
      var _ref19 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(request) {
        var token;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.jwtRequestHandler();

              case 2:
                token = _context19.sent;

                if (token) {
                  request.setRequestHeader('Authorization', 'Bearer ' + token);
                }

              case 4:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function setAuthHeadersForRequest(_x32) {
        return _ref19.apply(this, arguments);
      }

      return setAuthHeadersForRequest;
    }()
  }, {
    key: "postAbsolute",
    value: function () {
      var _ref20 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(url, params, onsuccess, onerror) {
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", this.httpRequest("post", url, params, onsuccess, onerror));

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function postAbsolute(_x33, _x34, _x35, _x36) {
        return _ref20.apply(this, arguments);
      }

      return postAbsolute;
    }()
  }, {
    key: "postAuthenticatedAbsolute",
    value: function () {
      var _ref21 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(url, params, onsuccess, onerror) {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                return _context21.abrupt("return", this.httpRequest("post", url, params, onsuccess, onerror, true));

              case 1:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function postAuthenticatedAbsolute(_x37, _x38, _x39, _x40) {
        return _ref21.apply(this, arguments);
      }

      return postAuthenticatedAbsolute;
    }()
  }, {
    key: "patchAbsolute",
    value: function () {
      var _ref22 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(url, params, onsuccess, onerror) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                return _context22.abrupt("return", this.httpRequest("patch", url, params, onsuccess, onerror));

              case 1:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function patchAbsolute(_x41, _x42, _x43, _x44) {
        return _ref22.apply(this, arguments);
      }

      return patchAbsolute;
    }()
  }, {
    key: "getAbsolute",
    value: function () {
      var _ref23 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(url, params, onsuccess, onerror) {
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                return _context23.abrupt("return", this.httpRequest("get", url, params, onsuccess, onerror));

              case 1:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getAbsolute(_x45, _x46, _x47, _x48) {
        return _ref23.apply(this, arguments);
      }

      return getAbsolute;
    }()
  }, {
    key: "httpRequest",
    value: function () {
      var _ref24 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(verb, url, params, onsuccess, onerror) {
        var _this6 = this;

        var authenticated = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                return _context25.abrupt("return", new Promise(function () {
                  var _ref25 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(resolve, reject) {
                    var xmlhttp;
                    return regeneratorRuntime.wrap(function _callee24$(_context24) {
                      while (1) {
                        switch (_context24.prev = _context24.next) {
                          case 0:
                            xmlhttp = new XMLHttpRequest();


                            xmlhttp.onreadystatechange = function () {
                              if (xmlhttp.readyState == 4) {
                                var response = xmlhttp.responseText;
                                if (response) {
                                  try {
                                    response = JSON.parse(response);
                                  } catch (e) {}
                                }

                                if (xmlhttp.status >= 200 && xmlhttp.status <= 299) {
                                  _this6.$timeout(function () {
                                    onsuccess(response);
                                    resolve(response);
                                  });
                                } else {
                                  console.error("Request error:", response);
                                  _this6.$timeout(function () {
                                    onerror(response, xmlhttp.status);
                                    reject(response);
                                  });
                                }
                              }
                            };

                            if (verb == "get" && Object.keys(params).length > 0) {
                              url = _this6.urlForUrlAndParams(url, params);
                            }

                            xmlhttp.open(verb, url, true);
                            xmlhttp.setRequestHeader('Content-type', 'application/json');

                            if (!authenticated) {
                              _context24.next = 8;
                              break;
                            }

                            _context24.next = 8;
                            return _this6.setAuthHeadersForRequest(xmlhttp);

                          case 8:

                            if (verb == "post" || verb == "patch") {
                              xmlhttp.send(JSON.stringify(params));
                            } else {
                              xmlhttp.send();
                            }

                          case 9:
                          case "end":
                            return _context24.stop();
                        }
                      }
                    }, _callee24, _this6);
                  }));

                  return function (_x55, _x56) {
                    return _ref25.apply(this, arguments);
                  };
                }()));

              case 1:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function httpRequest(_x50, _x51, _x52, _x53, _x54) {
        return _ref24.apply(this, arguments);
      }

      return httpRequest;
    }()
  }, {
    key: "urlForUrlAndParams",
    value: function urlForUrlAndParams(url, params) {
      var keyValueString = Object.keys(params).map(function (key) {
        return key + "=" + encodeURIComponent(params[key]);
      }).join("&");

      if (url.includes("?")) {
        return url + "&" + keyValueString;
      } else {
        return url + "?" + keyValueString;
      }
    }
  }]);

  return SFHttpManager;
}();

;
var SFMigrationManager = exports.SFMigrationManager = function () {
  function SFMigrationManager(modelManager, syncManager, storageManager, authManager) {
    var _this7 = this;

    _classCallCheck(this, SFMigrationManager);

    this.modelManager = modelManager;
    this.syncManager = syncManager;
    this.storageManager = storageManager;

    this.completionHandlers = [];

    this.loadMigrations();

    // The syncManager used to dispatch a param called 'initialSync' in the 'sync:completed' event
    // to let us know of the first sync completion after login.
    // however it was removed as it was deemed to be unreliable (returned wrong value when a single sync request repeats on completion for pagination)
    // We'll now use authManager's events instead
    var didReceiveSignInEvent = false;
    var signInHandler = authManager.addEventHandler(function (event) {
      if (event == SFAuthManager.DidSignInEvent) {
        didReceiveSignInEvent = true;
      }
    });

    this.receivedLocalDataEvent = syncManager.initialDataLoaded();

    this.syncManager.addEventHandler(function () {
      var _ref26 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(event, data) {
        var dataLoadedEvent, syncCompleteEvent, completedList, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, migrationName, migration;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                dataLoadedEvent = event == "local-data-loaded";
                syncCompleteEvent = event == "sync:completed";

                if (!(dataLoadedEvent || syncCompleteEvent)) {
                  _context26.next = 40;
                  break;
                }

                if (dataLoadedEvent) {
                  _this7.receivedLocalDataEvent = true;
                } else if (syncCompleteEvent) {
                  _this7.receivedSyncCompletedEvent = true;
                }

                // We want to run pending migrations only after local data has been loaded, and a sync has been completed.

                if (!(_this7.receivedLocalDataEvent && _this7.receivedSyncCompletedEvent)) {
                  _context26.next = 40;
                  break;
                }

                if (!didReceiveSignInEvent) {
                  _context26.next = 39;
                  break;
                }

                // Reset our collected state about sign in
                didReceiveSignInEvent = false;
                authManager.removeEventHandler(signInHandler);

                // If initial online sync, clear any completed migrations that occurred while offline,
                // so they can run again now that we have updated user items. Only clear migrations that
                // don't have `runOnlyOnce` set
                _context26.next = 10;
                return _this7.getCompletedMigrations();

              case 10:
                completedList = _context26.sent.slice();
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context26.prev = 14;
                _iterator2 = completedList[Symbol.iterator]();

              case 16:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context26.next = 25;
                  break;
                }

                migrationName = _step2.value;
                _context26.next = 20;
                return _this7.migrationForEncodedName(migrationName);

              case 20:
                migration = _context26.sent;

                if (!migration.runOnlyOnce) {
                  _.pull(_this7._completed, migrationName);
                }

              case 22:
                _iteratorNormalCompletion2 = true;
                _context26.next = 16;
                break;

              case 25:
                _context26.next = 31;
                break;

              case 27:
                _context26.prev = 27;
                _context26.t0 = _context26["catch"](14);
                _didIteratorError2 = true;
                _iteratorError2 = _context26.t0;

              case 31:
                _context26.prev = 31;
                _context26.prev = 32;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 34:
                _context26.prev = 34;

                if (!_didIteratorError2) {
                  _context26.next = 37;
                  break;
                }

                throw _iteratorError2;

              case 37:
                return _context26.finish(34);

              case 38:
                return _context26.finish(31);

              case 39:
                _this7.runPendingMigrations();

              case 40:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, _this7, [[14, 27, 31, 39], [32,, 34, 38]]);
      }));

      return function (_x57, _x58) {
        return _ref26.apply(this, arguments);
      };
    }());
  }

  _createClass(SFMigrationManager, [{
    key: "addCompletionHandler",
    value: function addCompletionHandler(handler) {
      this.completionHandlers.push(handler);
    }
  }, {
    key: "removeCompletionHandler",
    value: function removeCompletionHandler(handler) {
      _.pull(this.completionHandlers, handler);
    }
  }, {
    key: "migrationForEncodedName",
    value: function () {
      var _ref27 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(name) {
        var decoded;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this.decode(name);

              case 2:
                decoded = _context27.sent;
                return _context27.abrupt("return", this.migrations.find(function (migration) {
                  return migration.name == decoded;
                }));

              case 4:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function migrationForEncodedName(_x59) {
        return _ref27.apply(this, arguments);
      }

      return migrationForEncodedName;
    }()
  }, {
    key: "loadMigrations",
    value: function loadMigrations() {
      this.migrations = this.registeredMigrations();
    }
  }, {
    key: "registeredMigrations",
    value: function registeredMigrations() {
      // Subclasses should return an array of migrations here.
      // Migrations should have a unique `name`, `content_type`,
      // and `handler`, which is a function that accepts an array of matching items to migration.
    }
  }, {
    key: "runPendingMigrations",
    value: function () {
      var _ref28 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var pending, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, migration, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, item, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, handler;

        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getPendingMigrations();

              case 2:
                pending = _context28.sent;


                // run in pre loop, keeping in mind that a migration may be run twice: when offline then again when signing in.
                // we need to reset the items to a new array.
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context28.prev = 6;
                for (_iterator3 = pending[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  migration = _step3.value;

                  migration.items = [];
                }

                _context28.next = 14;
                break;

              case 10:
                _context28.prev = 10;
                _context28.t0 = _context28["catch"](6);
                _didIteratorError3 = true;
                _iteratorError3 = _context28.t0;

              case 14:
                _context28.prev = 14;
                _context28.prev = 15;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 17:
                _context28.prev = 17;

                if (!_didIteratorError3) {
                  _context28.next = 20;
                  break;
                }

                throw _iteratorError3;

              case 20:
                return _context28.finish(17);

              case 21:
                return _context28.finish(14);

              case 22:
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                _context28.prev = 25;
                _iterator4 = this.modelManager.allNondummyItems[Symbol.iterator]();

              case 27:
                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                  _context28.next = 51;
                  break;
                }

                item = _step4.value;
                _iteratorNormalCompletion7 = true;
                _didIteratorError7 = false;
                _iteratorError7 = undefined;
                _context28.prev = 32;

                for (_iterator7 = pending[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  migration = _step7.value;

                  if (item.content_type == migration.content_type) {
                    migration.items.push(item);
                  }
                }
                _context28.next = 40;
                break;

              case 36:
                _context28.prev = 36;
                _context28.t1 = _context28["catch"](32);
                _didIteratorError7 = true;
                _iteratorError7 = _context28.t1;

              case 40:
                _context28.prev = 40;
                _context28.prev = 41;

                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }

              case 43:
                _context28.prev = 43;

                if (!_didIteratorError7) {
                  _context28.next = 46;
                  break;
                }

                throw _iteratorError7;

              case 46:
                return _context28.finish(43);

              case 47:
                return _context28.finish(40);

              case 48:
                _iteratorNormalCompletion4 = true;
                _context28.next = 27;
                break;

              case 51:
                _context28.next = 57;
                break;

              case 53:
                _context28.prev = 53;
                _context28.t2 = _context28["catch"](25);
                _didIteratorError4 = true;
                _iteratorError4 = _context28.t2;

              case 57:
                _context28.prev = 57;
                _context28.prev = 58;

                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }

              case 60:
                _context28.prev = 60;

                if (!_didIteratorError4) {
                  _context28.next = 63;
                  break;
                }

                throw _iteratorError4;

              case 63:
                return _context28.finish(60);

              case 64:
                return _context28.finish(57);

              case 65:
                _iteratorNormalCompletion5 = true;
                _didIteratorError5 = false;
                _iteratorError5 = undefined;
                _context28.prev = 68;
                _iterator5 = pending[Symbol.iterator]();

              case 70:
                if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                  _context28.next = 81;
                  break;
                }

                migration = _step5.value;

                if (!(migration.items && migration.items.length > 0 || migration.customHandler)) {
                  _context28.next = 77;
                  break;
                }

                _context28.next = 75;
                return this.runMigration(migration, migration.items);

              case 75:
                _context28.next = 78;
                break;

              case 77:
                this.markMigrationCompleted(migration);

              case 78:
                _iteratorNormalCompletion5 = true;
                _context28.next = 70;
                break;

              case 81:
                _context28.next = 87;
                break;

              case 83:
                _context28.prev = 83;
                _context28.t3 = _context28["catch"](68);
                _didIteratorError5 = true;
                _iteratorError5 = _context28.t3;

              case 87:
                _context28.prev = 87;
                _context28.prev = 88;

                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }

              case 90:
                _context28.prev = 90;

                if (!_didIteratorError5) {
                  _context28.next = 93;
                  break;
                }

                throw _iteratorError5;

              case 93:
                return _context28.finish(90);

              case 94:
                return _context28.finish(87);

              case 95:
                _iteratorNormalCompletion6 = true;
                _didIteratorError6 = false;
                _iteratorError6 = undefined;
                _context28.prev = 98;


                for (_iterator6 = this.completionHandlers[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  handler = _step6.value;

                  handler();
                }
                _context28.next = 106;
                break;

              case 102:
                _context28.prev = 102;
                _context28.t4 = _context28["catch"](98);
                _didIteratorError6 = true;
                _iteratorError6 = _context28.t4;

              case 106:
                _context28.prev = 106;
                _context28.prev = 107;

                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
                }

              case 109:
                _context28.prev = 109;

                if (!_didIteratorError6) {
                  _context28.next = 112;
                  break;
                }

                throw _iteratorError6;

              case 112:
                return _context28.finish(109);

              case 113:
                return _context28.finish(106);

              case 114:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this, [[6, 10, 14, 22], [15,, 17, 21], [25, 53, 57, 65], [32, 36, 40, 48], [41,, 43, 47], [58,, 60, 64], [68, 83, 87, 95], [88,, 90, 94], [98, 102, 106, 114], [107,, 109, 113]]);
      }));

      function runPendingMigrations() {
        return _ref28.apply(this, arguments);
      }

      return runPendingMigrations;
    }()
  }, {
    key: "encode",
    value: function () {
      var _ref29 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(text) {
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                return _context29.abrupt("return", window.btoa(text));

              case 1:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function encode(_x60) {
        return _ref29.apply(this, arguments);
      }

      return encode;
    }()
  }, {
    key: "decode",
    value: function () {
      var _ref30 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(text) {
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                return _context30.abrupt("return", window.atob(text));

              case 1:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function decode(_x61) {
        return _ref30.apply(this, arguments);
      }

      return decode;
    }()
  }, {
    key: "getCompletedMigrations",
    value: function () {
      var _ref31 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31() {
        var rawCompleted;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (this._completed) {
                  _context31.next = 5;
                  break;
                }

                _context31.next = 3;
                return this.storageManager.getItem("migrations");

              case 3:
                rawCompleted = _context31.sent;

                if (rawCompleted) {
                  this._completed = JSON.parse(rawCompleted);
                } else {
                  this._completed = [];
                }

              case 5:
                return _context31.abrupt("return", this._completed);

              case 6:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getCompletedMigrations() {
        return _ref31.apply(this, arguments);
      }

      return getCompletedMigrations;
    }()
  }, {
    key: "getPendingMigrations",
    value: function () {
      var _ref32 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32() {
        var completed, pending, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, migration;

        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getCompletedMigrations();

              case 2:
                completed = _context32.sent;
                pending = [];
                _iteratorNormalCompletion8 = true;
                _didIteratorError8 = false;
                _iteratorError8 = undefined;
                _context32.prev = 7;
                _iterator8 = this.migrations[Symbol.iterator]();

              case 9:
                if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                  _context32.next = 22;
                  break;
                }

                migration = _step8.value;
                _context32.t0 = completed;
                _context32.next = 14;
                return this.encode(migration.name);

              case 14:
                _context32.t1 = _context32.sent;
                _context32.t2 = _context32.t0.indexOf.call(_context32.t0, _context32.t1);
                _context32.t3 = -1;

                if (!(_context32.t2 == _context32.t3)) {
                  _context32.next = 19;
                  break;
                }

                pending.push(migration);

              case 19:
                _iteratorNormalCompletion8 = true;
                _context32.next = 9;
                break;

              case 22:
                _context32.next = 28;
                break;

              case 24:
                _context32.prev = 24;
                _context32.t4 = _context32["catch"](7);
                _didIteratorError8 = true;
                _iteratorError8 = _context32.t4;

              case 28:
                _context32.prev = 28;
                _context32.prev = 29;

                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                  _iterator8.return();
                }

              case 31:
                _context32.prev = 31;

                if (!_didIteratorError8) {
                  _context32.next = 34;
                  break;
                }

                throw _iteratorError8;

              case 34:
                return _context32.finish(31);

              case 35:
                return _context32.finish(28);

              case 36:
                return _context32.abrupt("return", pending);

              case 37:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this, [[7, 24, 28, 36], [29,, 31, 35]]);
      }));

      function getPendingMigrations() {
        return _ref32.apply(this, arguments);
      }

      return getPendingMigrations;
    }()
  }, {
    key: "markMigrationCompleted",
    value: function () {
      var _ref33 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(migration) {
        var completed;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.getCompletedMigrations();

              case 2:
                completed = _context33.sent;
                _context33.t0 = completed;
                _context33.next = 6;
                return this.encode(migration.name);

              case 6:
                _context33.t1 = _context33.sent;

                _context33.t0.push.call(_context33.t0, _context33.t1);

                this.storageManager.setItem("migrations", JSON.stringify(completed));
                migration.running = false;

              case 10:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function markMigrationCompleted(_x62) {
        return _ref33.apply(this, arguments);
      }

      return markMigrationCompleted;
    }()
  }, {
    key: "runMigration",
    value: function () {
      var _ref34 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(migration, items) {
        var _this8 = this;

        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                if (!migration.running) {
                  _context34.next = 2;
                  break;
                }

                return _context34.abrupt("return");

              case 2:

                console.log("Running migration:", migration.name);

                migration.running = true;

                if (!migration.customHandler) {
                  _context34.next = 8;
                  break;
                }

                return _context34.abrupt("return", migration.customHandler().then(function () {
                  _this8.markMigrationCompleted(migration);
                }));

              case 8:
                return _context34.abrupt("return", migration.handler(items).then(function () {
                  _this8.markMigrationCompleted(migration);
                }));

              case 9:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function runMigration(_x63, _x64) {
        return _ref34.apply(this, arguments);
      }

      return runMigration;
    }()
  }]);

  return SFMigrationManager;
}();

;
var SFModelManager = exports.SFModelManager = function () {
  function SFModelManager(timeout) {
    _classCallCheck(this, SFModelManager);

    SFModelManager.MappingSourceRemoteRetrieved = "MappingSourceRemoteRetrieved";
    SFModelManager.MappingSourceRemoteSaved = "MappingSourceRemoteSaved";
    SFModelManager.MappingSourceLocalSaved = "MappingSourceLocalSaved";
    SFModelManager.MappingSourceLocalRetrieved = "MappingSourceLocalRetrieved";
    SFModelManager.MappingSourceLocalDirtied = "MappingSourceLocalDirtied";
    SFModelManager.MappingSourceComponentRetrieved = "MappingSourceComponentRetrieved";
    SFModelManager.MappingSourceDesktopInstalled = "MappingSourceDesktopInstalled"; // When a component is installed by the desktop and some of its values change
    SFModelManager.MappingSourceRemoteActionRetrieved = "MappingSourceRemoteActionRetrieved"; /* aciton-based Extensions like note history */
    SFModelManager.MappingSourceFileImport = "MappingSourceFileImport";

    SFModelManager.isMappingSourceRetrieved = function (source) {
      return [SFModelManager.MappingSourceRemoteRetrieved, SFModelManager.MappingSourceComponentRetrieved, SFModelManager.MappingSourceRemoteActionRetrieved].includes(source);
    };

    this.$timeout = timeout || setTimeout.bind(window);

    this.itemSyncObservers = [];
    this.items = [];
    this.itemsHash = {};
    this.missedReferences = {};
    this.uuidChangeObservers = [];
  }

  _createClass(SFModelManager, [{
    key: "handleSignout",
    value: function handleSignout() {
      this.items.length = 0;
      this.itemsHash = {};
      this.missedReferences = {};
    }
  }, {
    key: "addModelUuidChangeObserver",
    value: function addModelUuidChangeObserver(id, callback) {
      this.uuidChangeObservers.push({ id: id, callback: callback });
    }
  }, {
    key: "notifyObserversOfUuidChange",
    value: function notifyObserversOfUuidChange(oldItem, newItem) {
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this.uuidChangeObservers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var observer = _step9.value;

          try {
            observer.callback(oldItem, newItem);
          } catch (e) {
            console.error("Notify observers of uuid change exception:", e);
          }
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
  }, {
    key: "alternateUUIDForItem",
    value: function () {
      var _ref35 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(item) {
        var newItem, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, referencingObject;

        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                // We need to clone this item and give it a new uuid, then delete item with old uuid from db (you can't modify uuid's in our indexeddb setup)
                newItem = this.createItem(item);
                _context35.next = 3;
                return SFJS.crypto.generateUUID();

              case 3:
                newItem.uuid = _context35.sent;


                // Update uuids of relationships
                newItem.informReferencesOfUUIDChange(item.uuid, newItem.uuid);
                this.informModelsOfUUIDChangeForItem(newItem, item.uuid, newItem.uuid);

                // the new item should inherit the original's relationships
                _iteratorNormalCompletion10 = true;
                _didIteratorError10 = false;
                _iteratorError10 = undefined;
                _context35.prev = 9;
                for (_iterator10 = item.referencingObjects[Symbol.iterator](); !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  referencingObject = _step10.value;

                  referencingObject.setIsNoLongerBeingReferencedBy(item);
                  item.setIsNoLongerBeingReferencedBy(referencingObject);
                  referencingObject.addItemAsRelationship(newItem);
                }

                _context35.next = 17;
                break;

              case 13:
                _context35.prev = 13;
                _context35.t0 = _context35["catch"](9);
                _didIteratorError10 = true;
                _iteratorError10 = _context35.t0;

              case 17:
                _context35.prev = 17;
                _context35.prev = 18;

                if (!_iteratorNormalCompletion10 && _iterator10.return) {
                  _iterator10.return();
                }

              case 20:
                _context35.prev = 20;

                if (!_didIteratorError10) {
                  _context35.next = 23;
                  break;
                }

                throw _iteratorError10;

              case 23:
                return _context35.finish(20);

              case 24:
                return _context35.finish(17);

              case 25:
                this.setItemsDirty(item.referencingObjects, true);

                // Used to set up referencingObjects for new item (so that other items can now properly reference this new item)
                this.resolveReferencesForItem(newItem);

                if (this.loggingEnabled) {
                  console.log(item.uuid, "-->", newItem.uuid);
                }

                // Set to deleted, then run through mapping function so that observers can be notified
                item.deleted = true;
                item.content.references = [];
                // Don't set dirty, because we don't need to sync old item. alternating uuid only occurs in two cases:
                // signing in and merging offline data, or when a uuid-conflict occurs. In both cases, the original item never
                // saves to a server, so doesn't need to be synced.
                // informModelsOfUUIDChangeForItem may set this object to dirty, but we want to undo that here, so that the item gets deleted
                // right away through the mapping function.
                this.setItemDirty(item, false, false, SFModelManager.MappingSourceLocalSaved);
                _context35.next = 33;
                return this.mapResponseItemsToLocalModels([item], SFModelManager.MappingSourceLocalSaved);

              case 33:

                // add new item
                this.addItem(newItem);
                this.setItemDirty(newItem, true, true, SFModelManager.MappingSourceLocalSaved);

                this.notifyObserversOfUuidChange(item, newItem);

                return _context35.abrupt("return", newItem);

              case 37:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this, [[9, 13, 17, 25], [18,, 20, 24]]);
      }));

      function alternateUUIDForItem(_x65) {
        return _ref35.apply(this, arguments);
      }

      return alternateUUIDForItem;
    }()
  }, {
    key: "informModelsOfUUIDChangeForItem",
    value: function informModelsOfUUIDChangeForItem(newItem, oldUUID, newUUID) {
      // some models that only have one-way relationships might be interested to hear that an item has changed its uuid
      // for example, editors have a one way relationship with notes. When a note changes its UUID, it has no way to inform the editor
      // to update its relationships

      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = this.items[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var model = _step11.value;

          model.potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID);
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11.return) {
            _iterator11.return();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }
    }
  }, {
    key: "didSyncModelsOffline",
    value: function didSyncModelsOffline(items) {
      this.notifySyncObserversOfModels(items, SFModelManager.MappingSourceLocalSaved);
    }
  }, {
    key: "mapResponseItemsToLocalModels",
    value: function () {
      var _ref36 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(items, source, sourceKey) {
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                return _context36.abrupt("return", this.mapResponseItemsToLocalModelsWithOptions({ items: items, source: source, sourceKey: sourceKey }));

              case 1:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function mapResponseItemsToLocalModels(_x66, _x67, _x68) {
        return _ref36.apply(this, arguments);
      }

      return mapResponseItemsToLocalModels;
    }()
  }, {
    key: "mapResponseItemsToLocalModelsOmittingFields",
    value: function () {
      var _ref37 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(items, omitFields, source, sourceKey) {
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                return _context37.abrupt("return", this.mapResponseItemsToLocalModelsWithOptions({ items: items, omitFields: omitFields, source: source, sourceKey: sourceKey }));

              case 1:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function mapResponseItemsToLocalModelsOmittingFields(_x69, _x70, _x71, _x72) {
        return _ref37.apply(this, arguments);
      }

      return mapResponseItemsToLocalModelsOmittingFields;
    }()
  }, {
    key: "mapResponseItemsToLocalModelsWithOptions",
    value: function () {
      var _ref39 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(_ref38) {
        var items = _ref38.items,
            omitFields = _ref38.omitFields,
            source = _ref38.source,
            sourceKey = _ref38.sourceKey,
            options = _ref38.options;

        var models, processedObjects, modelsToNotifyObserversOf, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, json_obj, isMissingContent, isCorrupt, _iteratorNormalCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, key, item, contentType, unknownContentType, isDirtyItemPendingDelete, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, _ref40, _ref41, index, _json_obj, model, missedRefs, _loop, _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, ref;

        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                models = [], processedObjects = [], modelsToNotifyObserversOf = [];

                // first loop should add and process items

                _iteratorNormalCompletion12 = true;
                _didIteratorError12 = false;
                _iteratorError12 = undefined;
                _context38.prev = 4;
                _iterator12 = items[Symbol.iterator]();

              case 6:
                if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
                  _context38.next = 57;
                  break;
                }

                json_obj = _step12.value;

                if (json_obj) {
                  _context38.next = 10;
                  break;
                }

                return _context38.abrupt("continue", 54);

              case 10:

                // content is missing if it has been sucessfullly decrypted but no content
                isMissingContent = !json_obj.content && !json_obj.errorDecrypting;
                isCorrupt = !json_obj.content_type || !json_obj.uuid;

                if (!((isCorrupt || isMissingContent) && !json_obj.deleted)) {
                  _context38.next = 15;
                  break;
                }

                // An item that is not deleted should never have empty content
                console.error("Server response item is corrupt:", json_obj);
                return _context38.abrupt("continue", 54);

              case 15:
                if (!Array.isArray(omitFields)) {
                  _context38.next = 35;
                  break;
                }

                _iteratorNormalCompletion15 = true;
                _didIteratorError15 = false;
                _iteratorError15 = undefined;
                _context38.prev = 19;

                for (_iterator15 = omitFields[Symbol.iterator](); !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                  key = _step15.value;

                  delete json_obj[key];
                }
                _context38.next = 27;
                break;

              case 23:
                _context38.prev = 23;
                _context38.t0 = _context38["catch"](19);
                _didIteratorError15 = true;
                _iteratorError15 = _context38.t0;

              case 27:
                _context38.prev = 27;
                _context38.prev = 28;

                if (!_iteratorNormalCompletion15 && _iterator15.return) {
                  _iterator15.return();
                }

              case 30:
                _context38.prev = 30;

                if (!_didIteratorError15) {
                  _context38.next = 33;
                  break;
                }

                throw _iteratorError15;

              case 33:
                return _context38.finish(30);

              case 34:
                return _context38.finish(27);

              case 35:
                item = this.findItem(json_obj.uuid);


                if (item) {
                  item.updateFromJSON(json_obj);
                  // If an item goes through mapping, it can no longer be a dummy.
                  item.dummy = false;
                }

                contentType = json_obj["content_type"] || item && item.content_type;
                unknownContentType = this.acceptableContentTypes && !this.acceptableContentTypes.includes(contentType);

                if (!unknownContentType) {
                  _context38.next = 41;
                  break;
                }

                return _context38.abrupt("continue", 54);

              case 41:
                isDirtyItemPendingDelete = false;

                if (!(json_obj.deleted == true)) {
                  _context38.next = 49;
                  break;
                }

                if (!json_obj.dirty) {
                  _context38.next = 47;
                  break;
                }

                // Item was marked as deleted but not yet synced (in offline scenario)
                // We need to create this item as usual, but just not add it to individual arrays
                // i.e add to this.items but not this.notes (so that it can be retrieved with getDirtyItems)
                isDirtyItemPendingDelete = true;
                _context38.next = 49;
                break;

              case 47:
                if (item) {
                  // We still want to return this item to the caller so they know it was handled.
                  models.push(item);

                  modelsToNotifyObserversOf.push(item);
                  this.removeItemLocally(item);
                }
                return _context38.abrupt("continue", 54);

              case 49:

                if (!item) {
                  item = this.createItem(json_obj);
                }

                this.addItem(item, isDirtyItemPendingDelete);

                // Observers do not need to handle items that errored while decrypting.
                if (!item.errorDecrypting) {
                  modelsToNotifyObserversOf.push(item);
                }

                models.push(item);
                processedObjects.push(json_obj);

              case 54:
                _iteratorNormalCompletion12 = true;
                _context38.next = 6;
                break;

              case 57:
                _context38.next = 63;
                break;

              case 59:
                _context38.prev = 59;
                _context38.t1 = _context38["catch"](4);
                _didIteratorError12 = true;
                _iteratorError12 = _context38.t1;

              case 63:
                _context38.prev = 63;
                _context38.prev = 64;

                if (!_iteratorNormalCompletion12 && _iterator12.return) {
                  _iterator12.return();
                }

              case 66:
                _context38.prev = 66;

                if (!_didIteratorError12) {
                  _context38.next = 69;
                  break;
                }

                throw _iteratorError12;

              case 69:
                return _context38.finish(66);

              case 70:
                return _context38.finish(63);

              case 71:

                // second loop should process references
                _iteratorNormalCompletion13 = true;
                _didIteratorError13 = false;
                _iteratorError13 = undefined;
                _context38.prev = 74;
                for (_iterator13 = processedObjects.entries()[Symbol.iterator](); !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                  _ref40 = _step13.value;
                  _ref41 = _slicedToArray(_ref40, 2);
                  index = _ref41[0];
                  _json_obj = _ref41[1];
                  model = models[index];

                  if (_json_obj.content) {
                    this.resolveReferencesForItem(model);
                  }

                  model.didFinishSyncing();
                }

                _context38.next = 82;
                break;

              case 78:
                _context38.prev = 78;
                _context38.t2 = _context38["catch"](74);
                _didIteratorError13 = true;
                _iteratorError13 = _context38.t2;

              case 82:
                _context38.prev = 82;
                _context38.prev = 83;

                if (!_iteratorNormalCompletion13 && _iterator13.return) {
                  _iterator13.return();
                }

              case 85:
                _context38.prev = 85;

                if (!_didIteratorError13) {
                  _context38.next = 88;
                  break;
                }

                throw _iteratorError13;

              case 88:
                return _context38.finish(85);

              case 89:
                return _context38.finish(82);

              case 90:
                missedRefs = this.popMissedReferenceStructsForObjects(processedObjects);

                _loop = function _loop(ref) {
                  var model = models.find(function (candidate) {
                    return candidate.uuid == ref.reference_uuid;
                  });
                  // Model should 100% be defined here, but let's not be too overconfident
                  if (model) {
                    var itemWaitingForTheValueInThisCurrentLoop = ref.for_item;
                    itemWaitingForTheValueInThisCurrentLoop.addItemAsRelationship(model);
                  }
                };

                _iteratorNormalCompletion14 = true;
                _didIteratorError14 = false;
                _iteratorError14 = undefined;
                _context38.prev = 95;

                for (_iterator14 = missedRefs[Symbol.iterator](); !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                  ref = _step14.value;

                  _loop(ref);
                }

                _context38.next = 103;
                break;

              case 99:
                _context38.prev = 99;
                _context38.t3 = _context38["catch"](95);
                _didIteratorError14 = true;
                _iteratorError14 = _context38.t3;

              case 103:
                _context38.prev = 103;
                _context38.prev = 104;

                if (!_iteratorNormalCompletion14 && _iterator14.return) {
                  _iterator14.return();
                }

              case 106:
                _context38.prev = 106;

                if (!_didIteratorError14) {
                  _context38.next = 109;
                  break;
                }

                throw _iteratorError14;

              case 109:
                return _context38.finish(106);

              case 110:
                return _context38.finish(103);

              case 111:
                _context38.next = 113;
                return this.notifySyncObserversOfModels(modelsToNotifyObserversOf, source, sourceKey);

              case 113:
                return _context38.abrupt("return", models);

              case 114:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this, [[4, 59, 63, 71], [19, 23, 27, 35], [28,, 30, 34], [64,, 66, 70], [74, 78, 82, 90], [83,, 85, 89], [95, 99, 103, 111], [104,, 106, 110]]);
      }));

      function mapResponseItemsToLocalModelsWithOptions(_x73) {
        return _ref39.apply(this, arguments);
      }

      return mapResponseItemsToLocalModelsWithOptions;
    }()
  }, {
    key: "missedReferenceBuildKey",
    value: function missedReferenceBuildKey(referenceId, objectId) {
      return referenceId + ":" + objectId;
    }
  }, {
    key: "popMissedReferenceStructsForObjects",
    value: function popMissedReferenceStructsForObjects(objects) {
      if (!objects || objects.length == 0) {
        return [];
      }

      var results = [];
      var toDelete = [];
      var uuids = objects.map(function (item) {
        return item.uuid;
      });
      var genericUuidLength = uuids[0].length;

      var keys = Object.keys(this.missedReferences);
      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = keys[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var candidateKey = _step16.value;

          /*
          We used to do string.split to get at the UUID, but surprisingly,
          the performance of this was about 20x worse then just getting the substring.
           let matches = candidateKey.split(":")[0] == object.uuid;
          */
          var matches = uuids.includes(candidateKey.substring(0, genericUuidLength));
          if (matches) {
            results.push(this.missedReferences[candidateKey]);
            toDelete.push(candidateKey);
          }
        }

        // remove from hash
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16.return) {
            _iterator16.return();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = toDelete[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var key = _step17.value;

          delete this.missedReferences[key];
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17.return) {
            _iterator17.return();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }

      return results;
    }
  }, {
    key: "resolveReferencesForItem",
    value: function resolveReferencesForItem(item) {
      var markReferencesDirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


      if (item.errorDecrypting) {
        return;
      }

      var contentObject = item.contentObject;

      // If another client removes an item's references, this client won't pick up the removal unless
      // we remove everything not present in the current list of references
      item.updateLocalRelationships();

      if (!contentObject.references) {
        return;
      }

      var references = contentObject.references.slice(); // make copy, references will be modified in array

      var referencesIds = references.map(function (ref) {
        return ref.uuid;
      });
      var includeBlanks = true;
      var referencesObjectResults = this.findItems(referencesIds, includeBlanks);

      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = referencesObjectResults.entries()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var _ref42 = _step18.value;

          var _ref43 = _slicedToArray(_ref42, 2);

          var index = _ref43[0];
          var referencedItem = _ref43[1];

          if (referencedItem) {
            item.addItemAsRelationship(referencedItem);
            if (markReferencesDirty) {
              this.setItemDirty(referencedItem, true);
            }
          } else {
            var missingRefId = referencesIds[index];
            // Allows mapper to check when missing reference makes it through the loop,
            // and then runs resolveReferencesForItem again for the original item.
            var mappingKey = this.missedReferenceBuildKey(missingRefId, item.uuid);
            if (!this.missedReferences[mappingKey]) {
              var missedRef = { reference_uuid: missingRefId, for_item: item };
              this.missedReferences[mappingKey] = missedRef;
            }
          }
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18.return) {
            _iterator18.return();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }
    }

    /* Note that this function is public, and can also be called manually (desktopManager uses it) */

  }, {
    key: "notifySyncObserversOfModels",
    value: function () {
      var _ref44 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(models, source, sourceKey) {
        var _this9 = this;

        var observers, _loop2, _iteratorNormalCompletion19, _didIteratorError19, _iteratorError19, _iterator19, _step19, observer;

        return regeneratorRuntime.wrap(function _callee39$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                // Make sure `let` is used in the for loops instead of `var`, as we will be using a timeout below.
                observers = this.itemSyncObservers.sort(function (a, b) {
                  // sort by priority
                  return a.priority < b.priority ? -1 : 1;
                });
                _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2(observer) {
                  var allRelevantItems, validItems, deletedItems, _iteratorNormalCompletion20, _didIteratorError20, _iteratorError20, _iterator20, _step20, item;

                  return regeneratorRuntime.wrap(function _loop2$(_context39) {
                    while (1) {
                      switch (_context39.prev = _context39.next) {
                        case 0:
                          allRelevantItems = observer.types.includes("*") ? models : models.filter(function (item) {
                            return observer.types.includes(item.content_type);
                          });
                          validItems = [], deletedItems = [];
                          _iteratorNormalCompletion20 = true;
                          _didIteratorError20 = false;
                          _iteratorError20 = undefined;
                          _context39.prev = 5;

                          for (_iterator20 = allRelevantItems[Symbol.iterator](); !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                            item = _step20.value;

                            if (item.deleted) {
                              deletedItems.push(item);
                            } else {
                              validItems.push(item);
                            }
                          }

                          _context39.next = 13;
                          break;

                        case 9:
                          _context39.prev = 9;
                          _context39.t0 = _context39["catch"](5);
                          _didIteratorError20 = true;
                          _iteratorError20 = _context39.t0;

                        case 13:
                          _context39.prev = 13;
                          _context39.prev = 14;

                          if (!_iteratorNormalCompletion20 && _iterator20.return) {
                            _iterator20.return();
                          }

                        case 16:
                          _context39.prev = 16;

                          if (!_didIteratorError20) {
                            _context39.next = 19;
                            break;
                          }

                          throw _iteratorError20;

                        case 19:
                          return _context39.finish(16);

                        case 20:
                          return _context39.finish(13);

                        case 21:
                          if (!(allRelevantItems.length > 0)) {
                            _context39.next = 24;
                            break;
                          }

                          _context39.next = 24;
                          return _this9._callSyncObserverCallbackWithTimeout(observer, allRelevantItems, validItems, deletedItems, source, sourceKey);

                        case 24:
                        case "end":
                          return _context39.stop();
                      }
                    }
                  }, _loop2, _this9, [[5, 9, 13, 21], [14,, 16, 20]]);
                });
                _iteratorNormalCompletion19 = true;
                _didIteratorError19 = false;
                _iteratorError19 = undefined;
                _context40.prev = 5;
                _iterator19 = observers[Symbol.iterator]();

              case 7:
                if (_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done) {
                  _context40.next = 13;
                  break;
                }

                observer = _step19.value;
                return _context40.delegateYield(_loop2(observer), "t0", 10);

              case 10:
                _iteratorNormalCompletion19 = true;
                _context40.next = 7;
                break;

              case 13:
                _context40.next = 19;
                break;

              case 15:
                _context40.prev = 15;
                _context40.t1 = _context40["catch"](5);
                _didIteratorError19 = true;
                _iteratorError19 = _context40.t1;

              case 19:
                _context40.prev = 19;
                _context40.prev = 20;

                if (!_iteratorNormalCompletion19 && _iterator19.return) {
                  _iterator19.return();
                }

              case 22:
                _context40.prev = 22;

                if (!_didIteratorError19) {
                  _context40.next = 25;
                  break;
                }

                throw _iteratorError19;

              case 25:
                return _context40.finish(22);

              case 26:
                return _context40.finish(19);

              case 27:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee39, this, [[5, 15, 19, 27], [20,, 22, 26]]);
      }));

      function notifySyncObserversOfModels(_x75, _x76, _x77) {
        return _ref44.apply(this, arguments);
      }

      return notifySyncObserversOfModels;
    }()

    /*
      Rather than running this inline in a for loop, which causes problems and requires all variables to be declared with `let`,
      we'll do it here so it's more explicit and less confusing.
     */

  }, {
    key: "_callSyncObserverCallbackWithTimeout",
    value: function () {
      var _ref45 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(observer, allRelevantItems, validItems, deletedItems, source, sourceKey) {
        var _this10 = this;

        return regeneratorRuntime.wrap(function _callee40$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                return _context41.abrupt("return", new Promise(function (resolve, reject) {
                  _this10.$timeout(function () {
                    try {
                      observer.callback(allRelevantItems, validItems, deletedItems, source, sourceKey);
                    } catch (e) {
                      console.error("Sync observer exception", e);
                    } finally {
                      resolve();
                    }
                  });
                }));

              case 1:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee40, this);
      }));

      function _callSyncObserverCallbackWithTimeout(_x78, _x79, _x80, _x81, _x82, _x83) {
        return _ref45.apply(this, arguments);
      }

      return _callSyncObserverCallbackWithTimeout;
    }()

    // When a client sets an item as dirty, it means its values has changed, and everyone should know about it.
    // Particularly extensions. For example, if you edit the title of a note, extensions won't be notified until the save sync completes.
    // With this, they'll be notified immediately.

  }, {
    key: "setItemDirty",
    value: function setItemDirty(item) {
      var dirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var updateClientDate = arguments[2];
      var source = arguments[3];
      var sourceKey = arguments[4];

      this.setItemsDirty([item], dirty, updateClientDate, source, sourceKey);
    }
  }, {
    key: "setItemsDirty",
    value: function setItemsDirty(items) {
      var dirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var updateClientDate = arguments[2];
      var source = arguments[3];
      var sourceKey = arguments[4];
      var _iteratorNormalCompletion21 = true;
      var _didIteratorError21 = false;
      var _iteratorError21 = undefined;

      try {
        for (var _iterator21 = items[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
          var item = _step21.value;

          item.setDirty(dirty, updateClientDate);
        }
      } catch (err) {
        _didIteratorError21 = true;
        _iteratorError21 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion21 && _iterator21.return) {
            _iterator21.return();
          }
        } finally {
          if (_didIteratorError21) {
            throw _iteratorError21;
          }
        }
      }

      this.notifySyncObserversOfModels(items, source || SFModelManager.MappingSourceLocalDirtied, sourceKey);
    }
  }, {
    key: "createItem",
    value: function createItem(json_obj) {
      var itemClass = SFModelManager.ContentTypeClassMapping && SFModelManager.ContentTypeClassMapping[json_obj.content_type];
      if (!itemClass) {
        itemClass = SFItem;
      }

      var item = new itemClass(json_obj);
      return item;
    }

    /*
      Be sure itemResponse is a generic Javascript object, and not an Item.
      An Item needs to collapse its properties into its content object before it can be duplicated.
      Note: the reason we need this function is specificallty for the call to resolveReferencesForItem.
      This method creates but does not add the item to the global inventory. It's used by syncManager
      to check if this prospective duplicate item is identical to another item, including the references.
     */

  }, {
    key: "createDuplicateItemFromResponseItem",
    value: function () {
      var _ref46 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(itemResponse) {
        var itemResponseCopy, duplicate;
        return regeneratorRuntime.wrap(function _callee41$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                if (!(typeof itemResponse.setDirty === 'function')) {
                  _context42.next = 3;
                  break;
                }

                // You should never pass in objects here, as we will modify the itemResponse's uuid below (update: we now make a copy of input value).
                console.error("Attempting to create conflicted copy of non-response item.");
                return _context42.abrupt("return", null);

              case 3:
                // Make a copy so we don't modify input value.
                itemResponseCopy = JSON.parse(JSON.stringify(itemResponse));
                _context42.next = 6;
                return SFJS.crypto.generateUUID();

              case 6:
                itemResponseCopy.uuid = _context42.sent;
                duplicate = this.createItem(itemResponseCopy);
                return _context42.abrupt("return", duplicate);

              case 9:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee41, this);
      }));

      function createDuplicateItemFromResponseItem(_x86) {
        return _ref46.apply(this, arguments);
      }

      return createDuplicateItemFromResponseItem;
    }()
  }, {
    key: "duplicateItemAndAddAsConflict",
    value: function duplicateItemAndAddAsConflict(duplicateOf) {
      return this.duplicateItemWithCustomContentAndAddAsConflict({ content: duplicateOf.content, duplicateOf: duplicateOf });
    }
  }, {
    key: "duplicateItemWithCustomContentAndAddAsConflict",
    value: function duplicateItemWithCustomContentAndAddAsConflict(_ref47) {
      var content = _ref47.content,
          duplicateOf = _ref47.duplicateOf;

      var copy = this.duplicateItemWithCustomContent({ content: content, duplicateOf: duplicateOf });
      this.addDuplicatedItemAsConflict({ duplicate: copy, duplicateOf: duplicateOf });
      return copy;
    }
  }, {
    key: "addDuplicatedItemAsConflict",
    value: function addDuplicatedItemAsConflict(_ref48) {
      var duplicate = _ref48.duplicate,
          duplicateOf = _ref48.duplicateOf;

      this.addDuplicatedItem(duplicate, duplicateOf);
      duplicate.content.conflict_of = duplicateOf.uuid;
    }
  }, {
    key: "duplicateItemWithCustomContent",
    value: function duplicateItemWithCustomContent(_ref49) {
      var content = _ref49.content,
          duplicateOf = _ref49.duplicateOf;

      var copy = new duplicateOf.constructor({ content: content });
      copy.created_at = duplicateOf.created_at;
      if (!copy.content_type) {
        copy.content_type = duplicateOf.content_type;
      }
      return copy;
    }
  }, {
    key: "duplicateItemAndAdd",
    value: function duplicateItemAndAdd(item) {
      var copy = this.duplicateItemWithoutAdding(item);
      this.addDuplicatedItem(copy, item);
      return copy;
    }
  }, {
    key: "duplicateItemWithoutAdding",
    value: function duplicateItemWithoutAdding(item) {
      var copy = new item.constructor({ content: item.content });
      copy.created_at = item.created_at;
      if (!copy.content_type) {
        copy.content_type = item.content_type;
      }
      return copy;
    }
  }, {
    key: "addDuplicatedItem",
    value: function addDuplicatedItem(duplicate, original) {
      this.addItem(duplicate);
      // the duplicate should inherit the original's relationships
      var _iteratorNormalCompletion22 = true;
      var _didIteratorError22 = false;
      var _iteratorError22 = undefined;

      try {
        for (var _iterator22 = original.referencingObjects[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var referencingObject = _step22.value;

          referencingObject.addItemAsRelationship(duplicate);
          this.setItemDirty(referencingObject, true);
        }
      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22.return) {
            _iterator22.return();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }

      this.resolveReferencesForItem(duplicate);
      this.setItemDirty(duplicate, true);
    }
  }, {
    key: "addItem",
    value: function addItem(item) {
      var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this.addItems([item], globalOnly);
    }
  }, {
    key: "addItems",
    value: function addItems(items) {
      var _this11 = this;

      var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      items.forEach(function (item) {
        if (!_this11.itemsHash[item.uuid]) {
          _this11.itemsHash[item.uuid] = item;
          _this11.items.push(item);
        }
      });
    }

    /* Notifies observers when an item has been synced or mapped from a remote response */

  }, {
    key: "addItemSyncObserver",
    value: function addItemSyncObserver(id, types, callback) {
      this.addItemSyncObserverWithPriority({ id: id, types: types, callback: callback, priority: 1 });
    }
  }, {
    key: "addItemSyncObserverWithPriority",
    value: function addItemSyncObserverWithPriority(_ref50) {
      var id = _ref50.id,
          priority = _ref50.priority,
          types = _ref50.types,
          callback = _ref50.callback;

      if (!Array.isArray(types)) {
        types = [types];
      }
      this.itemSyncObservers.push({ id: id, types: types, priority: priority, callback: callback });
    }
  }, {
    key: "removeItemSyncObserver",
    value: function removeItemSyncObserver(id) {
      _.remove(this.itemSyncObservers, _.find(this.itemSyncObservers, { id: id }));
    }
  }, {
    key: "getDirtyItems",
    value: function getDirtyItems() {
      return this.items.filter(function (item) {
        // An item that has an error decrypting can be synced only if it is being deleted.
        // Otherwise, we don't want to send corrupt content up to the server.
        return item.dirty == true && !item.dummy && (!item.errorDecrypting || item.deleted);
      });
    }
  }, {
    key: "clearDirtyItems",
    value: function clearDirtyItems(items) {
      var _iteratorNormalCompletion23 = true;
      var _didIteratorError23 = false;
      var _iteratorError23 = undefined;

      try {
        for (var _iterator23 = items[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
          var item = _step23.value;

          item.setDirty(false);
        }
      } catch (err) {
        _didIteratorError23 = true;
        _iteratorError23 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion23 && _iterator23.return) {
            _iterator23.return();
          }
        } finally {
          if (_didIteratorError23) {
            throw _iteratorError23;
          }
        }
      }
    }
  }, {
    key: "removeAndDirtyAllRelationshipsForItem",
    value: function removeAndDirtyAllRelationshipsForItem(item) {
      // Handle direct relationships
      // An item with errorDecrypting will not have valid content field
      if (!item.errorDecrypting) {
        var _iteratorNormalCompletion24 = true;
        var _didIteratorError24 = false;
        var _iteratorError24 = undefined;

        try {
          for (var _iterator24 = item.content.references[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
            var reference = _step24.value;

            var relationship = this.findItem(reference.uuid);
            if (relationship) {
              item.removeItemAsRelationship(relationship);
              if (relationship.hasRelationshipWithItem(item)) {
                relationship.removeItemAsRelationship(item);
                this.setItemDirty(relationship, true);
              }
            }
          }
        } catch (err) {
          _didIteratorError24 = true;
          _iteratorError24 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion24 && _iterator24.return) {
              _iterator24.return();
            }
          } finally {
            if (_didIteratorError24) {
              throw _iteratorError24;
            }
          }
        }
      }

      // Handle indirect relationships
      var _iteratorNormalCompletion25 = true;
      var _didIteratorError25 = false;
      var _iteratorError25 = undefined;

      try {
        for (var _iterator25 = item.referencingObjects[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
          var object = _step25.value;

          object.removeItemAsRelationship(item);
          this.setItemDirty(object, true);
        }
      } catch (err) {
        _didIteratorError25 = true;
        _iteratorError25 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion25 && _iterator25.return) {
            _iterator25.return();
          }
        } finally {
          if (_didIteratorError25) {
            throw _iteratorError25;
          }
        }
      }

      item.referencingObjects = [];
    }

    /* Used when changing encryption key */

  }, {
    key: "setAllItemsDirty",
    value: function setAllItemsDirty() {
      var relevantItems = this.allItems;
      this.setItemsDirty(relevantItems, true);
    }
  }, {
    key: "setItemToBeDeleted",
    value: function setItemToBeDeleted(item) {
      item.deleted = true;

      if (!item.dummy) {
        this.setItemDirty(item, true);
      }

      this.removeAndDirtyAllRelationshipsForItem(item);
    }
  }, {
    key: "removeItemLocally",
    value: function () {
      var _ref51 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(item) {
        return regeneratorRuntime.wrap(function _callee42$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                _.remove(this.items, { uuid: item.uuid });

                delete this.itemsHash[item.uuid];

                item.isBeingRemovedLocally();

              case 3:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee42, this);
      }));

      function removeItemLocally(_x89) {
        return _ref51.apply(this, arguments);
      }

      return removeItemLocally;
    }()

    /* Searching */

  }, {
    key: "allItemsMatchingTypes",
    value: function allItemsMatchingTypes(contentTypes) {
      return this.allItems.filter(function (item) {
        return (_.includes(contentTypes, item.content_type) || _.includes(contentTypes, "*")) && !item.dummy;
      });
    }
  }, {
    key: "invalidItems",
    value: function invalidItems() {
      return this.allItems.filter(function (item) {
        return item.errorDecrypting;
      });
    }
  }, {
    key: "validItemsForContentType",
    value: function validItemsForContentType(contentType) {
      return this.allItems.filter(function (item) {
        return item.content_type == contentType && !item.errorDecrypting;
      });
    }
  }, {
    key: "findItem",
    value: function findItem(itemId) {
      return this.itemsHash[itemId];
    }
  }, {
    key: "findItems",
    value: function findItems(ids) {
      var includeBlanks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var results = [];
      var _iteratorNormalCompletion26 = true;
      var _didIteratorError26 = false;
      var _iteratorError26 = undefined;

      try {
        for (var _iterator26 = ids[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
          var id = _step26.value;

          var item = this.itemsHash[id];
          if (item || includeBlanks) {
            results.push(item);
          }
        }
      } catch (err) {
        _didIteratorError26 = true;
        _iteratorError26 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion26 && _iterator26.return) {
            _iterator26.return();
          }
        } finally {
          if (_didIteratorError26) {
            throw _iteratorError26;
          }
        }
      }

      return results;
    }
  }, {
    key: "itemsMatchingPredicate",
    value: function itemsMatchingPredicate(predicate) {
      return this.itemsMatchingPredicates([predicate]);
    }
  }, {
    key: "itemsMatchingPredicates",
    value: function itemsMatchingPredicates(predicates) {
      return this.filterItemsWithPredicates(this.allItems, predicates);
    }
  }, {
    key: "filterItemsWithPredicates",
    value: function filterItemsWithPredicates(items, predicates) {
      var results = items.filter(function (item) {
        var _iteratorNormalCompletion27 = true;
        var _didIteratorError27 = false;
        var _iteratorError27 = undefined;

        try {
          for (var _iterator27 = predicates[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
            var predicate = _step27.value;

            if (!item.satisfiesPredicate(predicate)) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError27 = true;
          _iteratorError27 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion27 && _iterator27.return) {
              _iterator27.return();
            }
          } finally {
            if (_didIteratorError27) {
              throw _iteratorError27;
            }
          }
        }

        return true;
      });

      return results;
    }

    /*
    Archives
    */

  }, {
    key: "importItems",
    value: function () {
      var _ref52 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(externalItems) {
        var itemsToBeMapped, localValues, _iteratorNormalCompletion28, _didIteratorError28, _iteratorError28, _iterator28, _step28, itemData, localItem, frozenValue, _iteratorNormalCompletion29, _didIteratorError29, _iteratorError29, _iterator29, _step29, _itemData, _localValues$_itemDat, itemRef, duplicate, items, _iteratorNormalCompletion30, _didIteratorError30, _iteratorError30, _iterator30, _step30, item;

        return regeneratorRuntime.wrap(function _callee43$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                itemsToBeMapped = [];
                // Get local values before doing any processing. This way, if a note change below modifies a tag,
                // and the tag is going to be iterated on in the same loop, then we don't want this change to be compared
                // to the local value.

                localValues = {};
                _iteratorNormalCompletion28 = true;
                _didIteratorError28 = false;
                _iteratorError28 = undefined;
                _context44.prev = 5;
                _iterator28 = externalItems[Symbol.iterator]();

              case 7:
                if (_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done) {
                  _context44.next = 18;
                  break;
                }

                itemData = _step28.value;
                localItem = this.findItem(itemData.uuid);

                if (localItem) {
                  _context44.next = 13;
                  break;
                }

                localValues[itemData.uuid] = {};
                return _context44.abrupt("continue", 15);

              case 13:
                frozenValue = this.duplicateItemWithoutAdding(localItem);

                localValues[itemData.uuid] = { frozenValue: frozenValue, itemRef: localItem };

              case 15:
                _iteratorNormalCompletion28 = true;
                _context44.next = 7;
                break;

              case 18:
                _context44.next = 24;
                break;

              case 20:
                _context44.prev = 20;
                _context44.t0 = _context44["catch"](5);
                _didIteratorError28 = true;
                _iteratorError28 = _context44.t0;

              case 24:
                _context44.prev = 24;
                _context44.prev = 25;

                if (!_iteratorNormalCompletion28 && _iterator28.return) {
                  _iterator28.return();
                }

              case 27:
                _context44.prev = 27;

                if (!_didIteratorError28) {
                  _context44.next = 30;
                  break;
                }

                throw _iteratorError28;

              case 30:
                return _context44.finish(27);

              case 31:
                return _context44.finish(24);

              case 32:
                _iteratorNormalCompletion29 = true;
                _didIteratorError29 = false;
                _iteratorError29 = undefined;
                _context44.prev = 35;
                _iterator29 = externalItems[Symbol.iterator]();

              case 37:
                if (_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done) {
                  _context44.next = 52;
                  break;
                }

                _itemData = _step29.value;
                _localValues$_itemDat = localValues[_itemData.uuid], frozenValue = _localValues$_itemDat.frozenValue, itemRef = _localValues$_itemDat.itemRef;

                if (!(frozenValue && !itemRef.errorDecrypting)) {
                  _context44.next = 47;
                  break;
                }

                _context44.next = 43;
                return this.createDuplicateItemFromResponseItem(_itemData);

              case 43:
                duplicate = _context44.sent;

                if (!_itemData.deleted && !frozenValue.isItemContentEqualWith(duplicate)) {
                  // Data differs
                  this.addDuplicatedItemAsConflict({ duplicate: duplicate, duplicateOf: itemRef });
                  itemsToBeMapped.push(duplicate);
                }
                _context44.next = 49;
                break;

              case 47:
                // it doesn't exist, push it into items to be mapped
                itemsToBeMapped.push(_itemData);
                if (itemRef && itemRef.errorDecrypting) {
                  itemRef.errorDecrypting = false;
                }

              case 49:
                _iteratorNormalCompletion29 = true;
                _context44.next = 37;
                break;

              case 52:
                _context44.next = 58;
                break;

              case 54:
                _context44.prev = 54;
                _context44.t1 = _context44["catch"](35);
                _didIteratorError29 = true;
                _iteratorError29 = _context44.t1;

              case 58:
                _context44.prev = 58;
                _context44.prev = 59;

                if (!_iteratorNormalCompletion29 && _iterator29.return) {
                  _iterator29.return();
                }

              case 61:
                _context44.prev = 61;

                if (!_didIteratorError29) {
                  _context44.next = 64;
                  break;
                }

                throw _iteratorError29;

              case 64:
                return _context44.finish(61);

              case 65:
                return _context44.finish(58);

              case 66:
                _context44.next = 68;
                return this.mapResponseItemsToLocalModels(itemsToBeMapped, SFModelManager.MappingSourceFileImport);

              case 68:
                items = _context44.sent;
                _iteratorNormalCompletion30 = true;
                _didIteratorError30 = false;
                _iteratorError30 = undefined;
                _context44.prev = 72;

                for (_iterator30 = items[Symbol.iterator](); !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                  item = _step30.value;

                  this.setItemDirty(item, true, true);
                  item.deleted = false;
                }

                _context44.next = 80;
                break;

              case 76:
                _context44.prev = 76;
                _context44.t2 = _context44["catch"](72);
                _didIteratorError30 = true;
                _iteratorError30 = _context44.t2;

              case 80:
                _context44.prev = 80;
                _context44.prev = 81;

                if (!_iteratorNormalCompletion30 && _iterator30.return) {
                  _iterator30.return();
                }

              case 83:
                _context44.prev = 83;

                if (!_didIteratorError30) {
                  _context44.next = 86;
                  break;
                }

                throw _iteratorError30;

              case 86:
                return _context44.finish(83);

              case 87:
                return _context44.finish(80);

              case 88:
                return _context44.abrupt("return", items);

              case 89:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee43, this, [[5, 20, 24, 32], [25,, 27, 31], [35, 54, 58, 66], [59,, 61, 65], [72, 76, 80, 88], [81,, 83, 87]]);
      }));

      function importItems(_x91) {
        return _ref52.apply(this, arguments);
      }

      return importItems;
    }()
  }, {
    key: "getAllItemsJSONData",
    value: function () {
      var _ref53 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(keys, authParams, returnNullIfEmpty) {
        return regeneratorRuntime.wrap(function _callee44$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                return _context45.abrupt("return", this.getJSONDataForItems(this.allItems, keys, authParams, returnNullIfEmpty));

              case 1:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee44, this);
      }));

      function getAllItemsJSONData(_x92, _x93, _x94) {
        return _ref53.apply(this, arguments);
      }

      return getAllItemsJSONData;
    }()
  }, {
    key: "getJSONDataForItems",
    value: function () {
      var _ref54 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(items, keys, authParams, returnNullIfEmpty) {
        return regeneratorRuntime.wrap(function _callee45$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                return _context46.abrupt("return", Promise.all(items.map(function (item) {
                  var itemParams = new SFItemParams(item, keys, authParams);
                  return itemParams.paramsForExportFile();
                })).then(function (items) {
                  if (returnNullIfEmpty && items.length == 0) {
                    return null;
                  }

                  var data = { items: items };

                  if (keys) {
                    // auth params are only needed when encrypted with a standard file key
                    data["auth_params"] = authParams;
                  }

                  return JSON.stringify(data, null, 2 /* pretty print */);
                }));

              case 1:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee45, this);
      }));

      function getJSONDataForItems(_x95, _x96, _x97, _x98) {
        return _ref54.apply(this, arguments);
      }

      return getJSONDataForItems;
    }()
  }, {
    key: "computeDataIntegrityHash",
    value: function () {
      var _ref55 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46() {
        var items, dates, string, hash;
        return regeneratorRuntime.wrap(function _callee46$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                _context47.prev = 0;
                items = this.allNondummyItems.sort(function (a, b) {
                  return b.updated_at - a.updated_at;
                });
                dates = items.map(function (item) {
                  return item.updatedAtTimestamp();
                });
                string = dates.join(",");
                _context47.next = 6;
                return SFJS.crypto.sha256(string);

              case 6:
                hash = _context47.sent;
                return _context47.abrupt("return", hash);

              case 10:
                _context47.prev = 10;
                _context47.t0 = _context47["catch"](0);

                console.error("Error computing data integrity hash", _context47.t0);
                return _context47.abrupt("return", null);

              case 14:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee46, this, [[0, 10]]);
      }));

      function computeDataIntegrityHash() {
        return _ref55.apply(this, arguments);
      }

      return computeDataIntegrityHash;
    }()
  }, {
    key: "allItems",
    get: function get() {
      return this.items.slice();
    }
  }, {
    key: "allNondummyItems",
    get: function get() {
      return this.items.filter(function (item) {
        return !item.dummy;
      });
    }
  }]);

  return SFModelManager;
}();

;
var SFPrivilegesManager = exports.SFPrivilegesManager = function () {
  function SFPrivilegesManager(modelManager, syncManager, singletonManager) {
    _classCallCheck(this, SFPrivilegesManager);

    this.modelManager = modelManager;
    this.syncManager = syncManager;
    this.singletonManager = singletonManager;

    this.loadPrivileges();

    SFPrivilegesManager.CredentialAccountPassword = "CredentialAccountPassword";
    SFPrivilegesManager.CredentialLocalPasscode = "CredentialLocalPasscode";

    SFPrivilegesManager.ActionManageExtensions = "ActionManageExtensions";
    SFPrivilegesManager.ActionManageBackups = "ActionManageBackups";
    SFPrivilegesManager.ActionViewProtectedNotes = "ActionViewProtectedNotes";
    SFPrivilegesManager.ActionManagePrivileges = "ActionManagePrivileges";
    SFPrivilegesManager.ActionManagePasscode = "ActionManagePasscode";
    SFPrivilegesManager.ActionDeleteNote = "ActionDeleteNote";

    SFPrivilegesManager.SessionExpiresAtKey = "SessionExpiresAtKey";
    SFPrivilegesManager.SessionLengthKey = "SessionLengthKey";

    SFPrivilegesManager.SessionLengthNone = 0;
    SFPrivilegesManager.SessionLengthFiveMinutes = 300;
    SFPrivilegesManager.SessionLengthOneHour = 3600;
    SFPrivilegesManager.SessionLengthOneWeek = 604800;

    this.availableActions = [SFPrivilegesManager.ActionViewProtectedNotes, SFPrivilegesManager.ActionDeleteNote, SFPrivilegesManager.ActionManagePasscode, SFPrivilegesManager.ActionManageBackups, SFPrivilegesManager.ActionManageExtensions, SFPrivilegesManager.ActionManagePrivileges];

    this.availableCredentials = [SFPrivilegesManager.CredentialAccountPassword, SFPrivilegesManager.CredentialLocalPasscode];

    this.sessionLengths = [SFPrivilegesManager.SessionLengthNone, SFPrivilegesManager.SessionLengthFiveMinutes, SFPrivilegesManager.SessionLengthOneHour, SFPrivilegesManager.SessionLengthOneWeek, SFPrivilegesManager.SessionLengthIndefinite];
  }

  /*
  async delegate.isOffline()
  async delegate.hasLocalPasscode()
  async delegate.saveToStorage(key, value)
  async delegate.getFromStorage(key)
  async delegate.verifyAccountPassword
  async delegate.verifyLocalPasscode
  */


  _createClass(SFPrivilegesManager, [{
    key: "setDelegate",
    value: function setDelegate(delegate) {
      this.delegate = delegate;
    }
  }, {
    key: "getAvailableActions",
    value: function getAvailableActions() {
      return this.availableActions;
    }
  }, {
    key: "getAvailableCredentials",
    value: function getAvailableCredentials() {
      return this.availableCredentials;
    }
  }, {
    key: "netCredentialsForAction",
    value: function () {
      var _ref56 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(action) {
        var credentials, netCredentials, _iteratorNormalCompletion31, _didIteratorError31, _iteratorError31, _iterator31, _step31, cred, isOffline, hasLocalPasscode;

        return regeneratorRuntime.wrap(function _callee47$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return this.getPrivileges();

              case 2:
                _context48.t0 = action;
                credentials = _context48.sent.getCredentialsForAction(_context48.t0);
                netCredentials = [];
                _iteratorNormalCompletion31 = true;
                _didIteratorError31 = false;
                _iteratorError31 = undefined;
                _context48.prev = 8;
                _iterator31 = credentials[Symbol.iterator]();

              case 10:
                if (_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done) {
                  _context48.next = 27;
                  break;
                }

                cred = _step31.value;

                if (!(cred == SFPrivilegesManager.CredentialAccountPassword)) {
                  _context48.next = 19;
                  break;
                }

                _context48.next = 15;
                return this.delegate.isOffline();

              case 15:
                isOffline = _context48.sent;

                if (!isOffline) {
                  netCredentials.push(cred);
                }
                _context48.next = 24;
                break;

              case 19:
                if (!(cred == SFPrivilegesManager.CredentialLocalPasscode)) {
                  _context48.next = 24;
                  break;
                }

                _context48.next = 22;
                return this.delegate.hasLocalPasscode();

              case 22:
                hasLocalPasscode = _context48.sent;

                if (hasLocalPasscode) {
                  netCredentials.push(cred);
                }

              case 24:
                _iteratorNormalCompletion31 = true;
                _context48.next = 10;
                break;

              case 27:
                _context48.next = 33;
                break;

              case 29:
                _context48.prev = 29;
                _context48.t1 = _context48["catch"](8);
                _didIteratorError31 = true;
                _iteratorError31 = _context48.t1;

              case 33:
                _context48.prev = 33;
                _context48.prev = 34;

                if (!_iteratorNormalCompletion31 && _iterator31.return) {
                  _iterator31.return();
                }

              case 36:
                _context48.prev = 36;

                if (!_didIteratorError31) {
                  _context48.next = 39;
                  break;
                }

                throw _iteratorError31;

              case 39:
                return _context48.finish(36);

              case 40:
                return _context48.finish(33);

              case 41:
                return _context48.abrupt("return", netCredentials);

              case 42:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee47, this, [[8, 29, 33, 41], [34,, 36, 40]]);
      }));

      function netCredentialsForAction(_x99) {
        return _ref56.apply(this, arguments);
      }

      return netCredentialsForAction;
    }()
  }, {
    key: "loadPrivileges",
    value: function () {
      var _ref57 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49() {
        var _this12 = this;

        return regeneratorRuntime.wrap(function _callee49$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                if (!this.loadPromise) {
                  _context50.next = 2;
                  break;
                }

                return _context50.abrupt("return", this.loadPromise);

              case 2:

                this.loadPromise = new Promise(function (resolve, reject) {
                  var privsContentType = SFPrivileges.contentType();
                  var contentTypePredicate = new SFPredicate("content_type", "=", privsContentType);
                  _this12.singletonManager.registerSingleton([contentTypePredicate], function (resolvedSingleton) {
                    _this12.privileges = resolvedSingleton;
                    resolve(resolvedSingleton);
                  }, function () {
                    var _ref58 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(valueCallback) {
                      var privs;
                      return regeneratorRuntime.wrap(function _callee48$(_context49) {
                        while (1) {
                          switch (_context49.prev = _context49.next) {
                            case 0:
                              // Safe to create. Create and return object.
                              privs = new SFPrivileges({ content_type: privsContentType });

                              if (SFJS.crypto.generateUUIDSync) {
                                _context49.next = 4;
                                break;
                              }

                              _context49.next = 4;
                              return privs.initUUID();

                            case 4:
                              _this12.modelManager.addItem(privs);
                              _this12.modelManager.setItemDirty(privs, true);
                              _this12.syncManager.sync();
                              valueCallback(privs);
                              resolve(privs);

                            case 9:
                            case "end":
                              return _context49.stop();
                          }
                        }
                      }, _callee48, _this12);
                    }));

                    return function (_x100) {
                      return _ref58.apply(this, arguments);
                    };
                  }());
                });

                return _context50.abrupt("return", this.loadPromise);

              case 4:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee49, this);
      }));

      function loadPrivileges() {
        return _ref57.apply(this, arguments);
      }

      return loadPrivileges;
    }()
  }, {
    key: "getPrivileges",
    value: function () {
      var _ref59 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50() {
        return regeneratorRuntime.wrap(function _callee50$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                if (!this.privileges) {
                  _context51.next = 4;
                  break;
                }

                return _context51.abrupt("return", this.privileges);

              case 4:
                return _context51.abrupt("return", this.loadPrivileges());

              case 5:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee50, this);
      }));

      function getPrivileges() {
        return _ref59.apply(this, arguments);
      }

      return getPrivileges;
    }()
  }, {
    key: "displayInfoForCredential",
    value: function displayInfoForCredential(credential) {
      var metadata = {};

      metadata[SFPrivilegesManager.CredentialAccountPassword] = {
        label: "Account Password",
        prompt: "Please enter your account password."
      };

      metadata[SFPrivilegesManager.CredentialLocalPasscode] = {
        label: "Local Passcode",
        prompt: "Please enter your local passcode."
      };

      return metadata[credential];
    }
  }, {
    key: "displayInfoForAction",
    value: function displayInfoForAction(action) {
      var metadata = {};

      metadata[SFPrivilegesManager.ActionManageExtensions] = {
        label: "Manage Extensions"
      };

      metadata[SFPrivilegesManager.ActionManageBackups] = {
        label: "Download/Import Backups"
      };

      metadata[SFPrivilegesManager.ActionViewProtectedNotes] = {
        label: "View Protected Notes"
      };

      metadata[SFPrivilegesManager.ActionManagePrivileges] = {
        label: "Manage Privileges"
      };

      metadata[SFPrivilegesManager.ActionManagePasscode] = {
        label: "Manage Passcode"
      };

      metadata[SFPrivilegesManager.ActionDeleteNote] = {
        label: "Delete Notes"
      };

      return metadata[action];
    }
  }, {
    key: "getSessionLengthOptions",
    value: function getSessionLengthOptions() {
      return [{
        value: SFPrivilegesManager.SessionLengthNone,
        label: "Don't Remember"
      }, {
        value: SFPrivilegesManager.SessionLengthFiveMinutes,
        label: "5 Minutes"
      }, {
        value: SFPrivilegesManager.SessionLengthOneHour,
        label: "1 Hour"
      }, {
        value: SFPrivilegesManager.SessionLengthOneWeek,
        label: "1 Week"
      }];
    }
  }, {
    key: "setSessionLength",
    value: function () {
      var _ref60 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(length) {
        var addToNow, expiresAt;
        return regeneratorRuntime.wrap(function _callee51$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                addToNow = function addToNow(seconds) {
                  var date = new Date();
                  date.setSeconds(date.getSeconds() + seconds);
                  return date;
                };

                expiresAt = addToNow(length);
                return _context52.abrupt("return", Promise.all([this.delegate.saveToStorage(SFPrivilegesManager.SessionExpiresAtKey, JSON.stringify(expiresAt)), this.delegate.saveToStorage(SFPrivilegesManager.SessionLengthKey, JSON.stringify(length))]));

              case 3:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee51, this);
      }));

      function setSessionLength(_x101) {
        return _ref60.apply(this, arguments);
      }

      return setSessionLength;
    }()
  }, {
    key: "clearSession",
    value: function () {
      var _ref61 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52() {
        return regeneratorRuntime.wrap(function _callee52$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                return _context53.abrupt("return", this.setSessionLength(SFPrivilegesManager.SessionLengthNone));

              case 1:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee52, this);
      }));

      function clearSession() {
        return _ref61.apply(this, arguments);
      }

      return clearSession;
    }()
  }, {
    key: "getSelectedSessionLength",
    value: function () {
      var _ref62 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53() {
        var length;
        return regeneratorRuntime.wrap(function _callee53$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                _context54.next = 2;
                return this.delegate.getFromStorage(SFPrivilegesManager.SessionLengthKey);

              case 2:
                length = _context54.sent;

                if (!length) {
                  _context54.next = 7;
                  break;
                }

                return _context54.abrupt("return", JSON.parse(length));

              case 7:
                return _context54.abrupt("return", SFPrivilegesManager.SessionLengthNone);

              case 8:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee53, this);
      }));

      function getSelectedSessionLength() {
        return _ref62.apply(this, arguments);
      }

      return getSelectedSessionLength;
    }()
  }, {
    key: "getSessionExpirey",
    value: function () {
      var _ref63 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54() {
        var expiresAt;
        return regeneratorRuntime.wrap(function _callee54$(_context55) {
          while (1) {
            switch (_context55.prev = _context55.next) {
              case 0:
                _context55.next = 2;
                return this.delegate.getFromStorage(SFPrivilegesManager.SessionExpiresAtKey);

              case 2:
                expiresAt = _context55.sent;

                if (!expiresAt) {
                  _context55.next = 7;
                  break;
                }

                return _context55.abrupt("return", new Date(JSON.parse(expiresAt)));

              case 7:
                return _context55.abrupt("return", new Date());

              case 8:
              case "end":
                return _context55.stop();
            }
          }
        }, _callee54, this);
      }));

      function getSessionExpirey() {
        return _ref63.apply(this, arguments);
      }

      return getSessionExpirey;
    }()
  }, {
    key: "actionHasPrivilegesConfigured",
    value: function () {
      var _ref64 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee55(action) {
        return regeneratorRuntime.wrap(function _callee55$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                _context56.next = 2;
                return this.netCredentialsForAction(action);

              case 2:
                _context56.t0 = _context56.sent.length;
                return _context56.abrupt("return", _context56.t0 > 0);

              case 4:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee55, this);
      }));

      function actionHasPrivilegesConfigured(_x102) {
        return _ref64.apply(this, arguments);
      }

      return actionHasPrivilegesConfigured;
    }()
  }, {
    key: "actionRequiresPrivilege",
    value: function () {
      var _ref65 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee56(action) {
        var expiresAt, netCredentials;
        return regeneratorRuntime.wrap(function _callee56$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                _context57.next = 2;
                return this.getSessionExpirey();

              case 2:
                expiresAt = _context57.sent;

                if (!(expiresAt > new Date())) {
                  _context57.next = 5;
                  break;
                }

                return _context57.abrupt("return", false);

              case 5:
                _context57.next = 7;
                return this.netCredentialsForAction(action);

              case 7:
                netCredentials = _context57.sent;
                return _context57.abrupt("return", netCredentials.length > 0);

              case 9:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee56, this);
      }));

      function actionRequiresPrivilege(_x103) {
        return _ref65.apply(this, arguments);
      }

      return actionRequiresPrivilege;
    }()
  }, {
    key: "savePrivileges",
    value: function () {
      var _ref66 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee57() {
        var privs;
        return regeneratorRuntime.wrap(function _callee57$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                _context58.next = 2;
                return this.getPrivileges();

              case 2:
                privs = _context58.sent;

                this.modelManager.setItemDirty(privs, true);
                this.syncManager.sync();

              case 5:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee57, this);
      }));

      function savePrivileges() {
        return _ref66.apply(this, arguments);
      }

      return savePrivileges;
    }()
  }, {
    key: "authenticateAction",
    value: function () {
      var _ref67 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee58(action, credentialAuthMapping) {
        var requiredCredentials, successfulCredentials, failedCredentials, _iteratorNormalCompletion32, _didIteratorError32, _iteratorError32, _iterator32, _step32, requiredCredential, passesAuth;

        return regeneratorRuntime.wrap(function _callee58$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                _context59.next = 2;
                return this.netCredentialsForAction(action);

              case 2:
                requiredCredentials = _context59.sent;
                successfulCredentials = [], failedCredentials = [];
                _iteratorNormalCompletion32 = true;
                _didIteratorError32 = false;
                _iteratorError32 = undefined;
                _context59.prev = 7;
                _iterator32 = requiredCredentials[Symbol.iterator]();

              case 9:
                if (_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done) {
                  _context59.next = 18;
                  break;
                }

                requiredCredential = _step32.value;
                _context59.next = 13;
                return this._verifyAuthenticationParameters(requiredCredential, credentialAuthMapping[requiredCredential]);

              case 13:
                passesAuth = _context59.sent;

                if (passesAuth) {
                  successfulCredentials.push(requiredCredential);
                } else {
                  failedCredentials.push(requiredCredential);
                }

              case 15:
                _iteratorNormalCompletion32 = true;
                _context59.next = 9;
                break;

              case 18:
                _context59.next = 24;
                break;

              case 20:
                _context59.prev = 20;
                _context59.t0 = _context59["catch"](7);
                _didIteratorError32 = true;
                _iteratorError32 = _context59.t0;

              case 24:
                _context59.prev = 24;
                _context59.prev = 25;

                if (!_iteratorNormalCompletion32 && _iterator32.return) {
                  _iterator32.return();
                }

              case 27:
                _context59.prev = 27;

                if (!_didIteratorError32) {
                  _context59.next = 30;
                  break;
                }

                throw _iteratorError32;

              case 30:
                return _context59.finish(27);

              case 31:
                return _context59.finish(24);

              case 32:
                return _context59.abrupt("return", {
                  success: failedCredentials.length == 0,
                  successfulCredentials: successfulCredentials,
                  failedCredentials: failedCredentials
                });

              case 33:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee58, this, [[7, 20, 24, 32], [25,, 27, 31]]);
      }));

      function authenticateAction(_x104, _x105) {
        return _ref67.apply(this, arguments);
      }

      return authenticateAction;
    }()
  }, {
    key: "_verifyAuthenticationParameters",
    value: function () {
      var _ref68 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee61(credential, value) {
        var _this13 = this;

        var verifyAccountPassword, verifyLocalPasscode;
        return regeneratorRuntime.wrap(function _callee61$(_context62) {
          while (1) {
            switch (_context62.prev = _context62.next) {
              case 0:
                verifyAccountPassword = function () {
                  var _ref69 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee59(password) {
                    return regeneratorRuntime.wrap(function _callee59$(_context60) {
                      while (1) {
                        switch (_context60.prev = _context60.next) {
                          case 0:
                            return _context60.abrupt("return", _this13.delegate.verifyAccountPassword(password));

                          case 1:
                          case "end":
                            return _context60.stop();
                        }
                      }
                    }, _callee59, _this13);
                  }));

                  return function verifyAccountPassword(_x108) {
                    return _ref69.apply(this, arguments);
                  };
                }();

                verifyLocalPasscode = function () {
                  var _ref70 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee60(passcode) {
                    return regeneratorRuntime.wrap(function _callee60$(_context61) {
                      while (1) {
                        switch (_context61.prev = _context61.next) {
                          case 0:
                            return _context61.abrupt("return", _this13.delegate.verifyLocalPasscode(passcode));

                          case 1:
                          case "end":
                            return _context61.stop();
                        }
                      }
                    }, _callee60, _this13);
                  }));

                  return function verifyLocalPasscode(_x109) {
                    return _ref70.apply(this, arguments);
                  };
                }();

                if (!(credential == SFPrivilegesManager.CredentialAccountPassword)) {
                  _context62.next = 6;
                  break;
                }

                return _context62.abrupt("return", verifyAccountPassword(value));

              case 6:
                if (!(credential == SFPrivilegesManager.CredentialLocalPasscode)) {
                  _context62.next = 8;
                  break;
                }

                return _context62.abrupt("return", verifyLocalPasscode(value));

              case 8:
              case "end":
                return _context62.stop();
            }
          }
        }, _callee61, this);
      }));

      function _verifyAuthenticationParameters(_x106, _x107) {
        return _ref68.apply(this, arguments);
      }

      return _verifyAuthenticationParameters;
    }()
  }]);

  return SFPrivilegesManager;
}();

;var SessionHistoryPersistKey = "sessionHistory_persist";
var SessionHistoryRevisionsKey = "sessionHistory_revisions";
var SessionHistoryAutoOptimizeKey = "sessionHistory_autoOptimize";

var SFSessionHistoryManager = exports.SFSessionHistoryManager = function () {
  function SFSessionHistoryManager(modelManager, storageManager, keyRequestHandler, contentTypes, timeout) {
    var _this14 = this;

    _classCallCheck(this, SFSessionHistoryManager);

    this.modelManager = modelManager;
    this.storageManager = storageManager;
    this.$timeout = timeout || setTimeout.bind(window);

    // Required to persist the encrypted form of SFHistorySession
    this.keyRequestHandler = keyRequestHandler;

    this.loadFromDisk().then(function () {
      _this14.modelManager.addItemSyncObserver("session-history", contentTypes, function (allItems, validItems, deletedItems, source, sourceKey) {
        if (source === SFModelManager.MappingSourceLocalDirtied) {
          return;
        }
        var _iteratorNormalCompletion33 = true;
        var _didIteratorError33 = false;
        var _iteratorError33 = undefined;

        try {
          for (var _iterator33 = allItems[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
            var item = _step33.value;

            try {
              _this14.addHistoryEntryForItem(item);
            } catch (e) {
              console.log("Caught exception while trying to add item history entry", e);
            }
          }
        } catch (err) {
          _didIteratorError33 = true;
          _iteratorError33 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion33 && _iterator33.return) {
              _iterator33.return();
            }
          } finally {
            if (_didIteratorError33) {
              throw _iteratorError33;
            }
          }
        }
      });
    });
  }

  _createClass(SFSessionHistoryManager, [{
    key: "encryptionParams",
    value: function () {
      var _ref71 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee62() {
        return regeneratorRuntime.wrap(function _callee62$(_context63) {
          while (1) {
            switch (_context63.prev = _context63.next) {
              case 0:
                return _context63.abrupt("return", this.keyRequestHandler());

              case 1:
              case "end":
                return _context63.stop();
            }
          }
        }, _callee62, this);
      }));

      function encryptionParams() {
        return _ref71.apply(this, arguments);
      }

      return encryptionParams;
    }()
  }, {
    key: "addHistoryEntryForItem",
    value: function addHistoryEntryForItem(item) {
      var _this15 = this;

      var persistableItemParams = {
        uuid: item.uuid,
        content_type: item.content_type,
        updated_at: item.updated_at,
        content: item.getContentCopy()
      };

      var entry = this.historySession.addEntryForItem(persistableItemParams);

      if (this.autoOptimize) {
        this.historySession.optimizeHistoryForItem(item);
      }

      if (entry && this.diskEnabled) {
        // Debounce, clear existing timeout
        if (this.diskTimeout) {
          if (this.$timeout.hasOwnProperty("cancel")) {
            this.$timeout.cancel(this.diskTimeout);
          } else {
            clearTimeout(this.diskTimeout);
          }
        };
        this.diskTimeout = this.$timeout(function () {
          _this15.saveToDisk();
        }, 2000);
      }
    }
  }, {
    key: "historyForItem",
    value: function historyForItem(item) {
      return this.historySession.historyForItem(item);
    }
  }, {
    key: "clearHistoryForItem",
    value: function () {
      var _ref72 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee63(item) {
        return regeneratorRuntime.wrap(function _callee63$(_context64) {
          while (1) {
            switch (_context64.prev = _context64.next) {
              case 0:
                this.historySession.clearItemHistory(item);
                return _context64.abrupt("return", this.saveToDisk());

              case 2:
              case "end":
                return _context64.stop();
            }
          }
        }, _callee63, this);
      }));

      function clearHistoryForItem(_x110) {
        return _ref72.apply(this, arguments);
      }

      return clearHistoryForItem;
    }()
  }, {
    key: "clearAllHistory",
    value: function () {
      var _ref73 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee64() {
        return regeneratorRuntime.wrap(function _callee64$(_context65) {
          while (1) {
            switch (_context65.prev = _context65.next) {
              case 0:
                this.historySession.clearAllHistory();
                return _context65.abrupt("return", this.storageManager.removeItem(SessionHistoryRevisionsKey));

              case 2:
              case "end":
                return _context65.stop();
            }
          }
        }, _callee64, this);
      }));

      function clearAllHistory() {
        return _ref73.apply(this, arguments);
      }

      return clearAllHistory;
    }()
  }, {
    key: "toggleDiskSaving",
    value: function () {
      var _ref74 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee65() {
        return regeneratorRuntime.wrap(function _callee65$(_context66) {
          while (1) {
            switch (_context66.prev = _context66.next) {
              case 0:
                this.diskEnabled = !this.diskEnabled;

                if (!this.diskEnabled) {
                  _context66.next = 6;
                  break;
                }

                this.storageManager.setItem(SessionHistoryPersistKey, JSON.stringify(true));
                this.saveToDisk();
                _context66.next = 8;
                break;

              case 6:
                this.storageManager.setItem(SessionHistoryPersistKey, JSON.stringify(false));
                return _context66.abrupt("return", this.storageManager.removeItem(SessionHistoryRevisionsKey));

              case 8:
              case "end":
                return _context66.stop();
            }
          }
        }, _callee65, this);
      }));

      function toggleDiskSaving() {
        return _ref74.apply(this, arguments);
      }

      return toggleDiskSaving;
    }()
  }, {
    key: "saveToDisk",
    value: function () {
      var _ref75 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee66() {
        var _this16 = this;

        var encryptionParams, itemParams;
        return regeneratorRuntime.wrap(function _callee66$(_context67) {
          while (1) {
            switch (_context67.prev = _context67.next) {
              case 0:
                if (this.diskEnabled) {
                  _context67.next = 2;
                  break;
                }

                return _context67.abrupt("return");

              case 2:
                _context67.next = 4;
                return this.encryptionParams();

              case 4:
                encryptionParams = _context67.sent;
                itemParams = new SFItemParams(this.historySession, encryptionParams.keys, encryptionParams.auth_params);

                itemParams.paramsForSync().then(function (syncParams) {
                  // console.log("Saving to disk", syncParams);
                  _this16.storageManager.setItem(SessionHistoryRevisionsKey, JSON.stringify(syncParams));
                });

              case 7:
              case "end":
                return _context67.stop();
            }
          }
        }, _callee66, this);
      }));

      function saveToDisk() {
        return _ref75.apply(this, arguments);
      }

      return saveToDisk;
    }()
  }, {
    key: "loadFromDisk",
    value: function () {
      var _ref76 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee67() {
        var diskValue, historyValue, encryptionParams, historySession, autoOptimizeValue;
        return regeneratorRuntime.wrap(function _callee67$(_context68) {
          while (1) {
            switch (_context68.prev = _context68.next) {
              case 0:
                _context68.next = 2;
                return this.storageManager.getItem(SessionHistoryPersistKey);

              case 2:
                diskValue = _context68.sent;

                if (diskValue) {
                  this.diskEnabled = JSON.parse(diskValue);
                }

                _context68.next = 6;
                return this.storageManager.getItem(SessionHistoryRevisionsKey);

              case 6:
                historyValue = _context68.sent;

                if (!historyValue) {
                  _context68.next = 18;
                  break;
                }

                historyValue = JSON.parse(historyValue);
                _context68.next = 11;
                return this.encryptionParams();

              case 11:
                encryptionParams = _context68.sent;
                _context68.next = 14;
                return SFJS.itemTransformer.decryptItem(historyValue, encryptionParams.keys);

              case 14:
                historySession = new SFHistorySession(historyValue);

                this.historySession = historySession;
                _context68.next = 19;
                break;

              case 18:
                this.historySession = new SFHistorySession();

              case 19:
                _context68.next = 21;
                return this.storageManager.getItem(SessionHistoryAutoOptimizeKey);

              case 21:
                autoOptimizeValue = _context68.sent;

                if (autoOptimizeValue) {
                  this.autoOptimize = JSON.parse(autoOptimizeValue);
                } else {
                  // default value is true
                  this.autoOptimize = true;
                }

              case 23:
              case "end":
                return _context68.stop();
            }
          }
        }, _callee67, this);
      }));

      function loadFromDisk() {
        return _ref76.apply(this, arguments);
      }

      return loadFromDisk;
    }()
  }, {
    key: "toggleAutoOptimize",
    value: function () {
      var _ref77 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee68() {
        return regeneratorRuntime.wrap(function _callee68$(_context69) {
          while (1) {
            switch (_context69.prev = _context69.next) {
              case 0:
                this.autoOptimize = !this.autoOptimize;

                if (this.autoOptimize) {
                  this.storageManager.setItem(SessionHistoryAutoOptimizeKey, JSON.stringify(true));
                } else {
                  this.storageManager.setItem(SessionHistoryAutoOptimizeKey, JSON.stringify(false));
                }

              case 2:
              case "end":
                return _context69.stop();
            }
          }
        }, _callee68, this);
      }));

      function toggleAutoOptimize() {
        return _ref77.apply(this, arguments);
      }

      return toggleAutoOptimize;
    }()
  }]);

  return SFSessionHistoryManager;
}();

; /*
   The SingletonManager allows controllers to register an item as a singleton, which means only one instance of that model
   should exist, both on the server and on the client. When the SingletonManager detects multiple items matching the singleton predicate,
   the oldest ones will be deleted, leaving the newest ones. (See 4/28/18 update. We now choose the earliest created one as the winner.).
    (This no longer fully applies, See 4/28/18 update.) We will treat the model most recently arrived from the server as the most recent one. The reason for this is,
   if you're offline, a singleton can be created, as in the case of UserPreferneces. Then when you sign in, you'll retrieve your actual user preferences.
   In that case, even though the offline singleton has a more recent updated_at, the server retreived value is the one we care more about.
    4/28/18: I'm seeing this issue: if you have the app open in one window, then in another window sign in, and during sign in,
   click Refresh (or autorefresh occurs) in the original signed in window, then you will happen to receive from the server the newly created
   Extensions singleton, and it will be mistaken (it just looks like a regular retrieved item, since nothing is in saved) for a fresh, latest copy, and replace the current instance.
   This has happened to me and many users.
   A puzzling issue, but what if instead of resolving singletons by choosing the one most recently modified, we choose the one with the earliest create date?
   This way, we don't care when it was modified, but we always, always choose the item that was created first. This way, we always deal with the same item.
  */

var SFSingletonManager = exports.SFSingletonManager = function () {
  function SFSingletonManager(modelManager, syncManager) {
    var _this17 = this;

    _classCallCheck(this, SFSingletonManager);

    this.syncManager = syncManager;
    this.modelManager = modelManager;
    this.singletonHandlers = [];

    // We use sync observer instead of syncEvent `local-data-incremental-load`, because we want singletons
    // to resolve with the first priority, because they generally dictate app state.
    // If we used local-data-incremental-load, and 1 item was important singleton and 99 were heavy components,
    // then given the random nature of notifiying observers, the heavy components would spend a lot of time loading first,
    // here, we priortize ours loading as most important
    modelManager.addItemSyncObserverWithPriority({
      id: "sf-singleton-manager",
      types: "*",
      priority: -1,
      callback: function callback(allItems, validItems, deletedItems, source, sourceKey) {
        // Inside resolveSingletons, we are going to set items as dirty. If we don't stop here it will be infinite recursion.
        if (source === SFModelManager.MappingSourceLocalDirtied) {
          return;
        }
        _this17.resolveSingletons(modelManager.allNondummyItems, null, true);
      }
    });

    syncManager.addEventHandler(function (syncEvent, data) {
      if (syncEvent == "local-data-loaded") {
        _this17.resolveSingletons(modelManager.allNondummyItems, null, true);
        _this17.initialDataLoaded = true;
      } else if (syncEvent == "sync:completed") {
        // Wait for initial data load before handling any sync. If we don't want for initial data load,
        // then the singleton resolver won't have the proper items to work with to determine whether to resolve or create.
        if (!_this17.initialDataLoaded) {
          return;
        }
        // The reason we also need to consider savedItems in consolidating singletons is in case of sync conflicts,
        // a new item can be created, but is never processed through "retrievedItems" since it is only created locally then saved.

        // HOWEVER, by considering savedItems, we are now ruining everything, especially during sign in. A singleton can be created
        // offline, and upon sign in, will sync all items to the server, and by combining retrievedItems & savedItems, and only choosing
        // the latest, you are now resolving to the most recent one, which is in the savedItems list and not retrieved items, defeating
        // the whole purpose of this thing.

        // Updated solution: resolveSingletons will now evaluate both of these arrays separately.
        _this17.resolveSingletons(data.retrievedItems, data.savedItems);
      }
    });

    /*
      If an item alternates its uuid on registration, singletonHandlers might need to update
      their local reference to the object, since the object reference will change on uuid alternation
    */
    modelManager.addModelUuidChangeObserver("singleton-manager", function (oldModel, newModel) {
      var _iteratorNormalCompletion34 = true;
      var _didIteratorError34 = false;
      var _iteratorError34 = undefined;

      try {
        for (var _iterator34 = _this17.singletonHandlers[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
          var handler = _step34.value;

          if (handler.singleton && SFPredicate.ItemSatisfiesPredicates(newModel, handler.predicates)) {
            // Reference is now invalid, calling resolveSingleton should update it
            handler.singleton = null;
            _this17.resolveSingletons([newModel]);
          }
        }
      } catch (err) {
        _didIteratorError34 = true;
        _iteratorError34 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion34 && _iterator34.return) {
            _iterator34.return();
          }
        } finally {
          if (_didIteratorError34) {
            throw _iteratorError34;
          }
        }
      }
    });
  }

  _createClass(SFSingletonManager, [{
    key: "registerSingleton",
    value: function registerSingleton(predicates, resolveCallback, createBlock) {
      /*
      predicate: a key/value pair that specifies properties that should match in order for an item to be considered a predicate
      resolveCallback: called when one or more items are deleted and a new item becomes the reigning singleton
      createBlock: called when a sync is complete and no items are found. The createBlock should create the item and return it.
      */
      this.singletonHandlers.push({
        predicates: predicates,
        resolutionCallback: resolveCallback,
        createBlock: createBlock
      });
    }
  }, {
    key: "resolveSingletons",
    value: function resolveSingletons(retrievedItems, savedItems, initialLoad) {
      var _this18 = this;

      retrievedItems = retrievedItems || [];
      savedItems = savedItems || [];

      var _loop3 = function _loop3(singletonHandler) {
        var predicates = singletonHandler.predicates.slice();
        var retrievedSingletonItems = _this18.modelManager.filterItemsWithPredicates(retrievedItems, predicates);

        var handleCreation = function handleCreation() {
          if (singletonHandler.createBlock) {
            singletonHandler.pendingCreateBlockCallback = true;
            singletonHandler.createBlock(function (created) {
              singletonHandler.singleton = created;
              singletonHandler.pendingCreateBlockCallback = false;
              singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(created);
            });
          }
        };

        // We only want to consider saved items count to see if it's more than 0, and do nothing else with it.
        // This way we know there was some action and things need to be resolved. The saved items will come up
        // in filterItemsWithPredicate(this.modelManager.allNondummyItems) and be deleted anyway
        var savedSingletonItemsCount = _this18.modelManager.filterItemsWithPredicates(savedItems, predicates).length;

        if (retrievedSingletonItems.length > 0 || savedSingletonItemsCount > 0) {
          /*
            Check local inventory and make sure only 1 similar item exists. If more than 1, delete newest
            Note that this local inventory will also contain whatever is in retrievedItems.
          */
          var allExtantItemsMatchingPredicate = _this18.modelManager.itemsMatchingPredicates(predicates);

          /*
            Delete all but the earliest created
          */
          if (allExtantItemsMatchingPredicate.length >= 2) {
            var sorted = allExtantItemsMatchingPredicate.sort(function (a, b) {
              /*
                If compareFunction(a, b) is less than 0, sort a to an index lower than b, i.e. a comes first.
                If compareFunction(a, b) is greater than 0, sort b to an index lower than a, i.e. b comes first.
              */

              if (a.errorDecrypting) {
                return 1;
              }

              if (b.errorDecrypting) {
                return -1;
              }

              return a.created_at < b.created_at ? -1 : 1;
            });

            // The item that will be chosen to be kept
            var winningItem = sorted[0];

            // Items that will be deleted
            // Delete everything but the first one
            var toDelete = sorted.slice(1, sorted.length);

            var _iteratorNormalCompletion36 = true;
            var _didIteratorError36 = false;
            var _iteratorError36 = undefined;

            try {
              for (var _iterator36 = toDelete[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
                var d = _step36.value;

                _this18.modelManager.setItemToBeDeleted(d);
              }
            } catch (err) {
              _didIteratorError36 = true;
              _iteratorError36 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion36 && _iterator36.return) {
                  _iterator36.return();
                }
              } finally {
                if (_didIteratorError36) {
                  throw _iteratorError36;
                }
              }
            }

            _this18.syncManager.sync();

            // Send remaining item to callback
            singletonHandler.singleton = winningItem;
            singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(winningItem);
          } else if (allExtantItemsMatchingPredicate.length == 1) {
            var singleton = allExtantItemsMatchingPredicate[0];
            if (singleton.errorDecrypting) {
              // Delete the current singleton and create a new one
              _this18.modelManager.setItemToBeDeleted(singleton);
              handleCreation();
            } else if (!singletonHandler.singleton || singletonHandler.singleton !== singleton) {
              // Not yet notified interested parties of object
              singletonHandler.singleton = singleton;
              singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(singleton);
            }
          }
        } else {
          // Retrieved items does not include any items of interest. If we don't have a singleton registered to this handler,
          // we need to create one. Only do this on actual sync completetions and not on initial data load. Because we want
          // to get the latest from the server before making the decision to create a new item
          if (!singletonHandler.singleton && !initialLoad && !singletonHandler.pendingCreateBlockCallback) {
            handleCreation();
          }
        }
      };

      var _iteratorNormalCompletion35 = true;
      var _didIteratorError35 = false;
      var _iteratorError35 = undefined;

      try {
        for (var _iterator35 = this.singletonHandlers[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
          var singletonHandler = _step35.value;

          _loop3(singletonHandler);
        }
      } catch (err) {
        _didIteratorError35 = true;
        _iteratorError35 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion35 && _iterator35.return) {
            _iterator35.return();
          }
        } finally {
          if (_didIteratorError35) {
            throw _iteratorError35;
          }
        }
      }
    }
  }]);

  return SFSingletonManager;
}();

; // SFStorageManager should be subclassed, and all the methods below overwritten.

var SFStorageManager = exports.SFStorageManager = function () {
  function SFStorageManager() {
    _classCallCheck(this, SFStorageManager);
  }

  _createClass(SFStorageManager, [{
    key: "setItem",


    /* Simple Key/Value Storage */

    value: function () {
      var _ref78 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee69(key, value) {
        return regeneratorRuntime.wrap(function _callee69$(_context70) {
          while (1) {
            switch (_context70.prev = _context70.next) {
              case 0:
              case "end":
                return _context70.stop();
            }
          }
        }, _callee69, this);
      }));

      function setItem(_x111, _x112) {
        return _ref78.apply(this, arguments);
      }

      return setItem;
    }()
  }, {
    key: "getItem",
    value: function () {
      var _ref79 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee70(key) {
        return regeneratorRuntime.wrap(function _callee70$(_context71) {
          while (1) {
            switch (_context71.prev = _context71.next) {
              case 0:
              case "end":
                return _context71.stop();
            }
          }
        }, _callee70, this);
      }));

      function getItem(_x113) {
        return _ref79.apply(this, arguments);
      }

      return getItem;
    }()
  }, {
    key: "removeItem",
    value: function () {
      var _ref80 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee71(key) {
        return regeneratorRuntime.wrap(function _callee71$(_context72) {
          while (1) {
            switch (_context72.prev = _context72.next) {
              case 0:
              case "end":
                return _context72.stop();
            }
          }
        }, _callee71, this);
      }));

      function removeItem(_x114) {
        return _ref80.apply(this, arguments);
      }

      return removeItem;
    }()
  }, {
    key: "clear",
    value: function () {
      var _ref81 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee72() {
        return regeneratorRuntime.wrap(function _callee72$(_context73) {
          while (1) {
            switch (_context73.prev = _context73.next) {
              case 0:
              case "end":
                return _context73.stop();
            }
          }
        }, _callee72, this);
      }));

      function clear() {
        return _ref81.apply(this, arguments);
      }

      return clear;
    }()
  }, {
    key: "getAllModels",


    /*
    Model Storage
    */

    value: function () {
      var _ref82 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee73() {
        return regeneratorRuntime.wrap(function _callee73$(_context74) {
          while (1) {
            switch (_context74.prev = _context74.next) {
              case 0:
              case "end":
                return _context74.stop();
            }
          }
        }, _callee73, this);
      }));

      function getAllModels() {
        return _ref82.apply(this, arguments);
      }

      return getAllModels;
    }()
  }, {
    key: "saveModel",
    value: function () {
      var _ref83 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee74(item) {
        return regeneratorRuntime.wrap(function _callee74$(_context75) {
          while (1) {
            switch (_context75.prev = _context75.next) {
              case 0:
                return _context75.abrupt("return", this.saveModels([item]));

              case 1:
              case "end":
                return _context75.stop();
            }
          }
        }, _callee74, this);
      }));

      function saveModel(_x115) {
        return _ref83.apply(this, arguments);
      }

      return saveModel;
    }()
  }, {
    key: "saveModels",
    value: function () {
      var _ref84 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee75(items) {
        return regeneratorRuntime.wrap(function _callee75$(_context76) {
          while (1) {
            switch (_context76.prev = _context76.next) {
              case 0:
              case "end":
                return _context76.stop();
            }
          }
        }, _callee75, this);
      }));

      function saveModels(_x116) {
        return _ref84.apply(this, arguments);
      }

      return saveModels;
    }()
  }, {
    key: "deleteModel",
    value: function () {
      var _ref85 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee76(item) {
        return regeneratorRuntime.wrap(function _callee76$(_context77) {
          while (1) {
            switch (_context77.prev = _context77.next) {
              case 0:
              case "end":
                return _context77.stop();
            }
          }
        }, _callee76, this);
      }));

      function deleteModel(_x117) {
        return _ref85.apply(this, arguments);
      }

      return deleteModel;
    }()
  }, {
    key: "clearAllModels",
    value: function () {
      var _ref86 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee77() {
        return regeneratorRuntime.wrap(function _callee77$(_context78) {
          while (1) {
            switch (_context78.prev = _context78.next) {
              case 0:
              case "end":
                return _context78.stop();
            }
          }
        }, _callee77, this);
      }));

      function clearAllModels() {
        return _ref86.apply(this, arguments);
      }

      return clearAllModels;
    }()
  }, {
    key: "clearAllData",


    /* General */

    value: function () {
      var _ref87 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee78() {
        return regeneratorRuntime.wrap(function _callee78$(_context79) {
          while (1) {
            switch (_context79.prev = _context79.next) {
              case 0:
                return _context79.abrupt("return", Promise.all([this.clear(), this.clearAllModels()]));

              case 1:
              case "end":
                return _context79.stop();
            }
          }
        }, _callee78, this);
      }));

      function clearAllData() {
        return _ref87.apply(this, arguments);
      }

      return clearAllData;
    }()
  }]);

  return SFStorageManager;
}();

;
var SFSyncManager = exports.SFSyncManager = function () {
  function SFSyncManager(modelManager, storageManager, httpManager, timeout, interval) {
    _classCallCheck(this, SFSyncManager);

    SFSyncManager.KeyRequestLoadLocal = "KeyRequestLoadLocal";
    SFSyncManager.KeyRequestSaveLocal = "KeyRequestSaveLocal";
    SFSyncManager.KeyRequestLoadSaveAccount = "KeyRequestLoadSaveAccount";

    this.httpManager = httpManager;
    this.modelManager = modelManager;
    this.storageManager = storageManager;

    // Allows you to set your own interval/timeout function (i.e if you're using angular and want to use $timeout)
    this.$interval = interval || setInterval.bind(window);
    this.$timeout = timeout || setTimeout.bind(window);

    this.syncStatus = {};
    this.syncStatusObservers = [];
    this.eventHandlers = [];

    // this.loggingEnabled = true;

    this.PerSyncItemUploadLimit = 150;
    this.ServerItemDownloadLimit = 150;

    // The number of changed items that constitute a major change
    // This is used by the desktop app to create backups
    this.MajorDataChangeThreshold = 15;

    // Sync integrity checking
    // If X consective sync requests return mismatching hashes, then we officially enter out-of-sync.
    this.MaxDiscordanceBeforeOutOfSync = 5;

    // How many consective sync results have had mismatching hashes. This value can never exceed this.MaxDiscordanceBeforeOutOfSync.
    this.syncDiscordance = 0;
    this.outOfSync = false;
  }

  _createClass(SFSyncManager, [{
    key: "handleServerIntegrityHash",
    value: function () {
      var _ref88 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee79(serverHash) {
        var localHash;
        return regeneratorRuntime.wrap(function _callee79$(_context80) {
          while (1) {
            switch (_context80.prev = _context80.next) {
              case 0:
                if (!(!serverHash || serverHash.length == 0)) {
                  _context80.next = 2;
                  break;
                }

                return _context80.abrupt("return", true);

              case 2:
                _context80.next = 4;
                return this.modelManager.computeDataIntegrityHash();

              case 4:
                localHash = _context80.sent;

                if (localHash) {
                  _context80.next = 7;
                  break;
                }

                return _context80.abrupt("return", true);

              case 7:
                if (!(localHash !== serverHash)) {
                  _context80.next = 13;
                  break;
                }

                this.syncDiscordance++;
                if (this.syncDiscordance >= this.MaxDiscordanceBeforeOutOfSync) {
                  if (!this.outOfSync) {
                    this.outOfSync = true;
                    this.notifyEvent("enter-out-of-sync");
                  }
                }
                return _context80.abrupt("return", false);

              case 13:
                // Integrity matches
                if (this.outOfSync) {
                  this.outOfSync = false;
                  this.notifyEvent("exit-out-of-sync");
                }
                this.syncDiscordance = 0;
                return _context80.abrupt("return", true);

              case 16:
              case "end":
                return _context80.stop();
            }
          }
        }, _callee79, this);
      }));

      function handleServerIntegrityHash(_x118) {
        return _ref88.apply(this, arguments);
      }

      return handleServerIntegrityHash;
    }()
  }, {
    key: "isOutOfSync",
    value: function isOutOfSync() {
      // Once we are outOfSync, it's up to the client to display UI to the user to instruct them
      // to take action. The client should present a reconciliation wizard.
      return this.outOfSync;
    }
  }, {
    key: "getServerURL",
    value: function () {
      var _ref89 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee80() {
        return regeneratorRuntime.wrap(function _callee80$(_context81) {
          while (1) {
            switch (_context81.prev = _context81.next) {
              case 0:
                _context81.next = 2;
                return this.storageManager.getItem("server");

              case 2:
                _context81.t0 = _context81.sent;

                if (_context81.t0) {
                  _context81.next = 5;
                  break;
                }

                _context81.t0 = window._default_sf_server;

              case 5:
                return _context81.abrupt("return", _context81.t0);

              case 6:
              case "end":
                return _context81.stop();
            }
          }
        }, _callee80, this);
      }));

      function getServerURL() {
        return _ref89.apply(this, arguments);
      }

      return getServerURL;
    }()
  }, {
    key: "getSyncURL",
    value: function () {
      var _ref90 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee81() {
        return regeneratorRuntime.wrap(function _callee81$(_context82) {
          while (1) {
            switch (_context82.prev = _context82.next) {
              case 0:
                _context82.next = 2;
                return this.getServerURL();

              case 2:
                _context82.t0 = _context82.sent;
                return _context82.abrupt("return", _context82.t0 + "/items/sync");

              case 4:
              case "end":
                return _context82.stop();
            }
          }
        }, _callee81, this);
      }));

      function getSyncURL() {
        return _ref90.apply(this, arguments);
      }

      return getSyncURL;
    }()
  }, {
    key: "registerSyncStatusObserver",
    value: function registerSyncStatusObserver(callback) {
      var observer = { key: new Date(), callback: callback };
      this.syncStatusObservers.push(observer);
      return observer;
    }
  }, {
    key: "removeSyncStatusObserver",
    value: function removeSyncStatusObserver(observer) {
      _.pull(this.syncStatusObservers, observer);
    }
  }, {
    key: "syncStatusDidChange",
    value: function syncStatusDidChange() {
      var _this19 = this;

      this.syncStatusObservers.forEach(function (observer) {
        observer.callback(_this19.syncStatus);
      });
    }
  }, {
    key: "addEventHandler",
    value: function addEventHandler(handler) {
      /*
      Possible Events:
      sync:completed
      sync:taking-too-long
      sync:updated_token
      sync:error
      major-data-change
      local-data-loaded
      sync-session-invalid
      sync-exception
       */
      this.eventHandlers.push(handler);
      return handler;
    }
  }, {
    key: "removeEventHandler",
    value: function removeEventHandler(handler) {
      _.pull(this.eventHandlers, handler);
    }
  }, {
    key: "notifyEvent",
    value: function notifyEvent(syncEvent, data) {
      var _iteratorNormalCompletion37 = true;
      var _didIteratorError37 = false;
      var _iteratorError37 = undefined;

      try {
        for (var _iterator37 = this.eventHandlers[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
          var handler = _step37.value;

          handler(syncEvent, data || {});
        }
      } catch (err) {
        _didIteratorError37 = true;
        _iteratorError37 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion37 && _iterator37.return) {
            _iterator37.return();
          }
        } finally {
          if (_didIteratorError37) {
            throw _iteratorError37;
          }
        }
      }
    }
  }, {
    key: "setKeyRequestHandler",
    value: function setKeyRequestHandler(handler) {
      this.keyRequestHandler = handler;
    }
  }, {
    key: "getActiveKeyInfo",
    value: function () {
      var _ref91 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee82(request) {
        return regeneratorRuntime.wrap(function _callee82$(_context83) {
          while (1) {
            switch (_context83.prev = _context83.next) {
              case 0:
                return _context83.abrupt("return", this.keyRequestHandler(request));

              case 1:
              case "end":
                return _context83.stop();
            }
          }
        }, _callee82, this);
      }));

      function getActiveKeyInfo(_x119) {
        return _ref91.apply(this, arguments);
      }

      return getActiveKeyInfo;
    }()
  }, {
    key: "initialDataLoaded",
    value: function initialDataLoaded() {
      return this._initialDataLoaded === true;
    }
  }, {
    key: "_sortLocalItems",
    value: function _sortLocalItems(items) {
      var _this20 = this;

      return items.sort(function (a, b) {
        var dateResult = new Date(b.updated_at) - new Date(a.updated_at);

        var priorityList = _this20.contentTypeLoadPriority;
        var aPriority = 0,
            bPriority = 0;
        if (priorityList) {
          aPriority = priorityList.indexOf(a.content_type);
          bPriority = priorityList.indexOf(b.content_type);
          if (aPriority == -1) {
            // Not found in list, not prioritized. Set it to max value
            aPriority = priorityList.length;
          }
          if (bPriority == -1) {
            // Not found in list, not prioritized. Set it to max value
            bPriority = priorityList.length;
          }
        }

        if (aPriority == bPriority) {
          return dateResult;
        }

        if (aPriority < bPriority) {
          return -1;
        } else {
          return 1;
        }

        // aPriority < bPriority means a should come first
        return aPriority < bPriority ? -1 : 1;
      });
    }
  }, {
    key: "loadLocalItems",
    value: function () {
      var _ref92 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee84() {
        var _this21 = this;

        var _ref93 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            incrementalCallback = _ref93.incrementalCallback,
            batchSize = _ref93.batchSize,
            options = _ref93.options;

        var latency;
        return regeneratorRuntime.wrap(function _callee84$(_context85) {
          while (1) {
            switch (_context85.prev = _context85.next) {
              case 0:
                if (!(options && options.simulateHighLatency)) {
                  _context85.next = 4;
                  break;
                }

                latency = options.simulatedLatency || 1000;
                _context85.next = 4;
                return this._awaitSleep(latency);

              case 4:
                if (!this.loadLocalDataPromise) {
                  _context85.next = 6;
                  break;
                }

                return _context85.abrupt("return", this.loadLocalDataPromise);

              case 6:

                if (!batchSize) {
                  batchSize = 100;
                }

                this.loadLocalDataPromise = this.storageManager.getAllModels().then(function (items) {
                  // put most recently updated at beginning, sorted by priority
                  items = _this21._sortLocalItems(items);

                  // Filter out any items that exist in the local model mapping and have a lower dirtied date than the local dirtiedDate.
                  items = items.filter(function (nonDecryptedItem) {
                    var localItem = _this21.modelManager.findItem(nonDecryptedItem.uuid);
                    if (!localItem) {
                      return true;
                    }

                    return new Date(nonDecryptedItem.dirtiedDate) > localItem.dirtiedDate;
                  });

                  // break it up into chunks to make interface more responsive for large item counts
                  var total = items.length;
                  var current = 0;
                  var processed = [];

                  var decryptNext = function () {
                    var _ref94 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee83() {
                      var subitems, processedSubitems;
                      return regeneratorRuntime.wrap(function _callee83$(_context84) {
                        while (1) {
                          switch (_context84.prev = _context84.next) {
                            case 0:
                              subitems = items.slice(current, current + batchSize);
                              _context84.next = 3;
                              return _this21.handleItemsResponse(subitems, null, SFModelManager.MappingSourceLocalRetrieved, SFSyncManager.KeyRequestLoadLocal);

                            case 3:
                              processedSubitems = _context84.sent;

                              processed.push(processedSubitems);

                              current += subitems.length;

                              if (!(current < total)) {
                                _context84.next = 10;
                                break;
                              }

                              return _context84.abrupt("return", new Promise(function (innerResolve, innerReject) {
                                _this21.$timeout(function () {
                                  _this21.notifyEvent("local-data-incremental-load");
                                  incrementalCallback && incrementalCallback(current, total);
                                  decryptNext().then(innerResolve);
                                });
                              }));

                            case 10:
                              // Completed
                              _this21._initialDataLoaded = true;
                              _this21.notifyEvent("local-data-loaded");

                            case 12:
                            case "end":
                              return _context84.stop();
                          }
                        }
                      }, _callee83, _this21);
                    }));

                    return function decryptNext() {
                      return _ref94.apply(this, arguments);
                    };
                  }();

                  return decryptNext();
                });

                return _context85.abrupt("return", this.loadLocalDataPromise);

              case 9:
              case "end":
                return _context85.stop();
            }
          }
        }, _callee84, this);
      }));

      function loadLocalItems() {
        return _ref92.apply(this, arguments);
      }

      return loadLocalItems;
    }()
  }, {
    key: "writeItemsToLocalStorage",
    value: function () {
      var _ref95 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee88(items, offlineOnly) {
        var _this22 = this;

        return regeneratorRuntime.wrap(function _callee88$(_context89) {
          while (1) {
            switch (_context89.prev = _context89.next) {
              case 0:
                if (!(items.length == 0)) {
                  _context89.next = 2;
                  break;
                }

                return _context89.abrupt("return");

              case 2:
                return _context89.abrupt("return", new Promise(function () {
                  var _ref96 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee87(resolve, reject) {
                    var nonDeletedItems, deletedItems, _iteratorNormalCompletion38, _didIteratorError38, _iteratorError38, _iterator38, _step38, item, info, params;

                    return regeneratorRuntime.wrap(function _callee87$(_context88) {
                      while (1) {
                        switch (_context88.prev = _context88.next) {
                          case 0:
                            nonDeletedItems = [], deletedItems = [];
                            _iteratorNormalCompletion38 = true;
                            _didIteratorError38 = false;
                            _iteratorError38 = undefined;
                            _context88.prev = 4;

                            for (_iterator38 = items[Symbol.iterator](); !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
                              item = _step38.value;

                              // if the item is deleted and dirty it means we still need to sync it.
                              if (item.deleted === true && !item.dirty) {
                                deletedItems.push(item);
                              } else {
                                nonDeletedItems.push(item);
                              }
                            }

                            _context88.next = 12;
                            break;

                          case 8:
                            _context88.prev = 8;
                            _context88.t0 = _context88["catch"](4);
                            _didIteratorError38 = true;
                            _iteratorError38 = _context88.t0;

                          case 12:
                            _context88.prev = 12;
                            _context88.prev = 13;

                            if (!_iteratorNormalCompletion38 && _iterator38.return) {
                              _iterator38.return();
                            }

                          case 15:
                            _context88.prev = 15;

                            if (!_didIteratorError38) {
                              _context88.next = 18;
                              break;
                            }

                            throw _iteratorError38;

                          case 18:
                            return _context88.finish(15);

                          case 19:
                            return _context88.finish(12);

                          case 20:
                            if (!(deletedItems.length > 0)) {
                              _context88.next = 23;
                              break;
                            }

                            _context88.next = 23;
                            return Promise.all(deletedItems.map(function () {
                              var _ref97 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee85(deletedItem) {
                                return regeneratorRuntime.wrap(function _callee85$(_context86) {
                                  while (1) {
                                    switch (_context86.prev = _context86.next) {
                                      case 0:
                                        return _context86.abrupt("return", _this22.storageManager.deleteModel(deletedItem));

                                      case 1:
                                      case "end":
                                        return _context86.stop();
                                    }
                                  }
                                }, _callee85, _this22);
                              }));

                              return function (_x125) {
                                return _ref97.apply(this, arguments);
                              };
                            }()));

                          case 23:
                            _context88.next = 25;
                            return _this22.getActiveKeyInfo(SFSyncManager.KeyRequestSaveLocal);

                          case 25:
                            info = _context88.sent;

                            if (!(nonDeletedItems.length > 0)) {
                              _context88.next = 33;
                              break;
                            }

                            _context88.next = 29;
                            return Promise.all(nonDeletedItems.map(function () {
                              var _ref98 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee86(item) {
                                var itemParams;
                                return regeneratorRuntime.wrap(function _callee86$(_context87) {
                                  while (1) {
                                    switch (_context87.prev = _context87.next) {
                                      case 0:
                                        itemParams = new SFItemParams(item, info.keys, info.auth_params);
                                        _context87.next = 3;
                                        return itemParams.paramsForLocalStorage();

                                      case 3:
                                        itemParams = _context87.sent;

                                        if (offlineOnly) {
                                          delete itemParams.dirty;
                                        }
                                        return _context87.abrupt("return", itemParams);

                                      case 6:
                                      case "end":
                                        return _context87.stop();
                                    }
                                  }
                                }, _callee86, _this22);
                              }));

                              return function (_x126) {
                                return _ref98.apply(this, arguments);
                              };
                            }())).catch(function (e) {
                              return reject(e);
                            });

                          case 29:
                            params = _context88.sent;
                            _context88.next = 32;
                            return _this22.storageManager.saveModels(params).catch(function (error) {
                              console.error("Error writing items", error);
                              _this22.syncStatus.localError = error;
                              _this22.syncStatusDidChange();
                              reject();
                            });

                          case 32:

                            // on success
                            if (_this22.syncStatus.localError) {
                              _this22.syncStatus.localError = null;
                              _this22.syncStatusDidChange();
                            }

                          case 33:
                            resolve();

                          case 34:
                          case "end":
                            return _context88.stop();
                        }
                      }
                    }, _callee87, _this22, [[4, 8, 12, 20], [13,, 15, 19]]);
                  }));

                  return function (_x123, _x124) {
                    return _ref96.apply(this, arguments);
                  };
                }()));

              case 3:
              case "end":
                return _context89.stop();
            }
          }
        }, _callee88, this);
      }));

      function writeItemsToLocalStorage(_x121, _x122) {
        return _ref95.apply(this, arguments);
      }

      return writeItemsToLocalStorage;
    }()
  }, {
    key: "syncOffline",
    value: function () {
      var _ref99 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee89(items) {
        var _this23 = this;

        var _iteratorNormalCompletion39, _didIteratorError39, _iteratorError39, _iterator39, _step39, item;

        return regeneratorRuntime.wrap(function _callee89$(_context90) {
          while (1) {
            switch (_context90.prev = _context90.next) {
              case 0:
                // Update all items updated_at to now
                _iteratorNormalCompletion39 = true;
                _didIteratorError39 = false;
                _iteratorError39 = undefined;
                _context90.prev = 3;
                for (_iterator39 = items[Symbol.iterator](); !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
                  item = _step39.value;
                  item.updated_at = new Date();
                }
                _context90.next = 11;
                break;

              case 7:
                _context90.prev = 7;
                _context90.t0 = _context90["catch"](3);
                _didIteratorError39 = true;
                _iteratorError39 = _context90.t0;

              case 11:
                _context90.prev = 11;
                _context90.prev = 12;

                if (!_iteratorNormalCompletion39 && _iterator39.return) {
                  _iterator39.return();
                }

              case 14:
                _context90.prev = 14;

                if (!_didIteratorError39) {
                  _context90.next = 17;
                  break;
                }

                throw _iteratorError39;

              case 17:
                return _context90.finish(14);

              case 18:
                return _context90.finish(11);

              case 19:
                return _context90.abrupt("return", this.writeItemsToLocalStorage(items, true).then(function (responseItems) {
                  // delete anything needing to be deleted
                  var _iteratorNormalCompletion40 = true;
                  var _didIteratorError40 = false;
                  var _iteratorError40 = undefined;

                  try {
                    for (var _iterator40 = items[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
                      var _item = _step40.value;

                      if (_item.deleted) {
                        _this23.modelManager.removeItemLocally(_item);
                      }
                    }
                  } catch (err) {
                    _didIteratorError40 = true;
                    _iteratorError40 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion40 && _iterator40.return) {
                        _iterator40.return();
                      }
                    } finally {
                      if (_didIteratorError40) {
                        throw _iteratorError40;
                      }
                    }
                  }

                  _this23.modelManager.clearDirtyItems(items);
                  // Required in order for modelManager to notify sync observers
                  _this23.modelManager.didSyncModelsOffline(items);

                  _this23.notifyEvent("sync:completed", { savedItems: items });
                  return { saved_items: items };
                }));

              case 20:
              case "end":
                return _context90.stop();
            }
          }
        }, _callee89, this, [[3, 7, 11, 19], [12,, 14, 18]]);
      }));

      function syncOffline(_x127) {
        return _ref99.apply(this, arguments);
      }

      return syncOffline;
    }()

    /*
      In the case of signing in and merging local data, we alternative UUIDs
      to avoid overwriting data a user may retrieve that has the same UUID.
      Alternating here forces us to to create duplicates of the items instead.
     */

  }, {
    key: "markAllItemsDirtyAndSaveOffline",
    value: function () {
      var _ref100 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee90(alternateUUIDs) {
        var originalItems, _iteratorNormalCompletion41, _didIteratorError41, _iteratorError41, _iterator41, _step41, item, allItems, _iteratorNormalCompletion42, _didIteratorError42, _iteratorError42, _iterator42, _step42, _item2;

        return regeneratorRuntime.wrap(function _callee90$(_context91) {
          while (1) {
            switch (_context91.prev = _context91.next) {
              case 0:
                if (!alternateUUIDs) {
                  _context91.next = 28;
                  break;
                }

                // use a copy, as alternating uuid will affect array
                originalItems = this.modelManager.allNondummyItems.filter(function (item) {
                  return !item.errorDecrypting;
                }).slice();
                _iteratorNormalCompletion41 = true;
                _didIteratorError41 = false;
                _iteratorError41 = undefined;
                _context91.prev = 5;
                _iterator41 = originalItems[Symbol.iterator]();

              case 7:
                if (_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done) {
                  _context91.next = 14;
                  break;
                }

                item = _step41.value;
                _context91.next = 11;
                return this.modelManager.alternateUUIDForItem(item);

              case 11:
                _iteratorNormalCompletion41 = true;
                _context91.next = 7;
                break;

              case 14:
                _context91.next = 20;
                break;

              case 16:
                _context91.prev = 16;
                _context91.t0 = _context91["catch"](5);
                _didIteratorError41 = true;
                _iteratorError41 = _context91.t0;

              case 20:
                _context91.prev = 20;
                _context91.prev = 21;

                if (!_iteratorNormalCompletion41 && _iterator41.return) {
                  _iterator41.return();
                }

              case 23:
                _context91.prev = 23;

                if (!_didIteratorError41) {
                  _context91.next = 26;
                  break;
                }

                throw _iteratorError41;

              case 26:
                return _context91.finish(23);

              case 27:
                return _context91.finish(20);

              case 28:
                allItems = this.modelManager.allNondummyItems;
                _iteratorNormalCompletion42 = true;
                _didIteratorError42 = false;
                _iteratorError42 = undefined;
                _context91.prev = 32;

                for (_iterator42 = allItems[Symbol.iterator](); !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                  _item2 = _step42.value;
                  _item2.setDirty(true);
                }
                _context91.next = 40;
                break;

              case 36:
                _context91.prev = 36;
                _context91.t1 = _context91["catch"](32);
                _didIteratorError42 = true;
                _iteratorError42 = _context91.t1;

              case 40:
                _context91.prev = 40;
                _context91.prev = 41;

                if (!_iteratorNormalCompletion42 && _iterator42.return) {
                  _iterator42.return();
                }

              case 43:
                _context91.prev = 43;

                if (!_didIteratorError42) {
                  _context91.next = 46;
                  break;
                }

                throw _iteratorError42;

              case 46:
                return _context91.finish(43);

              case 47:
                return _context91.finish(40);

              case 48:
                return _context91.abrupt("return", this.writeItemsToLocalStorage(allItems, false));

              case 49:
              case "end":
                return _context91.stop();
            }
          }
        }, _callee90, this, [[5, 16, 20, 28], [21,, 23, 27], [32, 36, 40, 48], [41,, 43, 47]]);
      }));

      function markAllItemsDirtyAndSaveOffline(_x128) {
        return _ref100.apply(this, arguments);
      }

      return markAllItemsDirtyAndSaveOffline;
    }()
  }, {
    key: "setSyncToken",
    value: function () {
      var _ref101 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee91(token) {
        return regeneratorRuntime.wrap(function _callee91$(_context92) {
          while (1) {
            switch (_context92.prev = _context92.next) {
              case 0:
                this._syncToken = token;
                _context92.next = 3;
                return this.storageManager.setItem("syncToken", token);

              case 3:
              case "end":
                return _context92.stop();
            }
          }
        }, _callee91, this);
      }));

      function setSyncToken(_x129) {
        return _ref101.apply(this, arguments);
      }

      return setSyncToken;
    }()
  }, {
    key: "getSyncToken",
    value: function () {
      var _ref102 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee92() {
        return regeneratorRuntime.wrap(function _callee92$(_context93) {
          while (1) {
            switch (_context93.prev = _context93.next) {
              case 0:
                if (this._syncToken) {
                  _context93.next = 4;
                  break;
                }

                _context93.next = 3;
                return this.storageManager.getItem("syncToken");

              case 3:
                this._syncToken = _context93.sent;

              case 4:
                return _context93.abrupt("return", this._syncToken);

              case 5:
              case "end":
                return _context93.stop();
            }
          }
        }, _callee92, this);
      }));

      function getSyncToken() {
        return _ref102.apply(this, arguments);
      }

      return getSyncToken;
    }()
  }, {
    key: "setCursorToken",
    value: function () {
      var _ref103 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee93(token) {
        return regeneratorRuntime.wrap(function _callee93$(_context94) {
          while (1) {
            switch (_context94.prev = _context94.next) {
              case 0:
                this._cursorToken = token;

                if (!token) {
                  _context94.next = 6;
                  break;
                }

                _context94.next = 4;
                return this.storageManager.setItem("cursorToken", token);

              case 4:
                _context94.next = 8;
                break;

              case 6:
                _context94.next = 8;
                return this.storageManager.removeItem("cursorToken");

              case 8:
              case "end":
                return _context94.stop();
            }
          }
        }, _callee93, this);
      }));

      function setCursorToken(_x130) {
        return _ref103.apply(this, arguments);
      }

      return setCursorToken;
    }()
  }, {
    key: "getCursorToken",
    value: function () {
      var _ref104 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee94() {
        return regeneratorRuntime.wrap(function _callee94$(_context95) {
          while (1) {
            switch (_context95.prev = _context95.next) {
              case 0:
                if (this._cursorToken) {
                  _context95.next = 4;
                  break;
                }

                _context95.next = 3;
                return this.storageManager.getItem("cursorToken");

              case 3:
                this._cursorToken = _context95.sent;

              case 4:
                return _context95.abrupt("return", this._cursorToken);

              case 5:
              case "end":
                return _context95.stop();
            }
          }
        }, _callee94, this);
      }));

      function getCursorToken() {
        return _ref104.apply(this, arguments);
      }

      return getCursorToken;
    }()
  }, {
    key: "clearQueuedCallbacks",
    value: function clearQueuedCallbacks() {
      this._queuedCallbacks = [];
    }
  }, {
    key: "callQueuedCallbacks",
    value: function callQueuedCallbacks(response) {
      var allCallbacks = this.queuedCallbacks;
      if (allCallbacks.length) {
        var _iteratorNormalCompletion43 = true;
        var _didIteratorError43 = false;
        var _iteratorError43 = undefined;

        try {
          for (var _iterator43 = allCallbacks[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
            var eachCallback = _step43.value;

            eachCallback(response);
          }
        } catch (err) {
          _didIteratorError43 = true;
          _iteratorError43 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion43 && _iterator43.return) {
              _iterator43.return();
            }
          } finally {
            if (_didIteratorError43) {
              throw _iteratorError43;
            }
          }
        }

        this.clearQueuedCallbacks();
      }
    }
  }, {
    key: "beginCheckingIfSyncIsTakingTooLong",
    value: function beginCheckingIfSyncIsTakingTooLong() {
      if (this.syncStatus.checker) {
        this.stopCheckingIfSyncIsTakingTooLong();
      }
      this.syncStatus.checker = this.$interval(function () {
        // check to see if the ongoing sync is taking too long, alert the user
        var secondsPassed = (new Date() - this.syncStatus.syncStart) / 1000;
        var warningThreshold = 5.0; // seconds
        if (secondsPassed > warningThreshold) {
          this.notifyEvent("sync:taking-too-long");
          this.stopCheckingIfSyncIsTakingTooLong();
        }
      }.bind(this), 500);
    }
  }, {
    key: "stopCheckingIfSyncIsTakingTooLong",
    value: function stopCheckingIfSyncIsTakingTooLong() {
      if (this.$interval.hasOwnProperty("cancel")) {
        this.$interval.cancel(this.syncStatus.checker);
      } else {
        clearInterval(this.syncStatus.checker);
      }
      this.syncStatus.checker = null;
    }
  }, {
    key: "lockSyncing",
    value: function lockSyncing() {
      this.syncLocked = true;
    }
  }, {
    key: "unlockSyncing",
    value: function unlockSyncing() {
      this.syncLocked = false;
    }
  }, {
    key: "sync",
    value: function () {
      var _ref105 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee96() {
        var _this24 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return regeneratorRuntime.wrap(function _callee96$(_context97) {
          while (1) {
            switch (_context97.prev = _context97.next) {
              case 0:
                if (!this.syncLocked) {
                  _context97.next = 3;
                  break;
                }

                console.log("Sync Locked, Returning;");
                return _context97.abrupt("return");

              case 3:
                return _context97.abrupt("return", new Promise(function () {
                  var _ref106 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee95(resolve, reject) {
                    var allDirtyItems, dirtyItemsNotYetSaved, info, isSyncInProgress, initialDataLoaded, isContinuationSync, submitLimit, subItems, params, _iteratorNormalCompletion44, _didIteratorError44, _iteratorError44, _iterator44, _step44, item;

                    return regeneratorRuntime.wrap(function _callee95$(_context96) {
                      while (1) {
                        switch (_context96.prev = _context96.next) {
                          case 0:

                            if (!options) options = {};

                            allDirtyItems = _this24.modelManager.getDirtyItems();
                            dirtyItemsNotYetSaved = allDirtyItems.filter(function (candidate) {
                              return !_this24.lastDirtyItemsSave || candidate.dirtiedDate > _this24.lastDirtyItemsSave;
                            });
                            _context96.next = 5;
                            return _this24.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

                          case 5:
                            info = _context96.sent;
                            isSyncInProgress = _this24.syncStatus.syncOpInProgress;
                            initialDataLoaded = _this24.initialDataLoaded();

                            if (!(isSyncInProgress || !initialDataLoaded)) {
                              _context96.next = 16;
                              break;
                            }

                            _this24.performSyncAgainOnCompletion = true;
                            _this24.lastDirtyItemsSave = new Date();
                            _context96.next = 13;
                            return _this24.writeItemsToLocalStorage(dirtyItemsNotYetSaved, false);

                          case 13:
                            if (isSyncInProgress) {
                              _this24.queuedCallbacks.push(resolve);
                              if (_this24.loggingEnabled) {
                                console.warn("Attempting to sync while existing sync is in progress.");
                              }
                            }
                            if (!initialDataLoaded) {
                              if (_this24.loggingEnabled) {
                                console.warn("(1) Attempting to perform online sync before local data has loaded");
                              }
                              // Resolve right away, as we can't be sure when local data will be called by consumer.
                              resolve();
                            }
                            return _context96.abrupt("return");

                          case 16:

                            // Set this value immediately after checking it above, to avoid race conditions.
                            _this24.syncStatus.syncOpInProgress = true;

                            if (!info.offline) {
                              _context96.next = 19;
                              break;
                            }

                            return _context96.abrupt("return", _this24.syncOffline(allDirtyItems).then(function (response) {
                              _this24.syncStatus.syncOpInProgress = false;
                              resolve(response);
                            }).catch(function (e) {
                              _this24.notifyEvent("sync-exception", e);
                            }));

                          case 19:
                            if (_this24.initialDataLoaded()) {
                              _context96.next = 22;
                              break;
                            }

                            console.error("Attempting to perform online sync before local data has loaded");
                            return _context96.abrupt("return");

                          case 22:

                            if (_this24.loggingEnabled) {
                              console.log("Syncing online user.");
                            }

                            isContinuationSync = _this24.syncStatus.needsMoreSync;

                            _this24.syncStatus.syncStart = new Date();
                            _this24.beginCheckingIfSyncIsTakingTooLong();

                            submitLimit = _this24.PerSyncItemUploadLimit;
                            subItems = allDirtyItems.slice(0, submitLimit);

                            if (subItems.length < allDirtyItems.length) {
                              // more items left to be synced, repeat
                              _this24.syncStatus.needsMoreSync = true;
                            } else {
                              _this24.syncStatus.needsMoreSync = false;
                            }

                            if (!isContinuationSync) {
                              _this24.syncStatus.total = allDirtyItems.length;
                              _this24.syncStatus.current = 0;
                            }

                            // If items are marked as dirty during a long running sync request, total isn't updated
                            // This happens mostly in the case of large imports and sync conflicts where duplicated items are created
                            if (_this24.syncStatus.current > _this24.syncStatus.total) {
                              _this24.syncStatus.total = _this24.syncStatus.current;
                            }

                            _this24.syncStatusDidChange();

                            // Perform save after you've updated all status signals above. Presync save can take several seconds in some cases.
                            // Write to local storage before beginning sync.
                            // This way, if they close the browser before the sync request completes, local changes will not be lost
                            _context96.next = 34;
                            return _this24.writeItemsToLocalStorage(dirtyItemsNotYetSaved, false);

                          case 34:
                            _this24.lastDirtyItemsSave = new Date();

                            if (options.onPreSyncSave) {
                              options.onPreSyncSave();
                            }

                            // when doing a sync request that returns items greater than the limit, and thus subsequent syncs are required,
                            // we want to keep track of all retreived items, then save to local storage only once all items have been retrieved,
                            // so that relationships remain intact
                            // Update 12/18: I don't think we need to do this anymore, since relationships will now retroactively resolve their relationships,
                            // if an item they were looking for hasn't been pulled in yet.
                            if (!_this24.allRetreivedItems) {
                              _this24.allRetreivedItems = [];
                            }

                            // We also want to do this for savedItems
                            if (!_this24.allSavedItems) {
                              _this24.allSavedItems = [];
                            }

                            params = {};

                            params.limit = _this24.ServerItemDownloadLimit;

                            if (options.performIntegrityCheck) {
                              params.compute_integrity = true;
                            }

                            _context96.prev = 41;
                            _context96.next = 44;
                            return Promise.all(subItems.map(function (item) {
                              var itemParams = new SFItemParams(item, info.keys, info.auth_params);
                              itemParams.additionalFields = options.additionalFields;
                              return itemParams.paramsForSync();
                            })).then(function (itemsParams) {
                              params.items = itemsParams;
                            });

                          case 44:
                            _context96.next = 49;
                            break;

                          case 46:
                            _context96.prev = 46;
                            _context96.t0 = _context96["catch"](41);

                            _this24.notifyEvent("sync-exception", _context96.t0);

                          case 49:
                            _iteratorNormalCompletion44 = true;
                            _didIteratorError44 = false;
                            _iteratorError44 = undefined;
                            _context96.prev = 52;


                            for (_iterator44 = subItems[Symbol.iterator](); !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
                              item = _step44.value;

                              // Reset dirty counter to 0, since we're about to sync it.
                              // This means anyone marking the item as dirty after this will cause it so sync again and not be cleared on sync completion.
                              item.dirtyCount = 0;
                            }

                            _context96.next = 60;
                            break;

                          case 56:
                            _context96.prev = 56;
                            _context96.t1 = _context96["catch"](52);
                            _didIteratorError44 = true;
                            _iteratorError44 = _context96.t1;

                          case 60:
                            _context96.prev = 60;
                            _context96.prev = 61;

                            if (!_iteratorNormalCompletion44 && _iterator44.return) {
                              _iterator44.return();
                            }

                          case 63:
                            _context96.prev = 63;

                            if (!_didIteratorError44) {
                              _context96.next = 66;
                              break;
                            }

                            throw _iteratorError44;

                          case 66:
                            return _context96.finish(63);

                          case 67:
                            return _context96.finish(60);

                          case 68:
                            _context96.next = 70;
                            return _this24.getSyncToken();

                          case 70:
                            params.sync_token = _context96.sent;
                            _context96.next = 73;
                            return _this24.getCursorToken();

                          case 73:
                            params.cursor_token = _context96.sent;


                            params['api'] = SFHttpManager.getApiVersion();

                            _context96.prev = 75;
                            _context96.t2 = _this24.httpManager;
                            _context96.next = 79;
                            return _this24.getSyncURL();

                          case 79:
                            _context96.t3 = _context96.sent;
                            _context96.t4 = params;

                            _context96.t5 = function (response) {
                              _this24.handleSyncSuccess(subItems, response, options).then(function () {
                                resolve(response);
                              }).catch(function (e) {
                                console.log("Caught sync success exception:", e);
                                _this24.handleSyncError(null, null, allDirtyItems).then(function (errorResponse) {
                                  resolve(errorResponse);
                                });
                              });
                            };

                            _context96.t6 = function (response, statusCode) {
                              _this24.handleSyncError(response, statusCode, allDirtyItems).then(function (errorResponse) {
                                resolve(errorResponse);
                              });
                            };

                            _context96.t2.postAuthenticatedAbsolute.call(_context96.t2, _context96.t3, _context96.t4, _context96.t5, _context96.t6);

                            _context96.next = 89;
                            break;

                          case 86:
                            _context96.prev = 86;
                            _context96.t7 = _context96["catch"](75);

                            console.log("Sync exception caught:", _context96.t7);

                          case 89:
                          case "end":
                            return _context96.stop();
                        }
                      }
                    }, _callee95, _this24, [[41, 46], [52, 56, 60, 68], [61,, 63, 67], [75, 86]]);
                  }));

                  return function (_x132, _x133) {
                    return _ref106.apply(this, arguments);
                  };
                }()));

              case 4:
              case "end":
                return _context97.stop();
            }
          }
        }, _callee96, this);
      }));

      function sync() {
        return _ref105.apply(this, arguments);
      }

      return sync;
    }()
  }, {
    key: "_awaitSleep",
    value: function () {
      var _ref107 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee97(durationInMs) {
        return regeneratorRuntime.wrap(function _callee97$(_context98) {
          while (1) {
            switch (_context98.prev = _context98.next) {
              case 0:
                console.warn("Simulating high latency sync request", durationInMs);
                return _context98.abrupt("return", new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    resolve();
                  }, durationInMs);
                }));

              case 2:
              case "end":
                return _context98.stop();
            }
          }
        }, _callee97, this);
      }));

      function _awaitSleep(_x134) {
        return _ref107.apply(this, arguments);
      }

      return _awaitSleep;
    }()
  }, {
    key: "handleSyncSuccess",
    value: function () {
      var _ref108 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee98(syncedItems, response, options) {
        var _this25 = this;

        var latency, allSavedUUIDs, currentRequestSavedUUIDs, itemsToClearAsDirty, _iteratorNormalCompletion45, _didIteratorError45, _iteratorError45, _iterator45, _step45, item, retrieved, omitFields, saved, deprecated_unsaved, conflicts, conflictsNeedSync, matches, cursorToken;

        return regeneratorRuntime.wrap(function _callee98$(_context99) {
          while (1) {
            switch (_context99.prev = _context99.next) {
              case 0:
                if (!options.simulateHighLatency) {
                  _context99.next = 4;
                  break;
                }

                latency = options.simulatedLatency || 1000;
                _context99.next = 4;
                return this._awaitSleep(latency);

              case 4:

                this.syncStatus.error = null;

                if (this.loggingEnabled) {
                  console.log("Sync response", response);
                }

                allSavedUUIDs = this.allSavedItems.map(function (item) {
                  return item.uuid;
                });
                currentRequestSavedUUIDs = response.saved_items.map(function (savedResponse) {
                  return savedResponse.uuid;
                });


                response.retrieved_items = response.retrieved_items.filter(function (retrievedItem) {
                  var isInPreviousSaved = allSavedUUIDs.includes(retrievedItem.uuid);
                  var isInCurrentSaved = currentRequestSavedUUIDs.includes(retrievedItem.uuid);
                  if (isInPreviousSaved || isInCurrentSaved) {
                    return false;
                  }

                  var localItem = _this25.modelManager.findItem(retrievedItem.uuid);
                  if (localItem && localItem.dirty) {
                    return false;
                  }
                  return true;
                });

                // Clear dirty items after we've finish filtering retrieved_items above, since that depends on dirty items.
                // Check to make sure any subItem hasn't been marked as dirty again while a sync was ongoing
                itemsToClearAsDirty = [];
                _iteratorNormalCompletion45 = true;
                _didIteratorError45 = false;
                _iteratorError45 = undefined;
                _context99.prev = 13;

                for (_iterator45 = syncedItems[Symbol.iterator](); !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
                  item = _step45.value;

                  if (item.dirtyCount == 0) {
                    // Safe to clear as dirty
                    itemsToClearAsDirty.push(item);
                  }
                }

                _context99.next = 21;
                break;

              case 17:
                _context99.prev = 17;
                _context99.t0 = _context99["catch"](13);
                _didIteratorError45 = true;
                _iteratorError45 = _context99.t0;

              case 21:
                _context99.prev = 21;
                _context99.prev = 22;

                if (!_iteratorNormalCompletion45 && _iterator45.return) {
                  _iterator45.return();
                }

              case 24:
                _context99.prev = 24;

                if (!_didIteratorError45) {
                  _context99.next = 27;
                  break;
                }

                throw _iteratorError45;

              case 27:
                return _context99.finish(24);

              case 28:
                return _context99.finish(21);

              case 29:
                this.modelManager.clearDirtyItems(itemsToClearAsDirty);

                // Map retrieved items to local data
                // Note that deleted items will not be returned
                _context99.next = 32;
                return this.handleItemsResponse(response.retrieved_items, null, SFModelManager.MappingSourceRemoteRetrieved, SFSyncManager.KeyRequestLoadSaveAccount);

              case 32:
                retrieved = _context99.sent;


                // Append items to master list of retrieved items for this ongoing sync operation
                this.allRetreivedItems = this.allRetreivedItems.concat(retrieved);
                this.syncStatus.retrievedCount = this.allRetreivedItems.length;

                // Merge only metadata for saved items
                // we write saved items to disk now because it clears their dirty status then saves
                // if we saved items before completion, we had have to save them as dirty and save them again on success as clean
                omitFields = ["content", "auth_hash"];

                // Map saved items to local data

                _context99.next = 38;
                return this.handleItemsResponse(response.saved_items, omitFields, SFModelManager.MappingSourceRemoteSaved, SFSyncManager.KeyRequestLoadSaveAccount);

              case 38:
                saved = _context99.sent;


                // Append items to master list of saved items for this ongoing sync operation
                this.allSavedItems = this.allSavedItems.concat(saved);

                // 'unsaved' is deprecated and replaced with 'conflicts' in newer version.
                deprecated_unsaved = response.unsaved;
                _context99.next = 43;
                return this.deprecated_handleUnsavedItemsResponse(deprecated_unsaved);

              case 43:
                _context99.next = 45;
                return this.handleConflictsResponse(response.conflicts);

              case 45:
                conflicts = _context99.sent;
                conflictsNeedSync = conflicts && conflicts.length > 0;

                if (!conflicts) {
                  _context99.next = 50;
                  break;
                }

                _context99.next = 50;
                return this.writeItemsToLocalStorage(conflicts, false);

              case 50:
                _context99.next = 52;
                return this.writeItemsToLocalStorage(saved, false);

              case 52:
                _context99.next = 54;
                return this.writeItemsToLocalStorage(retrieved, false);

              case 54:
                if (!(response.integrity_hash && !response.cursor_token)) {
                  _context99.next = 59;
                  break;
                }

                _context99.next = 57;
                return this.handleServerIntegrityHash(response.integrity_hash);

              case 57:
                matches = _context99.sent;

                if (!matches) {
                  // If the server hash doesn't match our local hash, we want to continue syncing until we reach
                  // the max discordance threshold
                  if (this.syncDiscordance < this.MaxDiscordanceBeforeOutOfSync) {
                    this.performSyncAgainOnCompletion = true;
                  }
                }

              case 59:

                this.syncStatus.syncOpInProgress = false;
                this.syncStatus.current += syncedItems.length;

                this.syncStatusDidChange();

                // set the sync token at the end, so that if any errors happen above, you can resync
                this.setSyncToken(response.sync_token);
                this.setCursorToken(response.cursor_token);

                this.stopCheckingIfSyncIsTakingTooLong();

                _context99.next = 67;
                return this.getCursorToken();

              case 67:
                cursorToken = _context99.sent;

                if (!(cursorToken || this.syncStatus.needsMoreSync)) {
                  _context99.next = 72;
                  break;
                }

                return _context99.abrupt("return", new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    this.sync(options).then(resolve);
                  }.bind(_this25), 10); // wait 10ms to allow UI to update
                }));

              case 72:
                if (!conflictsNeedSync) {
                  _context99.next = 77;
                  break;
                }

                // We'll use the conflict sync as the next sync, so performSyncAgainOnCompletion can be turned off.
                this.performSyncAgainOnCompletion = false;
                // Include as part of await/resolve chain
                return _context99.abrupt("return", new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    _this25.sync(options).then(resolve);
                  }, 10); // wait 10ms to allow UI to update
                }));

              case 77:
                this.syncStatus.retrievedCount = 0;

                // current and total represent what's going up, not what's come down or saved.
                this.syncStatus.current = 0;
                this.syncStatus.total = 0;

                this.syncStatusDidChange();

                if (this.allRetreivedItems.length >= this.majorDataChangeThreshold || saved.length >= this.majorDataChangeThreshold || deprecated_unsaved && deprecated_unsaved.length >= this.majorDataChangeThreshold || conflicts && conflicts.length >= this.majorDataChangeThreshold) {
                  this.notifyEvent("major-data-change");
                }

                this.callQueuedCallbacks(response);
                this.notifyEvent("sync:completed", { retrievedItems: this.allRetreivedItems, savedItems: this.allSavedItems });

                this.allRetreivedItems = [];
                this.allSavedItems = [];

                if (this.performSyncAgainOnCompletion) {
                  this.performSyncAgainOnCompletion = false;
                  setTimeout(function () {
                    _this25.sync(options);
                  }, 10); // wait 10ms to allow UI to update
                }

                return _context99.abrupt("return", response);

              case 88:
              case "end":
                return _context99.stop();
            }
          }
        }, _callee98, this, [[13, 17, 21, 29], [22,, 24, 28]]);
      }));

      function handleSyncSuccess(_x135, _x136, _x137) {
        return _ref108.apply(this, arguments);
      }

      return handleSyncSuccess;
    }()
  }, {
    key: "handleSyncError",
    value: function () {
      var _ref109 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee99(response, statusCode, allDirtyItems) {
        return regeneratorRuntime.wrap(function _callee99$(_context100) {
          while (1) {
            switch (_context100.prev = _context100.next) {
              case 0:
                console.log("Sync error: ", response);

                if (statusCode == 401) {
                  this.notifyEvent("sync-session-invalid");
                }

                if (!response) {
                  response = { error: { message: "Could not connect to server." } };
                } else if (typeof response == 'string') {
                  response = { error: { message: response } };
                }

                this.syncStatus.syncOpInProgress = false;
                this.syncStatus.error = response.error;
                this.syncStatusDidChange();

                this.writeItemsToLocalStorage(allDirtyItems, false);
                this.modelManager.didSyncModelsOffline(allDirtyItems);

                this.stopCheckingIfSyncIsTakingTooLong();

                this.notifyEvent("sync:error", response.error);

                this.callQueuedCallbacks({ error: "Sync error" });

                return _context100.abrupt("return", response);

              case 12:
              case "end":
                return _context100.stop();
            }
          }
        }, _callee99, this);
      }));

      function handleSyncError(_x138, _x139, _x140) {
        return _ref109.apply(this, arguments);
      }

      return handleSyncError;
    }()
  }, {
    key: "handleItemsResponse",
    value: function () {
      var _ref110 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee100(responseItems, omitFields, source, keyRequest) {
        var keys, items, itemsWithErrorStatusChange;
        return regeneratorRuntime.wrap(function _callee100$(_context101) {
          while (1) {
            switch (_context101.prev = _context101.next) {
              case 0:
                _context101.next = 2;
                return this.getActiveKeyInfo(keyRequest);

              case 2:
                keys = _context101.sent.keys;
                _context101.next = 5;
                return SFJS.itemTransformer.decryptMultipleItems(responseItems, keys);

              case 5:
                _context101.next = 7;
                return this.modelManager.mapResponseItemsToLocalModelsOmittingFields(responseItems, omitFields, source);

              case 7:
                items = _context101.sent;


                // During the decryption process, items may be marked as "errorDecrypting". If so, we want to be sure
                // to persist this new state by writing these items back to local storage. When an item's "errorDecrypting"
                // flag is changed, its "errorDecryptingValueChanged" flag will be set, so we can find these items by filtering (then unsetting) below:
                itemsWithErrorStatusChange = items.filter(function (item) {
                  var valueChanged = item.errorDecryptingValueChanged;
                  // unset after consuming value
                  item.errorDecryptingValueChanged = false;
                  return valueChanged;
                });

                if (itemsWithErrorStatusChange.length > 0) {
                  this.writeItemsToLocalStorage(itemsWithErrorStatusChange, false);
                }

                return _context101.abrupt("return", items);

              case 11:
              case "end":
                return _context101.stop();
            }
          }
        }, _callee100, this);
      }));

      function handleItemsResponse(_x141, _x142, _x143, _x144) {
        return _ref110.apply(this, arguments);
      }

      return handleItemsResponse;
    }()
  }, {
    key: "refreshErroredItems",
    value: function () {
      var _ref111 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee101() {
        var erroredItems;
        return regeneratorRuntime.wrap(function _callee101$(_context102) {
          while (1) {
            switch (_context102.prev = _context102.next) {
              case 0:
                erroredItems = this.modelManager.allNondummyItems.filter(function (item) {
                  return item.errorDecrypting == true;
                });

                if (!(erroredItems.length > 0)) {
                  _context102.next = 3;
                  break;
                }

                return _context102.abrupt("return", this.handleItemsResponse(erroredItems, null, SFModelManager.MappingSourceLocalRetrieved, SFSyncManager.KeyRequestLoadSaveAccount));

              case 3:
              case "end":
                return _context102.stop();
            }
          }
        }, _callee101, this);
      }));

      function refreshErroredItems() {
        return _ref111.apply(this, arguments);
      }

      return refreshErroredItems;
    }()

    /*
    The difference between 'unsaved' (deprecated_handleUnsavedItemsResponse) and 'conflicts' (handleConflictsResponse) is that
    with unsaved items, the local copy is triumphant on the server, and we check the server copy to see if we should
    create it as a duplicate. This is for the legacy API where it would save what you sent the server no matter its value,
    and the client would decide what to do with the previous server value.
     handleConflictsResponse on the other hand handles where the local copy save was not triumphant on the server.
    Instead the conflict includes the server item. Here we immediately map the server value onto our local value,
    but before that, we give our local value a chance to duplicate itself if it differs from the server value.
    */

  }, {
    key: "handleConflictsResponse",
    value: function () {
      var _ref112 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee102(conflicts) {
        var localValues, _iteratorNormalCompletion46, _didIteratorError46, _iteratorError46, _iterator46, _step46, conflict, serverItemResponse, localItem, frozenContent, itemsNeedingLocalSave, _iteratorNormalCompletion47, _didIteratorError47, _iteratorError47, _iterator47, _step47, _conflict, _localValues$serverIt, itemRef, newItem, tempServerItem, _tempItemWithFrozenValues, frozenContentDiffers, currentContentDiffers, duplicateLocal, duplicateServer, keepLocal, keepServer, IsActiveItemSecondsThreshold, isActivelyBeingEdited, contentExcludingReferencesDiffers, isOnlyReferenceChange, localDuplicate;

        return regeneratorRuntime.wrap(function _callee102$(_context103) {
          while (1) {
            switch (_context103.prev = _context103.next) {
              case 0:
                if (!(!conflicts || conflicts.length == 0)) {
                  _context103.next = 2;
                  break;
                }

                return _context103.abrupt("return");

              case 2:

                if (this.loggingEnabled) {
                  console.log("Handle Conflicted Items:", conflicts);
                }

                // Get local values before doing any processing. This way, if a note change below modifies a tag,
                // and the tag is going to be iterated on in the same loop, then we don't want this change to be compared
                // to the local value.
                localValues = {};
                _iteratorNormalCompletion46 = true;
                _didIteratorError46 = false;
                _iteratorError46 = undefined;
                _context103.prev = 7;
                _iterator46 = conflicts[Symbol.iterator]();

              case 9:
                if (_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done) {
                  _context103.next = 21;
                  break;
                }

                conflict = _step46.value;
                serverItemResponse = conflict.server_item || conflict.unsaved_item;
                localItem = this.modelManager.findItem(serverItemResponse.uuid);

                if (localItem) {
                  _context103.next = 16;
                  break;
                }

                localValues[serverItemResponse.uuid] = {};
                return _context103.abrupt("continue", 18);

              case 16:
                frozenContent = localItem.getContentCopy();

                localValues[serverItemResponse.uuid] = { frozenContent: frozenContent, itemRef: localItem };

              case 18:
                _iteratorNormalCompletion46 = true;
                _context103.next = 9;
                break;

              case 21:
                _context103.next = 27;
                break;

              case 23:
                _context103.prev = 23;
                _context103.t0 = _context103["catch"](7);
                _didIteratorError46 = true;
                _iteratorError46 = _context103.t0;

              case 27:
                _context103.prev = 27;
                _context103.prev = 28;

                if (!_iteratorNormalCompletion46 && _iterator46.return) {
                  _iterator46.return();
                }

              case 30:
                _context103.prev = 30;

                if (!_didIteratorError46) {
                  _context103.next = 33;
                  break;
                }

                throw _iteratorError46;

              case 33:
                return _context103.finish(30);

              case 34:
                return _context103.finish(27);

              case 35:

                // Any item that's newly created here or updated will need to be persisted
                itemsNeedingLocalSave = [];
                _iteratorNormalCompletion47 = true;
                _didIteratorError47 = false;
                _iteratorError47 = undefined;
                _context103.prev = 39;
                _iterator47 = conflicts[Symbol.iterator]();

              case 41:
                if (_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done) {
                  _context103.next = 91;
                  break;
                }

                _conflict = _step47.value;

                // if sync_conflict, we receive conflict.server_item.
                // If uuid_conflict, we receive the value we attempted to save.
                serverItemResponse = _conflict.server_item || _conflict.unsaved_item;
                _context103.t1 = SFJS.itemTransformer;
                _context103.t2 = [serverItemResponse];
                _context103.next = 48;
                return this.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

              case 48:
                _context103.t3 = _context103.sent.keys;
                _context103.next = 51;
                return _context103.t1.decryptMultipleItems.call(_context103.t1, _context103.t2, _context103.t3);

              case 51:
                _localValues$serverIt = localValues[serverItemResponse.uuid], frozenContent = _localValues$serverIt.frozenContent, itemRef = _localValues$serverIt.itemRef;

                // Could be deleted

                if (itemRef) {
                  _context103.next = 54;
                  break;
                }

                return _context103.abrupt("continue", 88);

              case 54:

                // Item ref is always added, since it's value will have changed below, either by mapping, being set to dirty,
                // or being set undirty by the caller but the caller not saving because they're waiting on us.
                itemsNeedingLocalSave.push(itemRef);

                if (!(_conflict.type === "uuid_conflict")) {
                  _context103.next = 62;
                  break;
                }

                _context103.next = 58;
                return this.modelManager.alternateUUIDForItem(itemRef);

              case 58:
                newItem = _context103.sent;

                itemsNeedingLocalSave.push(newItem);
                _context103.next = 88;
                break;

              case 62:
                if (!(_conflict.type === "sync_conflict")) {
                  _context103.next = 86;
                  break;
                }

                _context103.next = 65;
                return this.modelManager.createDuplicateItemFromResponseItem(serverItemResponse);

              case 65:
                tempServerItem = _context103.sent;

                // Convert to an object simply so we can have access to the `isItemContentEqualWith` function.
                _tempItemWithFrozenValues = this.modelManager.duplicateItemWithCustomContent({
                  content: frozenContent, duplicateOf: itemRef
                });
                // if !frozenContentDiffers && currentContentDiffers, it means values have changed as we were looping through conflicts here.

                frozenContentDiffers = !_tempItemWithFrozenValues.isItemContentEqualWith(tempServerItem);
                currentContentDiffers = !itemRef.isItemContentEqualWith(tempServerItem);
                duplicateLocal = false;
                duplicateServer = false;
                keepLocal = false;
                keepServer = false;


                if (serverItemResponse.deleted || itemRef.deleted) {
                  keepServer = true;
                } else if (frozenContentDiffers) {
                  IsActiveItemSecondsThreshold = 20;
                  isActivelyBeingEdited = (new Date() - itemRef.client_updated_at) / 1000 < IsActiveItemSecondsThreshold;

                  if (isActivelyBeingEdited) {
                    keepLocal = true;
                    duplicateServer = true;
                  } else {
                    duplicateLocal = true;
                    keepServer = true;
                  }
                } else if (currentContentDiffers) {
                  contentExcludingReferencesDiffers = !SFItem.AreItemContentsEqual({
                    leftContent: itemRef.content,
                    rightContent: tempServerItem.content,
                    keysToIgnore: itemRef.keysToIgnoreWhenCheckingContentEquality().concat(["references"]),
                    appDataKeysToIgnore: itemRef.appDataKeysToIgnoreWhenCheckingContentEquality()
                  });
                  isOnlyReferenceChange = !contentExcludingReferencesDiffers;

                  if (isOnlyReferenceChange) {
                    keepLocal = true;
                  } else {
                    duplicateLocal = true;
                    keepServer = true;
                  }
                } else {
                  // items are exactly equal
                  keepServer = true;
                }

                if (!duplicateLocal) {
                  _context103.next = 79;
                  break;
                }

                _context103.next = 77;
                return this.modelManager.duplicateItemWithCustomContentAndAddAsConflict({
                  content: frozenContent,
                  duplicateOf: itemRef
                });

              case 77:
                localDuplicate = _context103.sent;

                itemsNeedingLocalSave.push(localDuplicate);

              case 79:

                if (duplicateServer) {
                  this.modelManager.addDuplicatedItemAsConflict({
                    duplicate: tempServerItem,
                    duplicateOf: itemRef
                  });
                  itemsNeedingLocalSave.push(tempServerItem);
                }

                if (!keepServer) {
                  _context103.next = 83;
                  break;
                }

                _context103.next = 83;
                return this.modelManager.mapResponseItemsToLocalModelsOmittingFields([serverItemResponse], null, SFModelManager.MappingSourceRemoteRetrieved);

              case 83:

                if (keepLocal) {
                  itemRef.updated_at = tempServerItem.updated_at;
                  itemRef.setDirty(true);
                }
                _context103.next = 88;
                break;

              case 86:
                console.error("Unsupported conflict type", _conflict.type);
                return _context103.abrupt("continue", 88);

              case 88:
                _iteratorNormalCompletion47 = true;
                _context103.next = 41;
                break;

              case 91:
                _context103.next = 97;
                break;

              case 93:
                _context103.prev = 93;
                _context103.t4 = _context103["catch"](39);
                _didIteratorError47 = true;
                _iteratorError47 = _context103.t4;

              case 97:
                _context103.prev = 97;
                _context103.prev = 98;

                if (!_iteratorNormalCompletion47 && _iterator47.return) {
                  _iterator47.return();
                }

              case 100:
                _context103.prev = 100;

                if (!_didIteratorError47) {
                  _context103.next = 103;
                  break;
                }

                throw _iteratorError47;

              case 103:
                return _context103.finish(100);

              case 104:
                return _context103.finish(97);

              case 105:
                return _context103.abrupt("return", itemsNeedingLocalSave);

              case 106:
              case "end":
                return _context103.stop();
            }
          }
        }, _callee102, this, [[7, 23, 27, 35], [28,, 30, 34], [39, 93, 97, 105], [98,, 100, 104]]);
      }));

      function handleConflictsResponse(_x145) {
        return _ref112.apply(this, arguments);
      }

      return handleConflictsResponse;
    }()

    // Legacy API

  }, {
    key: "deprecated_handleUnsavedItemsResponse",
    value: function () {
      var _ref113 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee103(unsaved) {
        var _iteratorNormalCompletion48, _didIteratorError48, _iteratorError48, _iterator48, _step48, mapping, itemResponse, item, error, dup;

        return regeneratorRuntime.wrap(function _callee103$(_context104) {
          while (1) {
            switch (_context104.prev = _context104.next) {
              case 0:
                if (!(!unsaved || unsaved.length == 0)) {
                  _context104.next = 2;
                  break;
                }

                return _context104.abrupt("return");

              case 2:

                if (this.loggingEnabled) {
                  console.log("Handle Unsaved Items:", unsaved);
                }

                _iteratorNormalCompletion48 = true;
                _didIteratorError48 = false;
                _iteratorError48 = undefined;
                _context104.prev = 6;
                _iterator48 = unsaved[Symbol.iterator]();

              case 8:
                if (_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done) {
                  _context104.next = 35;
                  break;
                }

                mapping = _step48.value;
                itemResponse = mapping.item;
                _context104.t0 = SFJS.itemTransformer;
                _context104.t1 = [itemResponse];
                _context104.next = 15;
                return this.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

              case 15:
                _context104.t2 = _context104.sent.keys;
                _context104.next = 18;
                return _context104.t0.decryptMultipleItems.call(_context104.t0, _context104.t1, _context104.t2);

              case 18:
                item = this.modelManager.findItem(itemResponse.uuid);

                // Could be deleted

                if (item) {
                  _context104.next = 21;
                  break;
                }

                return _context104.abrupt("continue", 32);

              case 21:
                error = mapping.error;

                if (!(error.tag === "uuid_conflict")) {
                  _context104.next = 27;
                  break;
                }

                _context104.next = 25;
                return this.modelManager.alternateUUIDForItem(item);

              case 25:
                _context104.next = 32;
                break;

              case 27:
                if (!(error.tag === "sync_conflict")) {
                  _context104.next = 32;
                  break;
                }

                _context104.next = 30;
                return this.modelManager.createDuplicateItemFromResponseItem(itemResponse);

              case 30:
                dup = _context104.sent;

                if (!itemResponse.deleted && !item.isItemContentEqualWith(dup)) {
                  this.modelManager.addDuplicatedItemAsConflict({ duplicate: dup, duplicateOf: item });
                }

              case 32:
                _iteratorNormalCompletion48 = true;
                _context104.next = 8;
                break;

              case 35:
                _context104.next = 41;
                break;

              case 37:
                _context104.prev = 37;
                _context104.t3 = _context104["catch"](6);
                _didIteratorError48 = true;
                _iteratorError48 = _context104.t3;

              case 41:
                _context104.prev = 41;
                _context104.prev = 42;

                if (!_iteratorNormalCompletion48 && _iterator48.return) {
                  _iterator48.return();
                }

              case 44:
                _context104.prev = 44;

                if (!_didIteratorError48) {
                  _context104.next = 47;
                  break;
                }

                throw _iteratorError48;

              case 47:
                return _context104.finish(44);

              case 48:
                return _context104.finish(41);

              case 49:
              case "end":
                return _context104.stop();
            }
          }
        }, _callee103, this, [[6, 37, 41, 49], [42,, 44, 48]]);
      }));

      function deprecated_handleUnsavedItemsResponse(_x146) {
        return _ref113.apply(this, arguments);
      }

      return deprecated_handleUnsavedItemsResponse;
    }()

    /*
      Executes a sync request with a blank sync token and high download limit. It will download all items,
      but won't do anything with them other than decrypting, creating respective objects, and returning them to caller. (it does not map them nor establish their relationships)
      The use case came primarly for clients who had ignored a certain content_type in sync, but later issued an update
      indicated they actually did want to start handling that content type. In that case, they would need to download all items
      freshly from the server.
    */

  }, {
    key: "stateless_downloadAllItems",
    value: function stateless_downloadAllItems() {
      var _this26 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new Promise(function () {
        var _ref114 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee105(resolve, reject) {
          var params;
          return regeneratorRuntime.wrap(function _callee105$(_context106) {
            while (1) {
              switch (_context106.prev = _context106.next) {
                case 0:
                  params = {
                    limit: options.limit || 500,
                    sync_token: options.syncToken,
                    cursor_token: options.cursorToken,
                    content_type: options.contentType,
                    event: options.event,
                    api: SFHttpManager.getApiVersion()
                  };
                  _context106.prev = 1;
                  _context106.t0 = _this26.httpManager;
                  _context106.next = 5;
                  return _this26.getSyncURL();

                case 5:
                  _context106.t1 = _context106.sent;
                  _context106.t2 = params;

                  _context106.t3 = function () {
                    var _ref115 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee104(response) {
                      var incomingItems, keys;
                      return regeneratorRuntime.wrap(function _callee104$(_context105) {
                        while (1) {
                          switch (_context105.prev = _context105.next) {
                            case 0:
                              if (!options.retrievedItems) {
                                options.retrievedItems = [];
                              }

                              incomingItems = response.retrieved_items;
                              _context105.next = 4;
                              return _this26.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

                            case 4:
                              keys = _context105.sent.keys;
                              _context105.next = 7;
                              return SFJS.itemTransformer.decryptMultipleItems(incomingItems, keys);

                            case 7:

                              options.retrievedItems = options.retrievedItems.concat(incomingItems.map(function (incomingItem) {
                                // Create model classes
                                return _this26.modelManager.createItem(incomingItem);
                              }));
                              options.syncToken = response.sync_token;
                              options.cursorToken = response.cursor_token;

                              if (options.cursorToken) {
                                _this26.stateless_downloadAllItems(options).then(resolve);
                              } else {
                                resolve(options.retrievedItems);
                              }

                            case 11:
                            case "end":
                              return _context105.stop();
                          }
                        }
                      }, _callee104, _this26);
                    }));

                    return function (_x150) {
                      return _ref115.apply(this, arguments);
                    };
                  }();

                  _context106.t4 = function (response, statusCode) {
                    reject(response);
                  };

                  _context106.t0.postAuthenticatedAbsolute.call(_context106.t0, _context106.t1, _context106.t2, _context106.t3, _context106.t4);

                  _context106.next = 16;
                  break;

                case 12:
                  _context106.prev = 12;
                  _context106.t5 = _context106["catch"](1);

                  console.log("Download all items exception caught:", _context106.t5);
                  reject(_context106.t5);

                case 16:
                case "end":
                  return _context106.stop();
              }
            }
          }, _callee105, _this26, [[1, 12]]);
        }));

        return function (_x148, _x149) {
          return _ref114.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "resolveOutOfSync",
    value: function () {
      var _ref116 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee107() {
        var _this27 = this;

        return regeneratorRuntime.wrap(function _callee107$(_context108) {
          while (1) {
            switch (_context108.prev = _context108.next) {
              case 0:
                return _context108.abrupt("return", this.stateless_downloadAllItems({ event: "resolve-out-of-sync" }).then(function () {
                  var _ref117 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee106(downloadedItems) {
                    var itemsToMap, _iteratorNormalCompletion49, _didIteratorError49, _iteratorError49, _iterator49, _step49, downloadedItem, existingItem, contentDoesntMatch;

                    return regeneratorRuntime.wrap(function _callee106$(_context107) {
                      while (1) {
                        switch (_context107.prev = _context107.next) {
                          case 0:
                            itemsToMap = [];
                            _iteratorNormalCompletion49 = true;
                            _didIteratorError49 = false;
                            _iteratorError49 = undefined;
                            _context107.prev = 4;
                            _iterator49 = downloadedItems[Symbol.iterator]();

                          case 6:
                            if (_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done) {
                              _context107.next = 18;
                              break;
                            }

                            downloadedItem = _step49.value;

                            // Note that deleted items will not be sent back by the server.
                            existingItem = _this27.modelManager.findItem(downloadedItem.uuid);

                            if (!existingItem) {
                              _context107.next = 14;
                              break;
                            }

                            // Check if the content differs. If it does, create a new item, and do not map downloadedItem.
                            contentDoesntMatch = !downloadedItem.isItemContentEqualWith(existingItem);

                            if (!contentDoesntMatch) {
                              _context107.next = 14;
                              break;
                            }

                            _context107.next = 14;
                            return _this27.modelManager.duplicateItemAndAddAsConflict(existingItem);

                          case 14:

                            // Map the downloadedItem as authoritive content. If client copy at all differed, we would have created a duplicate of it above and synced it.
                            // This is also neccessary to map the updated_at value from the server
                            itemsToMap.push(downloadedItem);

                          case 15:
                            _iteratorNormalCompletion49 = true;
                            _context107.next = 6;
                            break;

                          case 18:
                            _context107.next = 24;
                            break;

                          case 20:
                            _context107.prev = 20;
                            _context107.t0 = _context107["catch"](4);
                            _didIteratorError49 = true;
                            _iteratorError49 = _context107.t0;

                          case 24:
                            _context107.prev = 24;
                            _context107.prev = 25;

                            if (!_iteratorNormalCompletion49 && _iterator49.return) {
                              _iterator49.return();
                            }

                          case 27:
                            _context107.prev = 27;

                            if (!_didIteratorError49) {
                              _context107.next = 30;
                              break;
                            }

                            throw _iteratorError49;

                          case 30:
                            return _context107.finish(27);

                          case 31:
                            return _context107.finish(24);

                          case 32:
                            _context107.next = 34;
                            return _this27.modelManager.mapResponseItemsToLocalModelsWithOptions({ items: itemsToMap, source: SFModelManager.MappingSourceRemoteRetrieved });

                          case 34:
                            _context107.next = 36;
                            return _this27.writeItemsToLocalStorage(_this27.modelManager.allNondummyItems);

                          case 36:
                            return _context107.abrupt("return", _this27.sync({ performIntegrityCheck: true }));

                          case 37:
                          case "end":
                            return _context107.stop();
                        }
                      }
                    }, _callee106, _this27, [[4, 20, 24, 32], [25,, 27, 31]]);
                  }));

                  return function (_x151) {
                    return _ref117.apply(this, arguments);
                  };
                }()));

              case 1:
              case "end":
                return _context108.stop();
            }
          }
        }, _callee107, this);
      }));

      function resolveOutOfSync() {
        return _ref116.apply(this, arguments);
      }

      return resolveOutOfSync;
    }()
  }, {
    key: "handleSignout",
    value: function () {
      var _ref118 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee108() {
        return regeneratorRuntime.wrap(function _callee108$(_context109) {
          while (1) {
            switch (_context109.prev = _context109.next) {
              case 0:
                this.outOfSync = false;
                this.loadLocalDataPromise = null;
                this.performSyncAgainOnCompletion = false;
                this.syncStatus.syncOpInProgress = false;
                this._queuedCallbacks = [];
                this.syncStatus = {};
                return _context109.abrupt("return", this.clearSyncToken());

              case 7:
              case "end":
                return _context109.stop();
            }
          }
        }, _callee108, this);
      }));

      function handleSignout() {
        return _ref118.apply(this, arguments);
      }

      return handleSignout;
    }()
  }, {
    key: "clearSyncToken",
    value: function () {
      var _ref119 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee109() {
        return regeneratorRuntime.wrap(function _callee109$(_context110) {
          while (1) {
            switch (_context110.prev = _context110.next) {
              case 0:
                this._syncToken = null;
                this._cursorToken = null;
                return _context110.abrupt("return", this.storageManager.removeItem("syncToken"));

              case 3:
              case "end":
                return _context110.stop();
            }
          }
        }, _callee109, this);
      }));

      function clearSyncToken() {
        return _ref119.apply(this, arguments);
      }

      return clearSyncToken;
    }()

    // Only used by unit test

  }, {
    key: "__setLocalDataNotLoaded",
    value: function __setLocalDataNotLoaded() {
      this.loadLocalDataPromise = null;
      this._initialDataLoaded = false;
    }
  }, {
    key: "queuedCallbacks",
    get: function get() {
      if (!this._queuedCallbacks) {
        this._queuedCallbacks = [];
      }
      return this._queuedCallbacks;
    }
  }]);

  return SFSyncManager;
}();

;var dateFormatter;

var SFItem = exports.SFItem = function () {
  function SFItem() {
    var json_obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SFItem);

    this.content = {};
    this.referencingObjects = [];
    this.updateFromJSON(json_obj);

    if (!this.uuid) {
      // on React Native, this method will not exist. UUID gen will be handled manually via async methods.
      if (typeof SFJS !== "undefined" && SFJS.crypto.generateUUIDSync) {
        this.uuid = SFJS.crypto.generateUUIDSync();
      }
    }

    if (_typeof(this.content) === 'object' && !this.content.references) {
      this.content.references = [];
    }
  }

  // On some platforms, syncrounous uuid generation is not available.
  // Those platforms (mobile) must call this function manually.


  _createClass(SFItem, [{
    key: "initUUID",
    value: function () {
      var _ref120 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee110() {
        return regeneratorRuntime.wrap(function _callee110$(_context111) {
          while (1) {
            switch (_context111.prev = _context111.next) {
              case 0:
                if (this.uuid) {
                  _context111.next = 4;
                  break;
                }

                _context111.next = 3;
                return SFJS.crypto.generateUUID();

              case 3:
                this.uuid = _context111.sent;

              case 4:
              case "end":
                return _context111.stop();
            }
          }
        }, _callee110, this);
      }));

      function initUUID() {
        return _ref120.apply(this, arguments);
      }

      return initUUID;
    }()
  }, {
    key: "updateFromJSON",
    value: function updateFromJSON(json) {
      // Don't expect this to ever be the case but we're having a crash with Android and this is the only suspect.
      if (!json) {
        return;
      }

      this.deleted = json.deleted;
      this.uuid = json.uuid;
      this.enc_item_key = json.enc_item_key;
      this.auth_hash = json.auth_hash;
      this.auth_params = json.auth_params;

      // When updating from server response (as opposed to local json response), these keys will be missing.
      // So we only want to update these values if they are explicitly present.
      var clientKeys = ["errorDecrypting", "dirty", "dirtyCount", "dirtiedDate", "dummy"];
      var _iteratorNormalCompletion50 = true;
      var _didIteratorError50 = false;
      var _iteratorError50 = undefined;

      try {
        for (var _iterator50 = clientKeys[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
          var key = _step50.value;

          if (json[key] !== undefined) {
            this[key] = json[key];
          }
        }
      } catch (err) {
        _didIteratorError50 = true;
        _iteratorError50 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion50 && _iterator50.return) {
            _iterator50.return();
          }
        } finally {
          if (_didIteratorError50) {
            throw _iteratorError50;
          }
        }
      }

      if (this.dirtiedDate && typeof this.dirtiedDate === 'string') {
        this.dirtiedDate = new Date(this.dirtiedDate);
      }

      // Check if object has getter for content_type, and if so, skip
      if (!this.content_type) {
        this.content_type = json.content_type;
      }

      // this.content = json.content will copy it by reference rather than value. So we need to do a deep merge after.
      // json.content can still be a string here. We copy it to this.content, then do a deep merge to transfer over all values.

      if (json.errorDecrypting) {
        this.content = json.content;
      } else {
        try {
          var parsedContent = typeof json.content === 'string' ? JSON.parse(json.content) : json.content;
          SFItem.deepMerge(this.contentObject, parsedContent);
        } catch (e) {
          console.log("Error while updating item from json", e);
        }
      }

      // Manually merge top level data instead of wholesale merge
      if (json.created_at) {
        this.created_at = json.created_at;
      }
      // Could be null if we're mapping from an extension bridge, where we remove this as its a private property.
      if (json.updated_at) {
        this.updated_at = json.updated_at;
      }

      if (this.created_at) {
        this.created_at = new Date(this.created_at);
      } else {
        this.created_at = new Date();
      }

      if (this.updated_at) {
        this.updated_at = new Date(this.updated_at);
      } else {
        this.updated_at = new Date(0);
      } // Epoch

      // Allows the getter to be re-invoked
      this._client_updated_at = null;

      if (json.content) {
        this.mapContentToLocalProperties(this.contentObject);
      } else if (json.deleted == true) {
        this.handleDeletedContent();
      }
    }
  }, {
    key: "mapContentToLocalProperties",
    value: function mapContentToLocalProperties(contentObj) {}
  }, {
    key: "createContentJSONFromProperties",
    value: function createContentJSONFromProperties() {
      /*
      NOTE: This function does have side effects and WILL modify our content.
       Subclasses will override structureParams, and add their own custom content and properties to the object returned from structureParams
      These are properties that this superclass will not be aware of, like 'title' or 'text'
       When we call createContentJSONFromProperties, we want to update our own inherit 'content' field with the values returned from structureParams,
      so that our content field is up to date.
       Each subclass will call super.structureParams and merge it with its own custom result object.
      Since our own structureParams gets a real-time copy of our content, it should be safe to merge the aggregate value back into our own content field.
      */
      var content = this.structureParams();

      SFItem.deepMerge(this.contentObject, content);

      // Return the content item copy and not our actual value, as we don't want it to be mutated outside our control.
      return content;
    }
  }, {
    key: "structureParams",
    value: function structureParams() {
      return this.getContentCopy();
    }

    /* Allows the item to handle the case where the item is deleted and the content is null */

  }, {
    key: "handleDeletedContent",
    value: function handleDeletedContent() {
      // Subclasses can override
    }
  }, {
    key: "setDirty",
    value: function setDirty(dirty, updateClientDate) {
      this.dirty = dirty;

      // Allows the syncManager to check if an item has been marked dirty after a sync has been started
      // This prevents it from clearing it as a dirty item after sync completion, if someone else has marked it dirty
      // again after an ongoing sync.
      if (!this.dirtyCount) {
        this.dirtyCount = 0;
      }
      if (dirty) {
        this.dirtyCount++;
      } else {
        this.dirtyCount = 0;
      }

      // Used internally by syncManager to determine if a dirted item needs to be saved offline.
      // You want to set this in both cases, when dirty is true and false. If it's false, we still need
      // to save it to disk as an update.
      this.dirtiedDate = new Date();

      if (dirty && updateClientDate) {
        // Set the client modified date to now if marking the item as dirty
        this.client_updated_at = new Date();
      } else if (!this.hasRawClientUpdatedAtValue()) {
        // if we don't have an explcit raw value, we initialize client_updated_at.
        this.client_updated_at = new Date(this.updated_at);
      }
    }
  }, {
    key: "updateLocalRelationships",
    value: function updateLocalRelationships() {
      // optional override
    }
  }, {
    key: "addItemAsRelationship",
    value: function addItemAsRelationship(item) {
      item.setIsBeingReferencedBy(this);

      if (this.hasRelationshipWithItem(item)) {
        return;
      }

      var references = this.content.references || [];
      references.push({
        uuid: item.uuid,
        content_type: item.content_type
      });
      this.content.references = references;
    }
  }, {
    key: "removeItemAsRelationship",
    value: function removeItemAsRelationship(item) {
      item.setIsNoLongerBeingReferencedBy(this);
      this.removeReferenceWithUuid(item.uuid);
    }

    // When another object has a relationship with us, we push that object into memory here.
    // We use this so that when `this` is deleted, we're able to update the references of those other objects.

  }, {
    key: "setIsBeingReferencedBy",
    value: function setIsBeingReferencedBy(item) {
      if (!_.find(this.referencingObjects, { uuid: item.uuid })) {
        this.referencingObjects.push(item);
      }
    }
  }, {
    key: "setIsNoLongerBeingReferencedBy",
    value: function setIsNoLongerBeingReferencedBy(item) {
      _.remove(this.referencingObjects, { uuid: item.uuid });
      // Legacy two-way relationships should be handled here
      if (this.hasRelationshipWithItem(item)) {
        this.removeReferenceWithUuid(item.uuid);
        // We really shouldn't have the authority to set this item as dirty, but it's the only way to save this change.
        this.setDirty(true);
      }
    }
  }, {
    key: "removeReferenceWithUuid",
    value: function removeReferenceWithUuid(uuid) {
      var references = this.content.references || [];
      references = references.filter(function (r) {
        return r.uuid != uuid;
      });
      this.content.references = references;
    }
  }, {
    key: "hasRelationshipWithItem",
    value: function hasRelationshipWithItem(item) {
      var target = this.content.references.find(function (r) {
        return r.uuid == item.uuid;
      });
      return target != null;
    }
  }, {
    key: "isBeingRemovedLocally",
    value: function isBeingRemovedLocally() {}
  }, {
    key: "didFinishSyncing",
    value: function didFinishSyncing() {}
  }, {
    key: "informReferencesOfUUIDChange",
    value: function informReferencesOfUUIDChange(oldUUID, newUUID) {
      // optional override
    }
  }, {
    key: "potentialItemOfInterestHasChangedItsUUID",
    value: function potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID) {
      // optional override
      var _iteratorNormalCompletion51 = true;
      var _didIteratorError51 = false;
      var _iteratorError51 = undefined;

      try {
        for (var _iterator51 = this.content.references[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
          var reference = _step51.value;

          if (reference.uuid == oldUUID) {
            reference.uuid = newUUID;
            this.setDirty(true);
          }
        }
      } catch (err) {
        _didIteratorError51 = true;
        _iteratorError51 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion51 && _iterator51.return) {
            _iterator51.return();
          }
        } finally {
          if (_didIteratorError51) {
            throw _iteratorError51;
          }
        }
      }
    }
  }, {
    key: "doNotEncrypt",
    value: function doNotEncrypt() {
      return false;
    }

    /*
    App Data
    */

  }, {
    key: "setDomainDataItem",
    value: function setDomainDataItem(key, value, domain) {
      if (!domain) {
        console.error("SFItem.AppDomain needs to be set.");
        return;
      }

      if (this.errorDecrypting) {
        return;
      }

      if (!this.content.appData) {
        this.content.appData = {};
      }

      var data = this.content.appData[domain];
      if (!data) {
        data = {};
      }
      data[key] = value;
      this.content.appData[domain] = data;
    }
  }, {
    key: "getDomainDataItem",
    value: function getDomainDataItem(key, domain) {
      if (!domain) {
        console.error("SFItem.AppDomain needs to be set.");
        return;
      }

      if (this.errorDecrypting) {
        return;
      }

      if (!this.content.appData) {
        this.content.appData = {};
      }

      var data = this.content.appData[domain];
      if (data) {
        return data[key];
      } else {
        return null;
      }
    }
  }, {
    key: "setAppDataItem",
    value: function setAppDataItem(key, value) {
      this.setDomainDataItem(key, value, SFItem.AppDomain);
    }
  }, {
    key: "getAppDataItem",
    value: function getAppDataItem(key) {
      return this.getDomainDataItem(key, SFItem.AppDomain);
    }
  }, {
    key: "hasRawClientUpdatedAtValue",
    value: function hasRawClientUpdatedAtValue() {
      return this.getAppDataItem("client_updated_at") != null;
    }
  }, {
    key: "keysToIgnoreWhenCheckingContentEquality",


    /*
      During sync conflicts, when determing whether to create a duplicate for an item, we can omit keys that have no
      meaningful weight and can be ignored. For example, if one component has active = true and another component has active = false,
      it would be silly to duplicate them, so instead we ignore this.
     */
    value: function keysToIgnoreWhenCheckingContentEquality() {
      return [];
    }

    // Same as above, but keys inside appData[Item.AppDomain]

  }, {
    key: "appDataKeysToIgnoreWhenCheckingContentEquality",
    value: function appDataKeysToIgnoreWhenCheckingContentEquality() {
      return ["client_updated_at"];
    }
  }, {
    key: "getContentCopy",
    value: function getContentCopy() {
      var contentCopy = JSON.parse(JSON.stringify(this.content));
      return contentCopy;
    }
  }, {
    key: "isItemContentEqualWith",
    value: function isItemContentEqualWith(otherItem) {
      return SFItem.AreItemContentsEqual({
        leftContent: this.content,
        rightContent: otherItem.content,
        keysToIgnore: this.keysToIgnoreWhenCheckingContentEquality(),
        appDataKeysToIgnore: this.appDataKeysToIgnoreWhenCheckingContentEquality()
      });
    }
  }, {
    key: "satisfiesPredicate",
    value: function satisfiesPredicate(predicate) {
      /*
      Predicate is an SFPredicate having properties:
      {
        keypath: String,
        operator: String,
        value: object
      }
       */
      return SFPredicate.ItemSatisfiesPredicate(this, predicate);
    }

    /*
    Dates
    */

  }, {
    key: "createdAtString",
    value: function createdAtString() {
      return this.dateToLocalizedString(this.created_at);
    }
  }, {
    key: "updatedAtString",
    value: function updatedAtString() {
      return this.dateToLocalizedString(this.client_updated_at);
    }
  }, {
    key: "updatedAtTimestamp",
    value: function updatedAtTimestamp() {
      return this.updated_at.getTime();
    }
  }, {
    key: "dateToLocalizedString",
    value: function dateToLocalizedString(date) {
      if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
        if (!dateFormatter) {
          var locale = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language;
          dateFormatter = new Intl.DateTimeFormat(locale, {
            year: 'numeric',
            month: 'short',
            day: '2-digit',
            weekday: 'long',
            hour: '2-digit',
            minute: '2-digit'
          });
        }
        return dateFormatter.format(date);
      } else {
        // IE < 11, Safari <= 9.0.
        // In English, this generates the string most similar to
        // the toLocaleDateString() result above.
        return date.toDateString() + ' ' + date.toLocaleTimeString();
      }
    }
  }, {
    key: "contentObject",
    get: function get() {

      if (this.errorDecrypting) {
        return this.content;
      }

      if (!this.content) {
        this.content = {};
        return this.content;
      }

      if (this.content !== null && _typeof(this.content) === 'object') {
        // this is the case when mapping localStorage content, in which case the content is already parsed
        return this.content;
      }

      try {
        var content = JSON.parse(this.content);
        this.content = content;
        return this.content;
      } catch (e) {
        console.log("Error parsing json", e, this);
        this.content = {};
        return this.content;
      }
    }
  }, {
    key: "pinned",
    get: function get() {
      return this.getAppDataItem("pinned");
    }
  }, {
    key: "archived",
    get: function get() {
      return this.getAppDataItem("archived");
    }
  }, {
    key: "locked",
    get: function get() {
      return this.getAppDataItem("locked");
    }

    // May be used by clients to display the human readable type for this item. Should be overriden by subclasses.

  }, {
    key: "displayName",
    get: function get() {
      return "Item";
    }
  }, {
    key: "client_updated_at",
    get: function get() {
      if (!this._client_updated_at) {
        var saved = this.getAppDataItem("client_updated_at");
        if (saved) {
          this._client_updated_at = new Date(saved);
        } else {
          this._client_updated_at = new Date(this.updated_at);
        }
      }
      return this._client_updated_at;
    },
    set: function set(date) {
      this._client_updated_at = date;

      this.setAppDataItem("client_updated_at", date);
    }
  }], [{
    key: "deepMerge",
    value: function deepMerge(a, b) {
      // By default _.merge will not merge a full array with an empty one.
      // We want to replace arrays wholesale
      function mergeCopyArrays(objValue, srcValue) {
        if (_.isArray(objValue)) {
          return srcValue;
        }
      }
      _.mergeWith(a, b, mergeCopyArrays);
      return a;
    }
  }, {
    key: "AreItemContentsEqual",
    value: function AreItemContentsEqual(_ref121) {
      var leftContent = _ref121.leftContent,
          rightContent = _ref121.rightContent,
          keysToIgnore = _ref121.keysToIgnore,
          appDataKeysToIgnore = _ref121.appDataKeysToIgnore;

      var omit = function omit(obj, keys) {
        if (!obj) {
          return obj;
        }
        var _iteratorNormalCompletion52 = true;
        var _didIteratorError52 = false;
        var _iteratorError52 = undefined;

        try {
          for (var _iterator52 = keys[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
            var key = _step52.value;

            delete obj[key];
          }
        } catch (err) {
          _didIteratorError52 = true;
          _iteratorError52 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion52 && _iterator52.return) {
              _iterator52.return();
            }
          } finally {
            if (_didIteratorError52) {
              throw _iteratorError52;
            }
          }
        }

        return obj;
      };

      // Create copies of objects before running omit as not to modify source values directly.
      leftContent = JSON.parse(JSON.stringify(leftContent));
      if (leftContent.appData) {
        omit(leftContent.appData[SFItem.AppDomain], appDataKeysToIgnore);
      }
      leftContent = omit(leftContent, keysToIgnore);

      rightContent = JSON.parse(JSON.stringify(rightContent));
      if (rightContent.appData) {
        omit(rightContent.appData[SFItem.AppDomain], appDataKeysToIgnore);
      }
      rightContent = omit(rightContent, keysToIgnore);

      return JSON.stringify(leftContent) === JSON.stringify(rightContent);
    }
  }]);

  return SFItem;
}();

;
var SFItemParams = exports.SFItemParams = function () {
  function SFItemParams(item, keys, auth_params) {
    _classCallCheck(this, SFItemParams);

    this.item = item;
    this.keys = keys;
    this.auth_params = auth_params;

    if (this.keys && !this.auth_params) {
      throw "SFItemParams.auth_params must be supplied if supplying keys.";
    }

    if (this.auth_params && !this.auth_params.version) {
      throw "SFItemParams.auth_params is missing version";
    }
  }

  _createClass(SFItemParams, [{
    key: "paramsForExportFile",
    value: function () {
      var _ref122 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee111(includeDeleted) {
        var result;
        return regeneratorRuntime.wrap(function _callee111$(_context112) {
          while (1) {
            switch (_context112.prev = _context112.next) {
              case 0:
                this.forExportFile = true;

                if (!includeDeleted) {
                  _context112.next = 5;
                  break;
                }

                return _context112.abrupt("return", this.__params());

              case 5:
                _context112.next = 7;
                return this.__params();

              case 7:
                result = _context112.sent;
                return _context112.abrupt("return", _.omit(result, ["deleted"]));

              case 9:
              case "end":
                return _context112.stop();
            }
          }
        }, _callee111, this);
      }));

      function paramsForExportFile(_x153) {
        return _ref122.apply(this, arguments);
      }

      return paramsForExportFile;
    }()
  }, {
    key: "paramsForExtension",
    value: function () {
      var _ref123 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee112() {
        return regeneratorRuntime.wrap(function _callee112$(_context113) {
          while (1) {
            switch (_context113.prev = _context113.next) {
              case 0:
                return _context113.abrupt("return", this.paramsForExportFile());

              case 1:
              case "end":
                return _context113.stop();
            }
          }
        }, _callee112, this);
      }));

      function paramsForExtension() {
        return _ref123.apply(this, arguments);
      }

      return paramsForExtension;
    }()
  }, {
    key: "paramsForLocalStorage",
    value: function () {
      var _ref124 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee113() {
        return regeneratorRuntime.wrap(function _callee113$(_context114) {
          while (1) {
            switch (_context114.prev = _context114.next) {
              case 0:
                this.additionalFields = ["dirty", "dirtiedDate", "errorDecrypting"];
                this.forExportFile = true;
                return _context114.abrupt("return", this.__params());

              case 3:
              case "end":
                return _context114.stop();
            }
          }
        }, _callee113, this);
      }));

      function paramsForLocalStorage() {
        return _ref124.apply(this, arguments);
      }

      return paramsForLocalStorage;
    }()
  }, {
    key: "paramsForSync",
    value: function () {
      var _ref125 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee114() {
        return regeneratorRuntime.wrap(function _callee114$(_context115) {
          while (1) {
            switch (_context115.prev = _context115.next) {
              case 0:
                return _context115.abrupt("return", this.__params());

              case 1:
              case "end":
                return _context115.stop();
            }
          }
        }, _callee114, this);
      }));

      function paramsForSync() {
        return _ref125.apply(this, arguments);
      }

      return paramsForSync;
    }()
  }, {
    key: "__params",
    value: function () {
      var _ref126 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee115() {
        var params, doNotEncrypt, encryptedParams;
        return regeneratorRuntime.wrap(function _callee115$(_context116) {
          while (1) {
            switch (_context116.prev = _context116.next) {
              case 0:
                params = { uuid: this.item.uuid, content_type: this.item.content_type, deleted: this.item.deleted, created_at: this.item.created_at, updated_at: this.item.updated_at };

                if (this.item.errorDecrypting) {
                  _context116.next = 23;
                  break;
                }

                // Items should always be encrypted for export files. Only respect item.doNotEncrypt for remote sync params.
                doNotEncrypt = this.item.doNotEncrypt() && !this.forExportFile;

                if (!(this.keys && !doNotEncrypt)) {
                  _context116.next = 11;
                  break;
                }

                _context116.next = 6;
                return SFJS.itemTransformer.encryptItem(this.item, this.keys, this.auth_params);

              case 6:
                encryptedParams = _context116.sent;

                _.merge(params, encryptedParams);

                if (this.auth_params.version !== "001") {
                  params.auth_hash = null;
                }
                _context116.next = 21;
                break;

              case 11:
                if (!this.forExportFile) {
                  _context116.next = 15;
                  break;
                }

                _context116.t0 = this.item.createContentJSONFromProperties();
                _context116.next = 19;
                break;

              case 15:
                _context116.next = 17;
                return SFJS.crypto.base64(JSON.stringify(this.item.createContentJSONFromProperties()));

              case 17:
                _context116.t1 = _context116.sent;
                _context116.t0 = "000" + _context116.t1;

              case 19:
                params.content = _context116.t0;

                if (!this.forExportFile) {
                  params.enc_item_key = null;
                  params.auth_hash = null;
                }

              case 21:
                _context116.next = 26;
                break;

              case 23:
                // Error decrypting, keep "content" and related fields as is (and do not try to encrypt, otherwise that would be undefined behavior)
                params.content = this.item.content;
                params.enc_item_key = this.item.enc_item_key;
                params.auth_hash = this.item.auth_hash;

              case 26:

                if (this.additionalFields) {
                  _.merge(params, _.pick(this.item, this.additionalFields));
                }

                return _context116.abrupt("return", params);

              case 28:
              case "end":
                return _context116.stop();
            }
          }
        }, _callee115, this);
      }));

      function __params() {
        return _ref126.apply(this, arguments);
      }

      return __params;
    }()
  }]);

  return SFItemParams;
}();

;
var SFPredicate = exports.SFPredicate = function () {
  function SFPredicate(keypath, operator, value) {
    _classCallCheck(this, SFPredicate);

    this.keypath = keypath;
    this.operator = operator;
    this.value = value;

    // Preprocessing to make predicate evaluation faster.
    // Won't recurse forever, but with arbitrarily large input could get stuck. Hope there are input size limits
    // somewhere else.
    if (SFPredicate.IsRecursiveOperator(this.operator)) {
      this.value = this.value.map(SFPredicate.fromArray);
    }
  }

  _createClass(SFPredicate, null, [{
    key: "fromArray",
    value: function fromArray(array) {
      return new SFPredicate(array[0], array[1], array[2]);
    }
  }, {
    key: "ObjectSatisfiesPredicate",
    value: function ObjectSatisfiesPredicate(object, predicate) {
      // Predicates may not always be created using the official constructor
      // so if it's still an array here, convert to object
      if (Array.isArray(predicate)) {
        predicate = this.fromArray(predicate);
      }

      if (SFPredicate.IsRecursiveOperator(predicate.operator)) {
        if (predicate.operator === "and") {
          var _iteratorNormalCompletion53 = true;
          var _didIteratorError53 = false;
          var _iteratorError53 = undefined;

          try {
            for (var _iterator53 = predicate.value[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
              var subPredicate = _step53.value;

              if (!this.ObjectSatisfiesPredicate(object, subPredicate)) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError53 = true;
            _iteratorError53 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion53 && _iterator53.return) {
                _iterator53.return();
              }
            } finally {
              if (_didIteratorError53) {
                throw _iteratorError53;
              }
            }
          }

          return true;
        }
        if (predicate.operator === "or") {
          var _iteratorNormalCompletion54 = true;
          var _didIteratorError54 = false;
          var _iteratorError54 = undefined;

          try {
            for (var _iterator54 = predicate.value[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {
              var subPredicate = _step54.value;

              if (this.ObjectSatisfiesPredicate(object, subPredicate)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError54 = true;
            _iteratorError54 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion54 && _iterator54.return) {
                _iterator54.return();
              }
            } finally {
              if (_didIteratorError54) {
                throw _iteratorError54;
              }
            }
          }

          return false;
        }
      }

      var predicateValue = predicate.value;
      if (typeof predicateValue == 'string' && predicateValue.includes(".ago")) {
        predicateValue = this.DateFromString(predicateValue);
      }

      var valueAtKeyPath = predicate.keypath.split('.').reduce(function (previous, current) {
        return previous && previous[current];
      }, object);

      var falseyValues = [false, "", null, undefined, NaN];

      // If the value at keyPath is undefined, either because the property is nonexistent or the value is null.
      if (valueAtKeyPath == undefined) {
        if (predicate.operator == "!=") {
          return !falseyValues.includes(predicate.value);
        } else {
          return falseyValues.includes(predicate.value);
        }
      }

      if (predicate.operator == "=") {
        // Use array comparison
        if (Array.isArray(valueAtKeyPath)) {
          return JSON.stringify(valueAtKeyPath) == JSON.stringify(predicateValue);
        } else {
          return valueAtKeyPath == predicateValue;
        }
      } else if (predicate.operator == "!=") {
        // Use array comparison
        if (Array.isArray(valueAtKeyPath)) {
          return JSON.stringify(valueAtKeyPath) != JSON.stringify(predicateValue);
        } else {
          return valueAtKeyPath !== predicateValue;
        }
      } else if (predicate.operator == "<") {
        return valueAtKeyPath < predicateValue;
      } else if (predicate.operator == ">") {
        return valueAtKeyPath > predicateValue;
      } else if (predicate.operator == "<=") {
        return valueAtKeyPath <= predicateValue;
      } else if (predicate.operator == ">=") {
        return valueAtKeyPath >= predicateValue;
      } else if (predicate.operator == "startsWith") {
        return valueAtKeyPath.startsWith(predicateValue);
      } else if (predicate.operator == "in") {
        return predicateValue.indexOf(valueAtKeyPath) != -1;
      } else if (predicate.operator == "includes") {
        return this.resolveIncludesPredicate(valueAtKeyPath, predicateValue);
      } else if (predicate.operator == "matches") {
        var regex = new RegExp(predicateValue);
        return regex.test(valueAtKeyPath);
      }

      return false;
    }
  }, {
    key: "resolveIncludesPredicate",
    value: function resolveIncludesPredicate(valueAtKeyPath, predicateValue) {
      // includes can be a string  or a predicate (in array form)
      if (typeof predicateValue == 'string') {
        // if string, simply check if the valueAtKeyPath includes the predicate value
        return valueAtKeyPath.includes(predicateValue);
      } else {
        // is a predicate array or predicate object
        var innerPredicate;
        if (Array.isArray(predicateValue)) {
          innerPredicate = SFPredicate.fromArray(predicateValue);
        } else {
          innerPredicate = predicateValue;
        }
        var _iteratorNormalCompletion55 = true;
        var _didIteratorError55 = false;
        var _iteratorError55 = undefined;

        try {
          for (var _iterator55 = valueAtKeyPath[Symbol.iterator](), _step55; !(_iteratorNormalCompletion55 = (_step55 = _iterator55.next()).done); _iteratorNormalCompletion55 = true) {
            var obj = _step55.value;

            if (this.ObjectSatisfiesPredicate(obj, innerPredicate)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError55 = true;
          _iteratorError55 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion55 && _iterator55.return) {
              _iterator55.return();
            }
          } finally {
            if (_didIteratorError55) {
              throw _iteratorError55;
            }
          }
        }

        return false;
      }
    }
  }, {
    key: "ItemSatisfiesPredicate",
    value: function ItemSatisfiesPredicate(item, predicate) {
      if (Array.isArray(predicate)) {
        predicate = SFPredicate.fromArray(predicate);
      }
      return this.ObjectSatisfiesPredicate(item, predicate);
    }
  }, {
    key: "ItemSatisfiesPredicates",
    value: function ItemSatisfiesPredicates(item, predicates) {
      var _iteratorNormalCompletion56 = true;
      var _didIteratorError56 = false;
      var _iteratorError56 = undefined;

      try {
        for (var _iterator56 = predicates[Symbol.iterator](), _step56; !(_iteratorNormalCompletion56 = (_step56 = _iterator56.next()).done); _iteratorNormalCompletion56 = true) {
          var predicate = _step56.value;

          if (!this.ItemSatisfiesPredicate(item, predicate)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError56 = true;
        _iteratorError56 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion56 && _iterator56.return) {
            _iterator56.return();
          }
        } finally {
          if (_didIteratorError56) {
            throw _iteratorError56;
          }
        }
      }

      return true;
    }
  }, {
    key: "DateFromString",
    value: function DateFromString(string) {
      // x.days.ago, x.hours.ago
      var comps = string.split(".");
      var unit = comps[1];
      var date = new Date();
      var offset = parseInt(comps[0]);
      if (unit == "days") {
        date.setDate(date.getDate() - offset);
      } else if (unit == "hours") {
        date.setHours(date.getHours() - offset);
      }
      return date;
    }
  }, {
    key: "IsRecursiveOperator",
    value: function IsRecursiveOperator(operator) {
      return ["and", "or"].includes(operator);
    }
  }]);

  return SFPredicate;
}();

;
var SFPrivileges = exports.SFPrivileges = function (_SFItem) {
  _inherits(SFPrivileges, _SFItem);

  _createClass(SFPrivileges, null, [{
    key: "contentType",
    value: function contentType() {
      // It has prefix SN since it was originally imported from SN codebase
      return "SN|Privileges";
    }
  }]);

  function SFPrivileges(json_obj) {
    _classCallCheck(this, SFPrivileges);

    var _this28 = _possibleConstructorReturn(this, (SFPrivileges.__proto__ || Object.getPrototypeOf(SFPrivileges)).call(this, json_obj));

    if (!_this28.content.desktopPrivileges) {
      _this28.content.desktopPrivileges = {};
    }
    return _this28;
  }

  _createClass(SFPrivileges, [{
    key: "setCredentialsForAction",
    value: function setCredentialsForAction(action, credentials) {
      this.content.desktopPrivileges[action] = credentials;
    }
  }, {
    key: "getCredentialsForAction",
    value: function getCredentialsForAction(action) {
      return this.content.desktopPrivileges[action] || [];
    }
  }, {
    key: "toggleCredentialForAction",
    value: function toggleCredentialForAction(action, credential) {
      if (this.isCredentialRequiredForAction(action, credential)) {
        this.removeCredentialForAction(action, credential);
      } else {
        this.addCredentialForAction(action, credential);
      }
    }
  }, {
    key: "removeCredentialForAction",
    value: function removeCredentialForAction(action, credential) {
      _.pull(this.content.desktopPrivileges[action], credential);
    }
  }, {
    key: "addCredentialForAction",
    value: function addCredentialForAction(action, credential) {
      var credentials = this.getCredentialsForAction(action);
      credentials.push(credential);
      this.setCredentialsForAction(action, credentials);
    }
  }, {
    key: "isCredentialRequiredForAction",
    value: function isCredentialRequiredForAction(action, credential) {
      var credentialsRequired = this.getCredentialsForAction(action);
      return credentialsRequired.includes(credential);
    }
  }]);

  return SFPrivileges;
}(SFItem);

; /*
   Important: This is the only object in the session history domain that is persistable.
    A history session contains one main content object:
   the itemUUIDToItemHistoryMapping. This is a dictionary whose keys are item uuids,
   and each value is an SFItemHistory object.
    Each SFItemHistory object contains an array called `entires` which contain `SFItemHistory` entries (or subclasses, if the
   `SFItemHistory.HistoryEntryClassMapping` class property value is set.)
  */

// See default class values at bottom of this file, including `SFHistorySession.LargeItemEntryAmountThreshold`.

var SFHistorySession = exports.SFHistorySession = function (_SFItem2) {
  _inherits(SFHistorySession, _SFItem2);

  function SFHistorySession(json_obj) {
    _classCallCheck(this, SFHistorySession);

    /*
      Our .content params:
      {
        itemUUIDToItemHistoryMapping
      }
     */

    var _this29 = _possibleConstructorReturn(this, (SFHistorySession.__proto__ || Object.getPrototypeOf(SFHistorySession)).call(this, json_obj));

    if (!_this29.content.itemUUIDToItemHistoryMapping) {
      _this29.content.itemUUIDToItemHistoryMapping = {};
    }

    // When initializing from a json_obj, we want to deserialize the item history JSON into SFItemHistory objects.
    var uuids = Object.keys(_this29.content.itemUUIDToItemHistoryMapping);
    uuids.forEach(function (itemUUID) {
      var itemHistory = _this29.content.itemUUIDToItemHistoryMapping[itemUUID];
      _this29.content.itemUUIDToItemHistoryMapping[itemUUID] = new SFItemHistory(itemHistory);
    });
    return _this29;
  }

  _createClass(SFHistorySession, [{
    key: "addEntryForItem",
    value: function addEntryForItem(item) {
      var itemHistory = this.historyForItem(item);
      var entry = itemHistory.addHistoryEntryForItem(item);
      return entry;
    }
  }, {
    key: "historyForItem",
    value: function historyForItem(item) {
      var history = this.content.itemUUIDToItemHistoryMapping[item.uuid];
      if (!history) {
        history = this.content.itemUUIDToItemHistoryMapping[item.uuid] = new SFItemHistory();
      }
      return history;
    }
  }, {
    key: "clearItemHistory",
    value: function clearItemHistory(item) {
      this.historyForItem(item).clear();
    }
  }, {
    key: "clearAllHistory",
    value: function clearAllHistory() {
      this.content.itemUUIDToItemHistoryMapping = {};
    }
  }, {
    key: "optimizeHistoryForItem",
    value: function optimizeHistoryForItem(item) {
      // Clean up if there are too many revisions. Note SFHistorySession.LargeItemEntryAmountThreshold is the amount of revisions which above, call
      // for an optimization. An optimization may not remove entries above this threshold. It will determine what it should keep and what it shouldn't.
      // So, it is possible to have a threshold of 60 but have 600 entries, if the item history deems those worth keeping.
      var itemHistory = this.historyForItem(item);
      if (itemHistory.entries.length > SFHistorySession.LargeItemEntryAmountThreshold) {
        itemHistory.optimize();
      }
    }
  }]);

  return SFHistorySession;
}(SFItem);

// See comment in `this.optimizeHistoryForItem`


SFHistorySession.LargeItemEntryAmountThreshold = 60;
; // See default class values at bottom of this file, including `SFItemHistory.LargeEntryDeltaThreshold`.

var SFItemHistory = exports.SFItemHistory = function () {
  function SFItemHistory() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SFItemHistory);

    if (!this.entries) {
      this.entries = [];
    }

    // Deserialize the entries into entry objects.
    if (params.entries) {
      var _iteratorNormalCompletion57 = true;
      var _didIteratorError57 = false;
      var _iteratorError57 = undefined;

      try {
        for (var _iterator57 = params.entries[Symbol.iterator](), _step57; !(_iteratorNormalCompletion57 = (_step57 = _iterator57.next()).done); _iteratorNormalCompletion57 = true) {
          var entryParams = _step57.value;

          var entry = this.createEntryForItem(entryParams.item);
          entry.setPreviousEntry(this.getLastEntry());
          this.entries.push(entry);
        }
      } catch (err) {
        _didIteratorError57 = true;
        _iteratorError57 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion57 && _iterator57.return) {
            _iterator57.return();
          }
        } finally {
          if (_didIteratorError57) {
            throw _iteratorError57;
          }
        }
      }
    }
  }

  _createClass(SFItemHistory, [{
    key: "createEntryForItem",
    value: function createEntryForItem(item) {
      var historyItemClass = SFItemHistory.HistoryEntryClassMapping && SFItemHistory.HistoryEntryClassMapping[item.content_type];
      if (!historyItemClass) {
        historyItemClass = SFItemHistoryEntry;
      }
      var entry = new historyItemClass(item);
      return entry;
    }
  }, {
    key: "getLastEntry",
    value: function getLastEntry() {
      return this.entries[this.entries.length - 1];
    }
  }, {
    key: "addHistoryEntryForItem",
    value: function addHistoryEntryForItem(item) {
      var prospectiveEntry = this.createEntryForItem(item);

      var previousEntry = this.getLastEntry();
      prospectiveEntry.setPreviousEntry(previousEntry);

      // Don't add first revision if text length is 0, as this means it's a new note.
      // Actually, nevermind. If we do this, the first character added to a new note
      // will be displayed as "1 characters loaded".
      // if(!previousRevision && prospectiveRevision.textCharDiffLength == 0) {
      //   return;
      // }

      // Don't add if text is the same
      if (prospectiveEntry.isSameAsEntry(previousEntry)) {
        return;
      }

      this.entries.push(prospectiveEntry);
      return prospectiveEntry;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.entries.length = 0;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      var _this30 = this;

      var keepEntries = [];

      var isEntrySignificant = function isEntrySignificant(entry) {
        return entry.deltaSize() > SFItemHistory.LargeEntryDeltaThreshold;
      };

      var processEntry = function processEntry(entry, index, keep) {
        // Entries may be processed retrospectively, meaning it can be decided to be deleted, then an upcoming processing can change that.
        if (keep) {
          keepEntries.push(entry);
        } else {
          // Remove if in keep
          var index = keepEntries.indexOf(entry);
          if (index !== -1) {
            keepEntries.splice(index, 1);
          }
        }

        if (keep && isEntrySignificant(entry) && entry.operationVector() == -1) {
          // This is a large negative change. Hang on to the previous entry.
          var previousEntry = _this30.entries[index - 1];
          if (previousEntry) {
            keepEntries.push(previousEntry);
          }
        }
      };

      this.entries.forEach(function (entry, index) {
        if (index == 0 || index == _this30.entries.length - 1) {
          // Keep the first and last
          processEntry(entry, index, true);
        } else {
          var significant = isEntrySignificant(entry);
          processEntry(entry, index, significant);
        }
      });

      this.entries = this.entries.filter(function (entry, index) {
        return keepEntries.indexOf(entry) !== -1;
      });
    }
  }]);

  return SFItemHistory;
}();

// The amount of characters added or removed that constitute a keepable entry after optimization.


SFItemHistory.LargeEntryDeltaThreshold = 15;
;
var SFItemHistoryEntry = exports.SFItemHistoryEntry = function () {
  function SFItemHistoryEntry(item) {
    _classCallCheck(this, SFItemHistoryEntry);

    // Whatever values `item` has will be persisted, so be sure that the values are picked beforehand.
    this.item = SFItem.deepMerge({}, item);

    // We'll assume a `text` content value to diff on. If it doesn't exist, no problem.
    this.defaultContentKeyToDiffOn = "text";

    // Default value
    this.textCharDiffLength = 0;

    if (typeof this.item.updated_at == 'string') {
      this.item.updated_at = new Date(this.item.updated_at);
    }
  }

  _createClass(SFItemHistoryEntry, [{
    key: "setPreviousEntry",
    value: function setPreviousEntry(previousEntry) {
      this.hasPreviousEntry = previousEntry != null;

      // we'll try to compute the delta based on an assumed content property of `text`, if it exists.
      if (this.item.content[this.defaultContentKeyToDiffOn]) {
        if (previousEntry) {
          this.textCharDiffLength = this.item.content[this.defaultContentKeyToDiffOn].length - previousEntry.item.content[this.defaultContentKeyToDiffOn].length;
        } else {
          this.textCharDiffLength = this.item.content[this.defaultContentKeyToDiffOn].length;
        }
      }
    }
  }, {
    key: "operationVector",
    value: function operationVector() {
      // We'll try to use the value of `textCharDiffLength` to help determine this, if it's set
      if (this.textCharDiffLength != undefined) {
        if (!this.hasPreviousEntry || this.textCharDiffLength == 0) {
          return 0;
        } else if (this.textCharDiffLength < 0) {
          return -1;
        } else {
          return 1;
        }
      }

      // Otherwise use a default value of 1
      return 1;
    }
  }, {
    key: "deltaSize",
    value: function deltaSize() {
      // Up to the subclass to determine how large the delta was, i.e number of characters changed.
      // But this general class won't be able to determine which property it should diff on, or even its format.

      // We can return the `textCharDiffLength` if it's set, otherwise, just return 1;
      if (this.textCharDiffLength != undefined) {
        return Math.abs(this.textCharDiffLength);
      }

      // Otherwise return 1 here to constitute a basic positive delta.
      // The value returned should always be positive. override `operationVector` to return the direction of the delta.
      return 1;
    }
  }, {
    key: "isSameAsEntry",
    value: function isSameAsEntry(entry) {
      if (!entry) {
        return false;
      }

      var lhs = new SFItem(this.item);
      var rhs = new SFItem(entry.item);
      return lhs.isItemContentEqualWith(rhs);
    }
  }]);

  return SFItemHistoryEntry;
}();

; /* Abstract class. Instantiate an instance of either SFCryptoJS (uses cryptojs) or SFCryptoWeb (uses web crypto) */

var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

var SFAbstractCrypto = exports.SFAbstractCrypto = function () {
  function SFAbstractCrypto() {
    _classCallCheck(this, SFAbstractCrypto);

    this.DefaultPBKDF2Length = 768;
  }

  /*
  Our WebCrypto implementation only offers PBKDf2, so any other encryption
  and key generation functions must use CryptoJS in this abstract implementation.
  */

  _createClass(SFAbstractCrypto, [{
    key: "generateUUIDSync",
    value: function generateUUIDSync() {
      var crypto = globalScope.crypto || globalScope.msCrypto;
      if (crypto) {
        var buf = new Uint32Array(4);
        crypto.getRandomValues(buf);
        var idx = -1;
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          idx++;
          var r = buf[idx >> 3] >> idx % 8 * 4 & 15;
          var v = c == 'x' ? r : r & 0x3 | 0x8;
          return v.toString(16);
        });
      } else {
        var d = new Date().getTime();
        if (globalScope.performance && typeof globalScope.performance.now === "function") {
          d += performance.now(); //use high-precision timer if available
        }
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = (d + Math.random() * 16) % 16 | 0;
          d = Math.floor(d / 16);
          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
        });
        return uuid;
      }
    }
  }, {
    key: "generateUUID",
    value: function () {
      var _ref127 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee116() {
        return regeneratorRuntime.wrap(function _callee116$(_context117) {
          while (1) {
            switch (_context117.prev = _context117.next) {
              case 0:
                return _context117.abrupt("return", this.generateUUIDSync());

              case 1:
              case "end":
                return _context117.stop();
            }
          }
        }, _callee116, this);
      }));

      function generateUUID() {
        return _ref127.apply(this, arguments);
      }

      return generateUUID;
    }()
  }, {
    key: "decryptText",
    value: function () {
      var _ref128 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee117() {
        var _ref129 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            ciphertextToAuth = _ref129.ciphertextToAuth,
            contentCiphertext = _ref129.contentCiphertext,
            encryptionKey = _ref129.encryptionKey,
            iv = _ref129.iv,
            authHash = _ref129.authHash,
            authKey = _ref129.authKey;

        var requiresAuth = arguments[1];
        var localAuthHash, keyData, ivData, decrypted;
        return regeneratorRuntime.wrap(function _callee117$(_context118) {
          while (1) {
            switch (_context118.prev = _context118.next) {
              case 0:
                if (!(requiresAuth && !authHash)) {
                  _context118.next = 3;
                  break;
                }

                console.error("Auth hash is required.");
                return _context118.abrupt("return");

              case 3:
                if (!authHash) {
                  _context118.next = 10;
                  break;
                }

                _context118.next = 6;
                return this.hmac256(ciphertextToAuth, authKey);

              case 6:
                localAuthHash = _context118.sent;

                if (!(authHash !== localAuthHash)) {
                  _context118.next = 10;
                  break;
                }

                console.error("Auth hash does not match, returning null.");
                return _context118.abrupt("return", null);

              case 10:
                keyData = CryptoJS.enc.Hex.parse(encryptionKey);
                ivData = CryptoJS.enc.Hex.parse(iv || "");
                decrypted = CryptoJS.AES.decrypt(contentCiphertext, keyData, { iv: ivData, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
                return _context118.abrupt("return", decrypted.toString(CryptoJS.enc.Utf8));

              case 14:
              case "end":
                return _context118.stop();
            }
          }
        }, _callee117, this);
      }));

      function decryptText() {
        return _ref128.apply(this, arguments);
      }

      return decryptText;
    }()
  }, {
    key: "encryptText",
    value: function () {
      var _ref130 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee118(text, key, iv) {
        var keyData, ivData, encrypted;
        return regeneratorRuntime.wrap(function _callee118$(_context119) {
          while (1) {
            switch (_context119.prev = _context119.next) {
              case 0:
                keyData = CryptoJS.enc.Hex.parse(key);
                ivData = CryptoJS.enc.Hex.parse(iv || "");
                encrypted = CryptoJS.AES.encrypt(text, keyData, { iv: ivData, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
                return _context119.abrupt("return", encrypted.toString());

              case 4:
              case "end":
                return _context119.stop();
            }
          }
        }, _callee118, this);
      }));

      function encryptText(_x156, _x157, _x158) {
        return _ref130.apply(this, arguments);
      }

      return encryptText;
    }()
  }, {
    key: "generateRandomKey",
    value: function () {
      var _ref131 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee119(bits) {
        return regeneratorRuntime.wrap(function _callee119$(_context120) {
          while (1) {
            switch (_context120.prev = _context120.next) {
              case 0:
                return _context120.abrupt("return", CryptoJS.lib.WordArray.random(bits / 8).toString());

              case 1:
              case "end":
                return _context120.stop();
            }
          }
        }, _callee119, this);
      }));

      function generateRandomKey(_x159) {
        return _ref131.apply(this, arguments);
      }

      return generateRandomKey;
    }()
  }, {
    key: "generateItemEncryptionKey",
    value: function () {
      var _ref132 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee120() {
        var length, cost, salt, passphrase;
        return regeneratorRuntime.wrap(function _callee120$(_context121) {
          while (1) {
            switch (_context121.prev = _context121.next) {
              case 0:
                // Generates a key that will be split in half, each being 256 bits. So total length will need to be 512.
                length = 512;
                cost = 1;
                _context121.next = 4;
                return this.generateRandomKey(length);

              case 4:
                salt = _context121.sent;
                _context121.next = 7;
                return this.generateRandomKey(length);

              case 7:
                passphrase = _context121.sent;
                return _context121.abrupt("return", this.pbkdf2(passphrase, salt, cost, length));

              case 9:
              case "end":
                return _context121.stop();
            }
          }
        }, _callee120, this);
      }));

      function generateItemEncryptionKey() {
        return _ref132.apply(this, arguments);
      }

      return generateItemEncryptionKey;
    }()
  }, {
    key: "firstHalfOfKey",
    value: function () {
      var _ref133 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee121(key) {
        return regeneratorRuntime.wrap(function _callee121$(_context122) {
          while (1) {
            switch (_context122.prev = _context122.next) {
              case 0:
                return _context122.abrupt("return", key.substring(0, key.length / 2));

              case 1:
              case "end":
                return _context122.stop();
            }
          }
        }, _callee121, this);
      }));

      function firstHalfOfKey(_x160) {
        return _ref133.apply(this, arguments);
      }

      return firstHalfOfKey;
    }()
  }, {
    key: "secondHalfOfKey",
    value: function () {
      var _ref134 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee122(key) {
        return regeneratorRuntime.wrap(function _callee122$(_context123) {
          while (1) {
            switch (_context123.prev = _context123.next) {
              case 0:
                return _context123.abrupt("return", key.substring(key.length / 2, key.length));

              case 1:
              case "end":
                return _context123.stop();
            }
          }
        }, _callee122, this);
      }));

      function secondHalfOfKey(_x161) {
        return _ref134.apply(this, arguments);
      }

      return secondHalfOfKey;
    }()
  }, {
    key: "base64",
    value: function () {
      var _ref135 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee123(text) {
        return regeneratorRuntime.wrap(function _callee123$(_context124) {
          while (1) {
            switch (_context124.prev = _context124.next) {
              case 0:
                return _context124.abrupt("return", globalScope.btoa(encodeURIComponent(text).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
                  return String.fromCharCode('0x' + p1);
                })));

              case 1:
              case "end":
                return _context124.stop();
            }
          }
        }, _callee123, this);
      }));

      function base64(_x162) {
        return _ref135.apply(this, arguments);
      }

      return base64;
    }()
  }, {
    key: "base64Decode",
    value: function () {
      var _ref136 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee124(base64String) {
        return regeneratorRuntime.wrap(function _callee124$(_context125) {
          while (1) {
            switch (_context125.prev = _context125.next) {
              case 0:
                return _context125.abrupt("return", globalScope.atob(base64String));

              case 1:
              case "end":
                return _context125.stop();
            }
          }
        }, _callee124, this);
      }));

      function base64Decode(_x163) {
        return _ref136.apply(this, arguments);
      }

      return base64Decode;
    }()
  }, {
    key: "sha256",
    value: function () {
      var _ref137 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee125(text) {
        return regeneratorRuntime.wrap(function _callee125$(_context126) {
          while (1) {
            switch (_context126.prev = _context126.next) {
              case 0:
                return _context126.abrupt("return", CryptoJS.SHA256(text).toString());

              case 1:
              case "end":
                return _context126.stop();
            }
          }
        }, _callee125, this);
      }));

      function sha256(_x164) {
        return _ref137.apply(this, arguments);
      }

      return sha256;
    }()
  }, {
    key: "hmac256",
    value: function () {
      var _ref138 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee126(message, key) {
        var keyData, messageData, result;
        return regeneratorRuntime.wrap(function _callee126$(_context127) {
          while (1) {
            switch (_context127.prev = _context127.next) {
              case 0:
                keyData = CryptoJS.enc.Hex.parse(key);
                messageData = CryptoJS.enc.Utf8.parse(message);
                result = CryptoJS.HmacSHA256(messageData, keyData).toString();
                return _context127.abrupt("return", result);

              case 4:
              case "end":
                return _context127.stop();
            }
          }
        }, _callee126, this);
      }));

      function hmac256(_x165, _x166) {
        return _ref138.apply(this, arguments);
      }

      return hmac256;
    }()
  }, {
    key: "generateSalt",
    value: function () {
      var _ref139 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee127(identifier, version, cost, nonce) {
        var result;
        return regeneratorRuntime.wrap(function _callee127$(_context128) {
          while (1) {
            switch (_context128.prev = _context128.next) {
              case 0:
                _context128.next = 2;
                return this.sha256([identifier, "SF", version, cost, nonce].join(":"));

              case 2:
                result = _context128.sent;
                return _context128.abrupt("return", result);

              case 4:
              case "end":
                return _context128.stop();
            }
          }
        }, _callee127, this);
      }));

      function generateSalt(_x167, _x168, _x169, _x170) {
        return _ref139.apply(this, arguments);
      }

      return generateSalt;
    }()

    /** Generates two deterministic keys based on one input */

  }, {
    key: "generateSymmetricKeyPair",
    value: function () {
      var _ref140 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee128() {
        var _ref141 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            password = _ref141.password,
            pw_salt = _ref141.pw_salt,
            pw_cost = _ref141.pw_cost;

        var output, outputLength, splitLength, firstThird, secondThird, thirdThird;
        return regeneratorRuntime.wrap(function _callee128$(_context129) {
          while (1) {
            switch (_context129.prev = _context129.next) {
              case 0:
                _context129.next = 2;
                return this.pbkdf2(password, pw_salt, pw_cost, this.DefaultPBKDF2Length);

              case 2:
                output = _context129.sent;
                outputLength = output.length;
                splitLength = outputLength / 3;
                firstThird = output.slice(0, splitLength);
                secondThird = output.slice(splitLength, splitLength * 2);
                thirdThird = output.slice(splitLength * 2, splitLength * 3);
                return _context129.abrupt("return", [firstThird, secondThird, thirdThird]);

              case 9:
              case "end":
                return _context129.stop();
            }
          }
        }, _callee128, this);
      }));

      function generateSymmetricKeyPair() {
        return _ref140.apply(this, arguments);
      }

      return generateSymmetricKeyPair;
    }()
  }, {
    key: "computeEncryptionKeysForUser",
    value: function () {
      var _ref142 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee129(password, authParams) {
        var pw_salt;
        return regeneratorRuntime.wrap(function _callee129$(_context130) {
          while (1) {
            switch (_context130.prev = _context130.next) {
              case 0:
                if (!(authParams.version == "003")) {
                  _context130.next = 9;
                  break;
                }

                if (authParams.identifier) {
                  _context130.next = 4;
                  break;
                }

                console.error("authParams is missing identifier.");
                return _context130.abrupt("return");

              case 4:
                _context130.next = 6;
                return this.generateSalt(authParams.identifier, authParams.version, authParams.pw_cost, authParams.pw_nonce);

              case 6:
                pw_salt = _context130.sent;
                _context130.next = 10;
                break;

              case 9:
                // Salt is returned from server
                pw_salt = authParams.pw_salt;

              case 10:
                return _context130.abrupt("return", this.generateSymmetricKeyPair({ password: password, pw_salt: pw_salt, pw_cost: authParams.pw_cost }).then(function (keys) {
                  var userKeys = { pw: keys[0], mk: keys[1], ak: keys[2] };
                  return userKeys;
                }));

              case 11:
              case "end":
                return _context130.stop();
            }
          }
        }, _callee129, this);
      }));

      function computeEncryptionKeysForUser(_x172, _x173) {
        return _ref142.apply(this, arguments);
      }

      return computeEncryptionKeysForUser;
    }()

    // Unlike computeEncryptionKeysForUser, this method always uses the latest SF Version

  }, {
    key: "generateInitialKeysAndAuthParamsForUser",
    value: function () {
      var _ref143 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee130(identifier, password) {
        var version, pw_cost, pw_nonce, pw_salt;
        return regeneratorRuntime.wrap(function _callee130$(_context131) {
          while (1) {
            switch (_context131.prev = _context131.next) {
              case 0:
                version = this.SFJS.version;
                pw_cost = this.SFJS.defaultPasswordGenerationCost;
                _context131.next = 4;
                return this.generateRandomKey(256);

              case 4:
                pw_nonce = _context131.sent;
                _context131.next = 7;
                return this.generateSalt(identifier, version, pw_cost, pw_nonce);

              case 7:
                pw_salt = _context131.sent;
                return _context131.abrupt("return", this.generateSymmetricKeyPair({ password: password, pw_salt: pw_salt, pw_cost: pw_cost }).then(function (keys) {
                  var authParams = { pw_nonce: pw_nonce, pw_cost: pw_cost, identifier: identifier, version: version };
                  var userKeys = { pw: keys[0], mk: keys[1], ak: keys[2] };
                  return { keys: userKeys, authParams: authParams };
                }));

              case 9:
              case "end":
                return _context131.stop();
            }
          }
        }, _callee130, this);
      }));

      function generateInitialKeysAndAuthParamsForUser(_x174, _x175) {
        return _ref143.apply(this, arguments);
      }

      return generateInitialKeysAndAuthParamsForUser;
    }()
  }]);

  return SFAbstractCrypto;
}();

;
var SFCryptoJS = exports.SFCryptoJS = function (_SFAbstractCrypto) {
  _inherits(SFCryptoJS, _SFAbstractCrypto);

  function SFCryptoJS() {
    _classCallCheck(this, SFCryptoJS);

    return _possibleConstructorReturn(this, (SFCryptoJS.__proto__ || Object.getPrototypeOf(SFCryptoJS)).apply(this, arguments));
  }

  _createClass(SFCryptoJS, [{
    key: "pbkdf2",
    value: function () {
      var _ref144 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee131(password, pw_salt, pw_cost, length) {
        var params;
        return regeneratorRuntime.wrap(function _callee131$(_context132) {
          while (1) {
            switch (_context132.prev = _context132.next) {
              case 0:
                params = {
                  keySize: length / 32,
                  hasher: CryptoJS.algo.SHA512,
                  iterations: pw_cost
                };
                return _context132.abrupt("return", CryptoJS.PBKDF2(password, pw_salt, params).toString());

              case 2:
              case "end":
                return _context132.stop();
            }
          }
        }, _callee131, this);
      }));

      function pbkdf2(_x176, _x177, _x178, _x179) {
        return _ref144.apply(this, arguments);
      }

      return pbkdf2;
    }()
  }]);

  return SFCryptoJS;
}(SFAbstractCrypto);

;var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

var subtleCrypto = globalScope.crypto ? globalScope.crypto.subtle : null;

var SFCryptoWeb = exports.SFCryptoWeb = function (_SFAbstractCrypto2) {
  _inherits(SFCryptoWeb, _SFAbstractCrypto2);

  function SFCryptoWeb() {
    _classCallCheck(this, SFCryptoWeb);

    return _possibleConstructorReturn(this, (SFCryptoWeb.__proto__ || Object.getPrototypeOf(SFCryptoWeb)).apply(this, arguments));
  }

  _createClass(SFCryptoWeb, [{
    key: "pbkdf2",


    /**
    Public
    */

    value: function () {
      var _ref145 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee132(password, pw_salt, pw_cost, length) {
        var key;
        return regeneratorRuntime.wrap(function _callee132$(_context133) {
          while (1) {
            switch (_context133.prev = _context133.next) {
              case 0:
                _context133.next = 2;
                return this.webCryptoImportKey(password, "PBKDF2", ["deriveBits"]);

              case 2:
                key = _context133.sent;

                if (key) {
                  _context133.next = 6;
                  break;
                }

                console.log("Key is null, unable to continue");
                return _context133.abrupt("return", null);

              case 6:
                return _context133.abrupt("return", this.webCryptoDeriveBits(key, pw_salt, pw_cost, length));

              case 7:
              case "end":
                return _context133.stop();
            }
          }
        }, _callee132, this);
      }));

      function pbkdf2(_x180, _x181, _x182, _x183) {
        return _ref145.apply(this, arguments);
      }

      return pbkdf2;
    }()
  }, {
    key: "generateRandomKey",
    value: function () {
      var _ref146 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee134(bits) {
        var _this33 = this;

        var extractable;
        return regeneratorRuntime.wrap(function _callee134$(_context135) {
          while (1) {
            switch (_context135.prev = _context135.next) {
              case 0:
                extractable = true;
                return _context135.abrupt("return", subtleCrypto.generateKey({ name: "AES-CBC", length: bits }, extractable, ["encrypt", "decrypt"]).then(function (keyObject) {
                  return subtleCrypto.exportKey("raw", keyObject).then(function () {
                    var _ref147 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee133(keyData) {
                      var key;
                      return regeneratorRuntime.wrap(function _callee133$(_context134) {
                        while (1) {
                          switch (_context134.prev = _context134.next) {
                            case 0:
                              _context134.next = 2;
                              return _this33.arrayBufferToHexString(new Uint8Array(keyData));

                            case 2:
                              key = _context134.sent;
                              return _context134.abrupt("return", key);

                            case 4:
                            case "end":
                              return _context134.stop();
                          }
                        }
                      }, _callee133, _this33);
                    }));

                    return function (_x185) {
                      return _ref147.apply(this, arguments);
                    };
                  }()).catch(function (err) {
                    console.error("Error exporting key", err);
                  });
                }).catch(function (err) {
                  console.error("Error generating key", err);
                }));

              case 2:
              case "end":
                return _context135.stop();
            }
          }
        }, _callee134, this);
      }));

      function generateRandomKey(_x184) {
        return _ref146.apply(this, arguments);
      }

      return generateRandomKey;
    }()
  }, {
    key: "generateItemEncryptionKey",
    value: function () {
      var _ref148 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee135() {
        var length;
        return regeneratorRuntime.wrap(function _callee135$(_context136) {
          while (1) {
            switch (_context136.prev = _context136.next) {
              case 0:
                // Generates a key that will be split in half, each being 256 bits. So total length will need to be 512.
                length = 256;
                return _context136.abrupt("return", Promise.all([this.generateRandomKey(length), this.generateRandomKey(length)]).then(function (values) {
                  return values.join("");
                }));

              case 2:
              case "end":
                return _context136.stop();
            }
          }
        }, _callee135, this);
      }));

      function generateItemEncryptionKey() {
        return _ref148.apply(this, arguments);
      }

      return generateItemEncryptionKey;
    }()

    /* This is a functioning implementation of WebCrypto's encrypt, however, in basic testing, CrpytoJS performs about 30-40% faster, surprisingly. */

  }, {
    key: "encryptText",
    value: function () {
      var _ref149 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee137(text, key, iv) {
        var _this34 = this;

        var ivData, alg, keyBuffer, keyData, textData;
        return regeneratorRuntime.wrap(function _callee137$(_context138) {
          while (1) {
            switch (_context138.prev = _context138.next) {
              case 0:
                if (!iv) {
                  _context138.next = 6;
                  break;
                }

                _context138.next = 3;
                return this.hexStringToArrayBuffer(iv);

              case 3:
                _context138.t0 = _context138.sent;
                _context138.next = 7;
                break;

              case 6:
                _context138.t0 = new ArrayBuffer(16);

              case 7:
                ivData = _context138.t0;
                alg = { name: 'AES-CBC', iv: ivData };
                _context138.next = 11;
                return this.hexStringToArrayBuffer(key);

              case 11:
                keyBuffer = _context138.sent;
                _context138.next = 14;
                return this.webCryptoImportKey(keyBuffer, alg.name, ["encrypt"]);

              case 14:
                keyData = _context138.sent;
                _context138.next = 17;
                return this.stringToArrayBuffer(text);

              case 17:
                textData = _context138.sent;
                return _context138.abrupt("return", crypto.subtle.encrypt(alg, keyData, textData).then(function () {
                  var _ref150 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee136(result) {
                    var cipher;
                    return regeneratorRuntime.wrap(function _callee136$(_context137) {
                      while (1) {
                        switch (_context137.prev = _context137.next) {
                          case 0:
                            _context137.next = 2;
                            return _this34.arrayBufferToBase64(result);

                          case 2:
                            cipher = _context137.sent;
                            return _context137.abrupt("return", cipher);

                          case 4:
                          case "end":
                            return _context137.stop();
                        }
                      }
                    }, _callee136, _this34);
                  }));

                  return function (_x189) {
                    return _ref150.apply(this, arguments);
                  };
                }()));

              case 19:
              case "end":
                return _context138.stop();
            }
          }
        }, _callee137, this);
      }));

      function encryptText(_x186, _x187, _x188) {
        return _ref149.apply(this, arguments);
      }

      return encryptText;
    }()
  }, {
    key: "decryptText",
    value: function () {
      var _ref151 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee139() {
        var _this35 = this;

        var _ref152 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            ciphertextToAuth = _ref152.ciphertextToAuth,
            contentCiphertext = _ref152.contentCiphertext,
            encryptionKey = _ref152.encryptionKey,
            iv = _ref152.iv,
            authHash = _ref152.authHash,
            authKey = _ref152.authKey;

        var requiresAuth = arguments[1];
        var localAuthHash, ivData, alg, keyBuffer, keyData, textData;
        return regeneratorRuntime.wrap(function _callee139$(_context140) {
          while (1) {
            switch (_context140.prev = _context140.next) {
              case 0:
                if (!(requiresAuth && !authHash)) {
                  _context140.next = 3;
                  break;
                }

                console.error("Auth hash is required.");
                return _context140.abrupt("return");

              case 3:
                if (!authHash) {
                  _context140.next = 10;
                  break;
                }

                _context140.next = 6;
                return this.hmac256(ciphertextToAuth, authKey);

              case 6:
                localAuthHash = _context140.sent;

                if (!(authHash !== localAuthHash)) {
                  _context140.next = 10;
                  break;
                }

                console.error("Auth hash does not match, returning null. " + authHash + " != " + localAuthHash);
                return _context140.abrupt("return", null);

              case 10:
                if (!iv) {
                  _context140.next = 16;
                  break;
                }

                _context140.next = 13;
                return this.hexStringToArrayBuffer(iv);

              case 13:
                _context140.t0 = _context140.sent;
                _context140.next = 17;
                break;

              case 16:
                _context140.t0 = new ArrayBuffer(16);

              case 17:
                ivData = _context140.t0;
                alg = { name: 'AES-CBC', iv: ivData };
                _context140.next = 21;
                return this.hexStringToArrayBuffer(encryptionKey);

              case 21:
                keyBuffer = _context140.sent;
                _context140.next = 24;
                return this.webCryptoImportKey(keyBuffer, alg.name, ["decrypt"]);

              case 24:
                keyData = _context140.sent;
                _context140.next = 27;
                return this.base64ToArrayBuffer(contentCiphertext);

              case 27:
                textData = _context140.sent;
                return _context140.abrupt("return", crypto.subtle.decrypt(alg, keyData, textData).then(function () {
                  var _ref153 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee138(result) {
                    var decoded;
                    return regeneratorRuntime.wrap(function _callee138$(_context139) {
                      while (1) {
                        switch (_context139.prev = _context139.next) {
                          case 0:
                            _context139.next = 2;
                            return _this35.arrayBufferToString(result);

                          case 2:
                            decoded = _context139.sent;
                            return _context139.abrupt("return", decoded);

                          case 4:
                          case "end":
                            return _context139.stop();
                        }
                      }
                    }, _callee138, _this35);
                  }));

                  return function (_x191) {
                    return _ref153.apply(this, arguments);
                  };
                }()).catch(function (error) {
                  console.error("Error decrypting:", error);
                }));

              case 29:
              case "end":
                return _context140.stop();
            }
          }
        }, _callee139, this);
      }));

      function decryptText() {
        return _ref151.apply(this, arguments);
      }

      return decryptText;
    }()

    /**
    Internal
    */

  }, {
    key: "webCryptoImportKey",
    value: function () {
      var _ref154 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee140(input, alg, actions, hash) {
        var text;
        return regeneratorRuntime.wrap(function _callee140$(_context141) {
          while (1) {
            switch (_context141.prev = _context141.next) {
              case 0:
                if (!(typeof input === "string")) {
                  _context141.next = 6;
                  break;
                }

                _context141.next = 3;
                return this.stringToArrayBuffer(input);

              case 3:
                _context141.t0 = _context141.sent;
                _context141.next = 7;
                break;

              case 6:
                _context141.t0 = input;

              case 7:
                text = _context141.t0;
                return _context141.abrupt("return", subtleCrypto.importKey("raw", text, { name: alg, hash: hash }, false, actions).then(function (key) {
                  return key;
                }).catch(function (err) {
                  console.error(err);
                  return null;
                }));

              case 9:
              case "end":
                return _context141.stop();
            }
          }
        }, _callee140, this);
      }));

      function webCryptoImportKey(_x192, _x193, _x194, _x195) {
        return _ref154.apply(this, arguments);
      }

      return webCryptoImportKey;
    }()
    //

  }, {
    key: "webCryptoDeriveBits",
    value: function () {
      var _ref155 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee142(key, pw_salt, pw_cost, length) {
        var _this36 = this;

        var params;
        return regeneratorRuntime.wrap(function _callee142$(_context143) {
          while (1) {
            switch (_context143.prev = _context143.next) {
              case 0:
                _context143.next = 2;
                return this.stringToArrayBuffer(pw_salt);

              case 2:
                _context143.t0 = _context143.sent;
                _context143.t1 = pw_cost;
                _context143.t2 = { name: "SHA-512" };
                params = {
                  "name": "PBKDF2",
                  salt: _context143.t0,
                  iterations: _context143.t1,
                  hash: _context143.t2
                };
                return _context143.abrupt("return", subtleCrypto.deriveBits(params, key, length).then(function () {
                  var _ref156 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee141(bits) {
                    var key;
                    return regeneratorRuntime.wrap(function _callee141$(_context142) {
                      while (1) {
                        switch (_context142.prev = _context142.next) {
                          case 0:
                            _context142.next = 2;
                            return _this36.arrayBufferToHexString(new Uint8Array(bits));

                          case 2:
                            key = _context142.sent;
                            return _context142.abrupt("return", key);

                          case 4:
                          case "end":
                            return _context142.stop();
                        }
                      }
                    }, _callee141, _this36);
                  }));

                  return function (_x200) {
                    return _ref156.apply(this, arguments);
                  };
                }()).catch(function (err) {
                  console.error(err);
                  return null;
                }));

              case 7:
              case "end":
                return _context143.stop();
            }
          }
        }, _callee142, this);
      }));

      function webCryptoDeriveBits(_x196, _x197, _x198, _x199) {
        return _ref155.apply(this, arguments);
      }

      return webCryptoDeriveBits;
    }()
  }, {
    key: "stringToArrayBuffer",
    value: function () {
      var _ref157 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee143(string) {
        return regeneratorRuntime.wrap(function _callee143$(_context144) {
          while (1) {
            switch (_context144.prev = _context144.next) {
              case 0:
                return _context144.abrupt("return", new Promise(function (resolve, reject) {
                  var blob = new Blob([string]);
                  var f = new FileReader();
                  f.onload = function (e) {
                    resolve(e.target.result);
                  };
                  f.readAsArrayBuffer(blob);
                }));

              case 1:
              case "end":
                return _context144.stop();
            }
          }
        }, _callee143, this);
      }));

      function stringToArrayBuffer(_x201) {
        return _ref157.apply(this, arguments);
      }

      return stringToArrayBuffer;
    }()
  }, {
    key: "arrayBufferToString",
    value: function () {
      var _ref158 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee144(arrayBuffer) {
        return regeneratorRuntime.wrap(function _callee144$(_context145) {
          while (1) {
            switch (_context145.prev = _context145.next) {
              case 0:
                return _context145.abrupt("return", new Promise(function (resolve, reject) {
                  var blob = new Blob([arrayBuffer]);
                  var f = new FileReader();
                  f.onload = function (e) {
                    resolve(e.target.result);
                  };
                  f.readAsText(blob);
                }));

              case 1:
              case "end":
                return _context145.stop();
            }
          }
        }, _callee144, this);
      }));

      function arrayBufferToString(_x202) {
        return _ref158.apply(this, arguments);
      }

      return arrayBufferToString;
    }()
  }, {
    key: "arrayBufferToHexString",
    value: function () {
      var _ref159 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee145(arrayBuffer) {
        var byteArray, hexString, nextHexByte, i;
        return regeneratorRuntime.wrap(function _callee145$(_context146) {
          while (1) {
            switch (_context146.prev = _context146.next) {
              case 0:
                byteArray = new Uint8Array(arrayBuffer);
                hexString = "";


                for (i = 0; i < byteArray.byteLength; i++) {
                  nextHexByte = byteArray[i].toString(16);
                  if (nextHexByte.length < 2) {
                    nextHexByte = "0" + nextHexByte;
                  }
                  hexString += nextHexByte;
                }
                return _context146.abrupt("return", hexString);

              case 4:
              case "end":
                return _context146.stop();
            }
          }
        }, _callee145, this);
      }));

      function arrayBufferToHexString(_x203) {
        return _ref159.apply(this, arguments);
      }

      return arrayBufferToHexString;
    }()
  }, {
    key: "hexStringToArrayBuffer",
    value: function () {
      var _ref160 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee146(hex) {
        var bytes, c;
        return regeneratorRuntime.wrap(function _callee146$(_context147) {
          while (1) {
            switch (_context147.prev = _context147.next) {
              case 0:
                for (bytes = [], c = 0; c < hex.length; c += 2) {
                  bytes.push(parseInt(hex.substr(c, 2), 16));
                }return _context147.abrupt("return", new Uint8Array(bytes));

              case 2:
              case "end":
                return _context147.stop();
            }
          }
        }, _callee146, this);
      }));

      function hexStringToArrayBuffer(_x204) {
        return _ref160.apply(this, arguments);
      }

      return hexStringToArrayBuffer;
    }()
  }, {
    key: "base64ToArrayBuffer",
    value: function () {
      var _ref161 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee147(base64) {
        var binary_string, len, bytes, i;
        return regeneratorRuntime.wrap(function _callee147$(_context148) {
          while (1) {
            switch (_context148.prev = _context148.next) {
              case 0:
                _context148.next = 2;
                return this.base64Decode(base64);

              case 2:
                binary_string = _context148.sent;
                len = binary_string.length;
                bytes = new Uint8Array(len);

                for (i = 0; i < len; i++) {
                  bytes[i] = binary_string.charCodeAt(i);
                }
                return _context148.abrupt("return", bytes.buffer);

              case 7:
              case "end":
                return _context148.stop();
            }
          }
        }, _callee147, this);
      }));

      function base64ToArrayBuffer(_x205) {
        return _ref161.apply(this, arguments);
      }

      return base64ToArrayBuffer;
    }()
  }, {
    key: "arrayBufferToBase64",
    value: function () {
      var _ref162 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee148(buffer) {
        return regeneratorRuntime.wrap(function _callee148$(_context149) {
          while (1) {
            switch (_context149.prev = _context149.next) {
              case 0:
                return _context149.abrupt("return", new Promise(function (resolve, reject) {
                  var blob = new Blob([buffer], { type: 'application/octet-binary' });
                  var reader = new FileReader();
                  reader.onload = function (evt) {
                    var dataurl = evt.target.result;
                    resolve(dataurl.substr(dataurl.indexOf(',') + 1));
                  };
                  reader.readAsDataURL(blob);
                }));

              case 1:
              case "end":
                return _context149.stop();
            }
          }
        }, _callee148, this);
      }));

      function arrayBufferToBase64(_x206) {
        return _ref162.apply(this, arguments);
      }

      return arrayBufferToBase64;
    }()
  }, {
    key: "hmac256",
    value: function () {
      var _ref163 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee150(message, key) {
        var _this37 = this;

        var keyHexData, keyData, messageData;
        return regeneratorRuntime.wrap(function _callee150$(_context151) {
          while (1) {
            switch (_context151.prev = _context151.next) {
              case 0:
                _context151.next = 2;
                return this.hexStringToArrayBuffer(key);

              case 2:
                keyHexData = _context151.sent;
                _context151.next = 5;
                return this.webCryptoImportKey(keyHexData, "HMAC", ["sign"], { name: "SHA-256" });

              case 5:
                keyData = _context151.sent;
                _context151.next = 8;
                return this.stringToArrayBuffer(message);

              case 8:
                messageData = _context151.sent;
                return _context151.abrupt("return", crypto.subtle.sign({ name: "HMAC" }, keyData, messageData).then(function () {
                  var _ref164 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee149(signature) {
                    var hash;
                    return regeneratorRuntime.wrap(function _callee149$(_context150) {
                      while (1) {
                        switch (_context150.prev = _context150.next) {
                          case 0:
                            _context150.next = 2;
                            return _this37.arrayBufferToHexString(signature);

                          case 2:
                            hash = _context150.sent;
                            return _context150.abrupt("return", hash);

                          case 4:
                          case "end":
                            return _context150.stop();
                        }
                      }
                    }, _callee149, _this37);
                  }));

                  return function (_x209) {
                    return _ref164.apply(this, arguments);
                  };
                }()).catch(function (err) {
                  console.error("Error computing hmac", err);
                }));

              case 10:
              case "end":
                return _context151.stop();
            }
          }
        }, _callee150, this);
      }));

      function hmac256(_x207, _x208) {
        return _ref163.apply(this, arguments);
      }

      return hmac256;
    }()
  }]);

  return SFCryptoWeb;
}(SFAbstractCrypto);

;
var SFItemTransformer = exports.SFItemTransformer = function () {
  function SFItemTransformer(crypto) {
    _classCallCheck(this, SFItemTransformer);

    this.crypto = crypto;
  }

  _createClass(SFItemTransformer, [{
    key: "_private_encryptString",
    value: function () {
      var _ref165 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee151(string, encryptionKey, authKey, uuid, auth_params) {
        var fullCiphertext, contentCiphertext, iv, ciphertextToAuth, authHash, authParamsString;
        return regeneratorRuntime.wrap(function _callee151$(_context152) {
          while (1) {
            switch (_context152.prev = _context152.next) {
              case 0:
                if (!(auth_params.version === "001")) {
                  _context152.next = 7;
                  break;
                }

                _context152.next = 3;
                return this.crypto.encryptText(string, encryptionKey, null);

              case 3:
                contentCiphertext = _context152.sent;

                fullCiphertext = auth_params.version + contentCiphertext;
                _context152.next = 21;
                break;

              case 7:
                _context152.next = 9;
                return this.crypto.generateRandomKey(128);

              case 9:
                iv = _context152.sent;
                _context152.next = 12;
                return this.crypto.encryptText(string, encryptionKey, iv);

              case 12:
                contentCiphertext = _context152.sent;
                ciphertextToAuth = [auth_params.version, uuid, iv, contentCiphertext].join(":");
                _context152.next = 16;
                return this.crypto.hmac256(ciphertextToAuth, authKey);

              case 16:
                authHash = _context152.sent;
                _context152.next = 19;
                return this.crypto.base64(JSON.stringify(auth_params));

              case 19:
                authParamsString = _context152.sent;

                fullCiphertext = [auth_params.version, authHash, uuid, iv, contentCiphertext, authParamsString].join(":");

              case 21:
                return _context152.abrupt("return", fullCiphertext);

              case 22:
              case "end":
                return _context152.stop();
            }
          }
        }, _callee151, this);
      }));

      function _private_encryptString(_x210, _x211, _x212, _x213, _x214) {
        return _ref165.apply(this, arguments);
      }

      return _private_encryptString;
    }()
  }, {
    key: "encryptItem",
    value: function () {
      var _ref166 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee152(item, keys, auth_params) {
        var params, item_key, ek, ak, ciphertext, authHash;
        return regeneratorRuntime.wrap(function _callee152$(_context153) {
          while (1) {
            switch (_context153.prev = _context153.next) {
              case 0:
                params = {};
                // encrypt item key

                _context153.next = 3;
                return this.crypto.generateItemEncryptionKey();

              case 3:
                item_key = _context153.sent;

                if (!(auth_params.version === "001")) {
                  _context153.next = 10;
                  break;
                }

                _context153.next = 7;
                return this.crypto.encryptText(item_key, keys.mk, null);

              case 7:
                params.enc_item_key = _context153.sent;
                _context153.next = 13;
                break;

              case 10:
                _context153.next = 12;
                return this._private_encryptString(item_key, keys.mk, keys.ak, item.uuid, auth_params);

              case 12:
                params.enc_item_key = _context153.sent;

              case 13:
                _context153.next = 15;
                return this.crypto.firstHalfOfKey(item_key);

              case 15:
                ek = _context153.sent;
                _context153.next = 18;
                return this.crypto.secondHalfOfKey(item_key);

              case 18:
                ak = _context153.sent;
                _context153.next = 21;
                return this._private_encryptString(JSON.stringify(item.createContentJSONFromProperties()), ek, ak, item.uuid, auth_params);

              case 21:
                ciphertext = _context153.sent;

                if (!(auth_params.version === "001")) {
                  _context153.next = 27;
                  break;
                }

                _context153.next = 25;
                return this.crypto.hmac256(ciphertext, ak);

              case 25:
                authHash = _context153.sent;

                params.auth_hash = authHash;

              case 27:

                params.content = ciphertext;
                return _context153.abrupt("return", params);

              case 29:
              case "end":
                return _context153.stop();
            }
          }
        }, _callee152, this);
      }));

      function encryptItem(_x215, _x216, _x217) {
        return _ref166.apply(this, arguments);
      }

      return encryptItem;
    }()
  }, {
    key: "encryptionComponentsFromString",
    value: function encryptionComponentsFromString(string, encryptionKey, authKey) {
      var encryptionVersion = string.substring(0, 3);
      if (encryptionVersion === "001") {
        return {
          contentCiphertext: string.substring(3, string.length),
          encryptionVersion: encryptionVersion,
          ciphertextToAuth: string,
          iv: null,
          authHash: null,
          encryptionKey: encryptionKey,
          authKey: authKey
        };
      } else {
        var components = string.split(":");
        return {
          encryptionVersion: components[0],
          authHash: components[1],
          uuid: components[2],
          iv: components[3],
          contentCiphertext: components[4],
          authParams: components[5],
          ciphertextToAuth: [components[0], components[2], components[3], components[4]].join(":"),
          encryptionKey: encryptionKey,
          authKey: authKey
        };
      }
    }
  }, {
    key: "decryptItem",
    value: function () {
      var _ref167 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee153(item, keys) {
        var encryptedItemKey, requiresAuth, keyParams, item_key, ek, ak, itemParams, content;
        return regeneratorRuntime.wrap(function _callee153$(_context154) {
          while (1) {
            switch (_context154.prev = _context154.next) {
              case 0:
                if (!(typeof item.content != "string")) {
                  _context154.next = 2;
                  break;
                }

                return _context154.abrupt("return");

              case 2:
                if (!item.content.startsWith("000")) {
                  _context154.next = 14;
                  break;
                }

                _context154.prev = 3;
                _context154.t0 = JSON;
                _context154.next = 7;
                return this.crypto.base64Decode(item.content.substring(3, item.content.length));

              case 7:
                _context154.t1 = _context154.sent;
                item.content = _context154.t0.parse.call(_context154.t0, _context154.t1);
                _context154.next = 13;
                break;

              case 11:
                _context154.prev = 11;
                _context154.t2 = _context154["catch"](3);

              case 13:
                return _context154.abrupt("return");

              case 14:
                if (item.enc_item_key) {
                  _context154.next = 17;
                  break;
                }

                // This needs to be here to continue, return otherwise
                console.log("Missing item encryption key, skipping decryption.");
                return _context154.abrupt("return");

              case 17:

                // decrypt encrypted key
                encryptedItemKey = item.enc_item_key;
                requiresAuth = true;

                if (!encryptedItemKey.startsWith("002") && !encryptedItemKey.startsWith("003")) {
                  // legacy encryption type, has no prefix
                  encryptedItemKey = "001" + encryptedItemKey;
                  requiresAuth = false;
                }
                keyParams = this.encryptionComponentsFromString(encryptedItemKey, keys.mk, keys.ak);

                // return if uuid in auth hash does not match item uuid. Signs of tampering.

                if (!(keyParams.uuid && keyParams.uuid !== item.uuid)) {
                  _context154.next = 26;
                  break;
                }

                console.error("Item key params UUID does not match item UUID");
                if (!item.errorDecrypting) {
                  item.errorDecryptingValueChanged = true;
                }
                item.errorDecrypting = true;
                return _context154.abrupt("return");

              case 26:
                _context154.next = 28;
                return this.crypto.decryptText(keyParams, requiresAuth);

              case 28:
                item_key = _context154.sent;

                if (item_key) {
                  _context154.next = 34;
                  break;
                }

                console.log("Error decrypting item", item);
                if (!item.errorDecrypting) {
                  item.errorDecryptingValueChanged = true;
                }
                item.errorDecrypting = true;
                return _context154.abrupt("return");

              case 34:
                _context154.next = 36;
                return this.crypto.firstHalfOfKey(item_key);

              case 36:
                ek = _context154.sent;
                _context154.next = 39;
                return this.crypto.secondHalfOfKey(item_key);

              case 39:
                ak = _context154.sent;
                itemParams = this.encryptionComponentsFromString(item.content, ek, ak);
                _context154.prev = 41;
                _context154.t3 = JSON;
                _context154.next = 45;
                return this.crypto.base64Decode(itemParams.authParams);

              case 45:
                _context154.t4 = _context154.sent;
                item.auth_params = _context154.t3.parse.call(_context154.t3, _context154.t4);
                _context154.next = 51;
                break;

              case 49:
                _context154.prev = 49;
                _context154.t5 = _context154["catch"](41);

              case 51:
                if (!(itemParams.uuid && itemParams.uuid !== item.uuid)) {
                  _context154.next = 55;
                  break;
                }

                if (!item.errorDecrypting) {
                  item.errorDecryptingValueChanged = true;
                }
                item.errorDecrypting = true;
                return _context154.abrupt("return");

              case 55:

                if (!itemParams.authHash) {
                  // legacy 001
                  itemParams.authHash = item.auth_hash;
                }

                _context154.next = 58;
                return this.crypto.decryptText(itemParams, true);

              case 58:
                content = _context154.sent;

                if (!content) {
                  if (!item.errorDecrypting) {
                    item.errorDecryptingValueChanged = true;
                  }
                  item.errorDecrypting = true;
                } else {
                  if (item.errorDecrypting == true) {
                    item.errorDecryptingValueChanged = true;
                  }
                  // Content should only be set if it was successfully decrypted, and should otherwise remain unchanged.
                  item.errorDecrypting = false;
                  item.content = content;
                }

              case 60:
              case "end":
                return _context154.stop();
            }
          }
        }, _callee153, this, [[3, 11], [41, 49]]);
      }));

      function decryptItem(_x218, _x219) {
        return _ref167.apply(this, arguments);
      }

      return decryptItem;
    }()
  }, {
    key: "decryptMultipleItems",
    value: function () {
      var _ref168 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee155(items, keys, throws) {
        var _this38 = this;

        var decrypt;
        return regeneratorRuntime.wrap(function _callee155$(_context156) {
          while (1) {
            switch (_context156.prev = _context156.next) {
              case 0:
                decrypt = function () {
                  var _ref169 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee154(item) {
                    var isString;
                    return regeneratorRuntime.wrap(function _callee154$(_context155) {
                      while (1) {
                        switch (_context155.prev = _context155.next) {
                          case 0:
                            if (item) {
                              _context155.next = 2;
                              break;
                            }

                            return _context155.abrupt("return");

                          case 2:
                            if (!(item.deleted == true && item.content == null)) {
                              _context155.next = 4;
                              break;
                            }

                            return _context155.abrupt("return");

                          case 4:
                            isString = typeof item.content === 'string' || item.content instanceof String;

                            if (!isString) {
                              _context155.next = 19;
                              break;
                            }

                            _context155.prev = 6;
                            _context155.next = 9;
                            return _this38.decryptItem(item, keys);

                          case 9:
                            _context155.next = 19;
                            break;

                          case 11:
                            _context155.prev = 11;
                            _context155.t0 = _context155["catch"](6);

                            if (!item.errorDecrypting) {
                              item.errorDecryptingValueChanged = true;
                            }
                            item.errorDecrypting = true;

                            if (!throws) {
                              _context155.next = 17;
                              break;
                            }

                            throw _context155.t0;

                          case 17:
                            console.error("Error decrypting item", item, _context155.t0);
                            return _context155.abrupt("return");

                          case 19:
                          case "end":
                            return _context155.stop();
                        }
                      }
                    }, _callee154, _this38, [[6, 11]]);
                  }));

                  return function decrypt(_x223) {
                    return _ref169.apply(this, arguments);
                  };
                }();

                return _context156.abrupt("return", Promise.all(items.map(function (item) {
                  return decrypt(item);
                })));

              case 2:
              case "end":
                return _context156.stop();
            }
          }
        }, _callee155, this);
      }));

      function decryptMultipleItems(_x220, _x221, _x222) {
        return _ref168.apply(this, arguments);
      }

      return decryptMultipleItems;
    }()
  }]);

  return SFItemTransformer;
}();

;var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

var StandardFile = exports.StandardFile = function () {
  function StandardFile(cryptoInstance) {
    _classCallCheck(this, StandardFile);

    // This library runs in native environments as well (react native)
    if (globalScope) {
      // detect IE8 and above, and edge.
      // IE and Edge do not support pbkdf2 in WebCrypto, therefore we need to use CryptoJS
      var IEOrEdge = typeof document !== 'undefined' && document.documentMode || /Edge/.test(navigator.userAgent);

      if (!IEOrEdge && globalScope.crypto && globalScope.crypto.subtle) {
        this.crypto = new SFCryptoWeb();
      } else {
        this.crypto = new SFCryptoJS();
      }
    }

    // This must be placed outside window check, as it's used in native.
    if (cryptoInstance) {
      this.crypto = cryptoInstance;
    }

    this.itemTransformer = new SFItemTransformer(this.crypto);

    this.crypto.SFJS = {
      version: this.version(),
      defaultPasswordGenerationCost: this.defaultPasswordGenerationCost()
    };
  }

  _createClass(StandardFile, [{
    key: "version",
    value: function version() {
      return "003";
    }
  }, {
    key: "supportsPasswordDerivationCost",
    value: function supportsPasswordDerivationCost(cost) {
      // some passwords are created on platforms with stronger pbkdf2 capabilities, like iOS,
      // which CryptoJS can't handle here (WebCrypto can however).
      // if user has high password cost and is using browser that doesn't support WebCrypto,
      // we want to tell them that they can't login with this browser.
      if (cost > 5000) {
        return this.crypto instanceof SFCryptoWeb;
      } else {
        return true;
      }
    }

    // Returns the versions that this library supports technically.

  }, {
    key: "supportedVersions",
    value: function supportedVersions() {
      return ["001", "002", "003"];
    }
  }, {
    key: "isVersionNewerThanLibraryVersion",
    value: function isVersionNewerThanLibraryVersion(version) {
      var libraryVersion = this.version();
      return parseInt(version) > parseInt(libraryVersion);
    }
  }, {
    key: "isProtocolVersionOutdated",
    value: function isProtocolVersionOutdated(version) {
      // YYYY-MM-DD
      var expirationDates = {
        "001": Date.parse("2018-01-01"),
        "002": Date.parse("2020-01-01")
      };

      var date = expirationDates[version];
      if (!date) {
        // No expiration date, is active version
        return false;
      }
      var expired = new Date() > date;
      return expired;
    }
  }, {
    key: "costMinimumForVersion",
    value: function costMinimumForVersion(version) {
      return {
        "001": 3000,
        "002": 3000,
        "003": 110000
      }[version];
    }
  }, {
    key: "defaultPasswordGenerationCost",
    value: function defaultPasswordGenerationCost() {
      return this.costMinimumForVersion(this.version());
    }
  }]);

  return StandardFile;
}();

if (globalScope) {
  // window is for some reason defined in React Native, but throws an exception when you try to set to it
  try {
    globalScope.StandardFile = StandardFile;
    globalScope.SFJS = new StandardFile();
    globalScope.SFCryptoWeb = SFCryptoWeb;
    globalScope.SFCryptoJS = SFCryptoJS;
    globalScope.SFItemTransformer = SFItemTransformer;
    globalScope.SFModelManager = SFModelManager;
    globalScope.SFItem = SFItem;
    globalScope.SFItemParams = SFItemParams;
    globalScope.SFHttpManager = SFHttpManager;
    globalScope.SFStorageManager = SFStorageManager;
    globalScope.SFSyncManager = SFSyncManager;
    globalScope.SFAuthManager = SFAuthManager;
    globalScope.SFMigrationManager = SFMigrationManager;
    globalScope.SFAlertManager = SFAlertManager;
    globalScope.SFPredicate = SFPredicate;
    globalScope.SFHistorySession = SFHistorySession;
    globalScope.SFSessionHistoryManager = SFSessionHistoryManager;
    globalScope.SFItemHistory = SFItemHistory;
    globalScope.SFItemHistoryEntry = SFItemHistoryEntry;
    globalScope.SFPrivilegesManager = SFPrivilegesManager;
    globalScope.SFPrivileges = SFPrivileges;
    globalScope.SFSingletonManager = SFSingletonManager;
  } catch (e) {
    console.log("Exception while exporting window variables", e);
  }
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])(1)
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);
